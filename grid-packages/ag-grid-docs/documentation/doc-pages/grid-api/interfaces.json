{
  "ApplyColumnStateParams": {
    "meta": {},
    "type": {
      "state?": "ColumnState[]",
      "applyOrder?": "boolean",
      "defaultState?": "ColumnState"
    }
  },
  "ColumnResizeSet": {
    "meta": {},
    "type": { "columns": "Column[]", "ratios": "number[]", "width": "number" }
  },
  "ColumnState": {
    "meta": {},
    "type": {
      "colId?": "string",
      "hide?": "boolean | null",
      "aggFunc?": "string | IAggFunc | null",
      "width?": "number",
      "pivot?": "boolean | null",
      "pivotIndex?": "number | null",
      "pinned?": "boolean | string | 'left' | 'right' | null",
      "rowGroup?": "boolean | null",
      "rowGroupIndex?": "number | null",
      "flex?": "number | null",
      "sort?": "string | null",
      "sortIndex?": "number | null"
    }
  },
  "ComponentMetadata": {
    "meta": {},
    "type": {
      "mandatoryMethodList": "string[]",
      "optionalMethodList": "string[]",
      "functionAdapter?": "(callback: any) => {\n    new (): IComponent<any>;\n}"
    }
  },
  "ComponentType": {
    "meta": {},
    "type": { "propertyName": "string", "isCellRenderer()": "boolean" }
  },
  "FrameworkComponentWrapper": {
    "meta": {
      "doc": "/**\n * B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid */"
    },
    "type": {
      "wrap(frameworkComponent: {\n    new (): any;\n} | null, methodList: string[], optionalMethodList: string[], componentType: ComponentType, componentName?: string | null)": "A"
    }
  },
  "WrappableInterface": {
    "meta": {},
    "type": {
      "hasMethod(name: string)": "boolean",
      "callMethod(name: string, args: IArguments)": "void",
      "addMethod(name: string, callback: Function)": "void"
    }
  },
  "DefinitionObject": {
    "meta": { "isTypeAlias": true },
    "type": "GridOptions | ColDef | ColGroupDef | IFilterDef | ISetFilterParams | IRichCellEditorParams | ToolPanelDef | StatusPanelDef"
  },
  "UserCompDetails": {
    "meta": {},
    "type": {
      "componentClass": "any",
      "componentFromFramework": "boolean",
      "params": "any"
    }
  },
  "RegisteredComponent": {
    "meta": {
      "doc": "/**\n * B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid */"
    },
    "type": { "component": "any", "componentFromFramework": "boolean" }
  },
  "DeprecatedComponentName": {
    "meta": {},
    "type": { "propertyHolder": "string", "newComponentName": "string" }
  },
  "ContextParams": {
    "meta": {},
    "type": {
      "providedBeanInstances": "any",
      "beanClasses": "any[]",
      "debug": "boolean"
    }
  },
  "ComponentMeta": {
    "meta": {},
    "type": { "componentClass": "new () => Object", "componentName": "string" }
  },
  "BeanWrapper": {
    "meta": {},
    "type": { "bean": "any", "beanInstance": "any", "beanName": "any" }
  },
  "ReadyParams": {
    "meta": {},
    "type": {
      "gridCtrl": "GridCtrl",
      "gridBodyCtrl": "GridBodyCtrl",
      "centerRowContainerCtrl": "RowContainerCtrl",
      "leftRowContainerCtrl": "RowContainerCtrl",
      "rightRowContainerCtrl": "RowContainerCtrl",
      "bottomCenterRowContainerCtrl": "RowContainerCtrl",
      "bottomLeftRowContainerCtrl": "RowContainerCtrl",
      "bottomRightRowContainerCtrl": "RowContainerCtrl",
      "topCenterRowContainerCtrl": "RowContainerCtrl",
      "topLeftRowContainerCtrl": "RowContainerCtrl",
      "topRightRowContainerCtrl": "RowContainerCtrl",
      "fakeHScrollCtrl": "FakeHScrollCtrl",
      "headerRootComp": "HeaderRootComp"
    }
  },
  "DragItem": {
    "meta": {},
    "type": {
      "rowNode?": "RowNode",
      "rowNodes?": "RowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{\n    [key: string]: boolean;\n}"
    },
    "docs": {
      "rowNode?": "/**\n * When dragging a row, this contains the row node being dragged\n * When dragging multiple rows, this contains the row that started the drag. */",
      "rowNodes?": "/**\n * When dragging multiple rows, this contains all rows being dragged */",
      "columns?": "/**\n * When dragging columns, this contains the columns being dragged */",
      "visibleState?": "/**\n * When dragging columns, this contains the visible state of the columns */"
    }
  },
  "DragSourceType": {
    "meta": { "isEnum": true },
    "type": ["ToolPanel", "HeaderCell", "RowDrag", "ChartPanel"]
  },
  "DragSource": {
    "meta": {},
    "type": {
      "type": "DragSourceType",
      "eElement": "HTMLElement",
      "getDragItem": "() => DragItem",
      "dragItemName": "string | (() => string) | null",
      "defaultIconName?": "string",
      "dragSourceDropTarget?": "DropTarget",
      "dragSourceDomDataKey?": "string",
      "dragStartPixels?": "number",
      "onDragStarted?": "() => void",
      "onDragStopped?": "() => void"
    },
    "docs": {
      "type": "/**\n * The type of the drag source, used by the drop target to know where the\n * drag originated from. */",
      "eElement": "/**\n * Element which, when dragged, will kick off the DnD process */",
      "getDragItem": "/**\n * If eElement is dragged, then the dragItem is the object that gets passed around. */",
      "dragItemName": "/**\n * This name appears in the ghost icon when dragging. */",
      "defaultIconName?": "/**\n * Icon to show when not over a drop zone */",
      "dragSourceDropTarget?": "/**\n * The drop target associated with this dragSource. When dragging starts, this\n * target does not get an onDragEnter event. */",
      "dragSourceDomDataKey?": "/**\n * The drag source DOM Data Key, this is useful to detect if the origin grid is the same\n * as the target grid. */",
      "dragStartPixels?": "/**\n * After how many pixels of dragging should the drag operation start. Default is 4. */",
      "onDragStarted?": "/**\n * Callback for drag started */",
      "onDragStopped?": "/**\n * Callback for drag stopped */"
    }
  },
  "DropTarget": {
    "meta": {},
    "type": {
      "getContainer()": "HTMLElement",
      "getSecondaryContainers?()": "HTMLElement[][]",
      "getIconName?()": "string | null",
      "isInterestedIn(type: DragSourceType)": "boolean",
      "onDragEnter?(params: DraggingEvent)": "void",
      "onDragLeave?(params: DraggingEvent)": "void",
      "onDragging?(params: DraggingEvent)": "void",
      "onDragStop?(params: DraggingEvent)": "void",
      "external?": "boolean"
    },
    "docs": {
      "getContainer()": "/**\n * The main container that will get the drop. */",
      "getSecondaryContainers?()": "/**\n * If any secondary containers. For example when moving columns in AG Grid, we listen for drops\n * in the header as well as the body (main rows and pinned rows) of the grid. */",
      "getIconName?()": "/**\n * Icon to show when drag is over */",
      "onDragEnter?(params: DraggingEvent)": "/**\n * Callback for when drag enters */",
      "onDragLeave?(params: DraggingEvent)": "/**\n * Callback for when drag leaves */",
      "onDragging?(params: DraggingEvent)": "/**\n * Callback for when dragging */",
      "onDragStop?(params: DraggingEvent)": "/**\n * Callback for when drag stops */"
    }
  },
  "VerticalDirection": { "meta": { "isEnum": true }, "type": ["Up", "Down"] },
  "HorizontalDirection": {
    "meta": { "isEnum": true },
    "type": ["Left", "Right"]
  },
  "DraggingEvent": {
    "meta": {},
    "type": {
      "event": "MouseEvent",
      "x": "number",
      "y": "number",
      "vDirection": "VerticalDirection | null",
      "hDirection": "HorizontalDirection | null",
      "dragSource": "DragSource",
      "dragItem": "DragItem",
      "fromNudge": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "dropZoneTarget": "HTMLElement"
    }
  },
  "DragSourceAndListener": {
    "meta": {},
    "type": {
      "dragSource": "DragListenerParams",
      "mouseDownListener": "(mouseEvent: MouseEvent) => void",
      "touchEnabled": "boolean",
      "touchStartListener": "((touchEvent: TouchEvent) => void) | null"
    }
  },
  "DragListenerParams": {
    "meta": {},
    "type": {
      "dragStartPixels?": "number",
      "eElement": "HTMLElement",
      "skipMouseEvent?": "(mouseEvent: MouseEvent) => boolean",
      "onDragStart": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragStop": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragging": "(mouseEvent: MouseEvent | Touch) => void"
    },
    "docs": {
      "dragStartPixels?": "/**\n * After how many pixels of dragging should the drag operation start. Default is 4px. */",
      "eElement": "/**\n * Dom element to add the drag handling to */",
      "skipMouseEvent?": "/**\n * Some places may wish to ignore certain events, eg range selection ignores shift clicks */",
      "onDragStart": "/**\n * Callback for drag starting */",
      "onDragStop": "/**\n * Callback for drag stopping */",
      "onDragging": "/**\n * Callback for mouse move while dragging */"
    }
  },
  "CellPosition": {
    "meta": {},
    "type": {
      "rowIndex": "number",
      "rowPinned": "string | null",
      "column": "Column"
    }
  },
  "AbstractColDef": {
    "meta": {
      "doc": "/**\n * *********************************************************************\n * Don't forget to update ColDefUtil if changing this class. PLEASE! *\n * ********************************************************************* */\n/**\n * AbstractColDef can be a group or a column definition */"
    },
    "type": {
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "string | string[] | ((params: HeaderClassParams) => string | string[])",
      "toolPanelClass?": "string | string[] | ((params: ToolPanelClassParams) => string | string[])",
      "headerValueGetter?": "string | Function",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{\n    new (): ITooltipComp;\n} | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean"
    },
    "docs": {
      "headerName?": "/**\n * The name to render in the column header */",
      "columnGroupShow?": "/**\n * Whether to show the column when the group is open / closed. */",
      "headerClass?": "/**\n * CSS class for the header */",
      "toolPanelClass?": "/**\n * CSS class for the toolPanel */",
      "headerValueGetter?": "/**\n * Expression or function to get the cells value. */",
      "pivotKeys?": "/**\n * Never set this, it is used internally by grid when doing in-grid pivoting */",
      "suppressColumnsToolPanel?": "/**\n * Set to true to not include this column in the Columns Tool Panel */",
      "suppressFiltersToolPanel?": "/**\n * Set to true to not include this column / filter in the Filters Tool Panel */",
      "headerTooltip?": "/**\n * Tooltip for the column header */",
      "suppressHeaderKeyboardEvent?": "/**\n * Allows the user to suppress certain keyboard events in the grid header */"
    }
  },
  "ColGroupDef": {
    "meta": {},
    "type": {
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "string | string[] | ((params: HeaderClassParams) => string | string[])",
      "toolPanelClass?": "string | string[] | ((params: ToolPanelClassParams) => string | string[])",
      "headerValueGetter?": "string | Function",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{\n    new (): ITooltipComp;\n} | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean",
      "children": "(ColDef | ColGroupDef)[]",
      "groupId?": "string",
      "openByDefault?": "boolean",
      "marryChildren?": "boolean",
      "headerGroupComponent?": "string | {\n    new (): IHeaderGroupComp;\n}",
      "headerGroupComponentFramework?": "any",
      "headerGroupComponentParams?": "any"
    },
    "docs": {
      "headerName?": "/**\n * The name to render in the column header */",
      "columnGroupShow?": "/**\n * Whether to show the column when the group is open / closed. */",
      "headerClass?": "/**\n * CSS class for the header */",
      "toolPanelClass?": "/**\n * CSS class for the toolPanel */",
      "headerValueGetter?": "/**\n * Expression or function to get the cells value. */",
      "pivotKeys?": "/**\n * Never set this, it is used internally by grid when doing in-grid pivoting */",
      "suppressColumnsToolPanel?": "/**\n * Set to true to not include this column in the Columns Tool Panel */",
      "suppressFiltersToolPanel?": "/**\n * Set to true to not include this column / filter in the Filters Tool Panel */",
      "headerTooltip?": "/**\n * Tooltip for the column header */",
      "suppressHeaderKeyboardEvent?": "/**\n * Allows the user to suppress certain keyboard events in the grid header */",
      "children": "/**\n * Columns in this group */",
      "groupId?": "/**\n * Group ID */",
      "openByDefault?": "/**\n * Open by Default */",
      "marryChildren?": "/**\n * If true, group cannot be broken up by column moving, child columns will always appear side by side, however you can rearrange child columns within the group */",
      "headerGroupComponent?": "/**\n * The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used* */",
      "headerGroupComponentFramework?": "/**\n * The custom header group component to be used for rendering the component header in the hosting framework (ie: React/Angular). If none specified the default AG Grid is used* */",
      "headerGroupComponentParams?": "/**\n * The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used* */"
    }
  },
  "IAggFunc": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "params": "IAggFuncParams" }, "returnType": "any" }
  },
  "IAggFuncParams": {
    "meta": {},
    "type": {
      "values": "any[]",
      "column": "Column",
      "colDef": "ColDef",
      "rowNode": "RowNode",
      "data": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "HeaderClassParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "colDef": "AbstractColDef",
      "column?": "Column | null",
      "columnGroup?": "ColumnGroup | OriginalColumnGroup | null",
      "context?": "any"
    }
  },
  "ToolPanelClassParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "colDef": "AbstractColDef",
      "column?": "Column | null",
      "columnGroup?": "ColumnGroup | OriginalColumnGroup | null",
      "context?": "any"
    }
  },
  "ColDef": {
    "meta": {
      "doc": "/**\n * *********************************************************************\n * Don't forget to update ColDefUtil if changing this class. PLEASE! *\n * ********************************************************************* */"
    },
    "type": {
      "filter?": "IFilterType",
      "filterFramework?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "string | {\n    new (): IFloatingFilterComp;\n}",
      "floatingFilterComponentParams?": "any",
      "floatingFilterComponentFramework?": "any",
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "string | string[] | ((params: HeaderClassParams) => string | string[])",
      "toolPanelClass?": "string | string[] | ((params: ToolPanelClassParams) => string | string[])",
      "headerValueGetter?": "string | Function",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{\n    new (): ITooltipComp;\n} | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean",
      "colId?": "string",
      "sort?": "string | null",
      "initialSort?": "string",
      "sortIndex?": "number | null",
      "initialSortIndex?": "number",
      "sortedAt?": "number",
      "sortingOrder?": "(string | null)[]",
      "field?": "string",
      "type?": "string | string[]",
      "hide?": "boolean",
      "initialHide?": "boolean",
      "pinned?": "boolean | string | null",
      "initialPinned?": "boolean | string",
      "tooltipField?": "string",
      "tooltipValueGetter?": "(params: ITooltipParams) => string",
      "valueGetter?": "((params: ValueGetterParams) => any) | string",
      "filterValueGetter?": "((params: ValueGetterParams) => any) | string",
      "valueSetter?": "((params: ValueSetterParams) => boolean) | string",
      "keyCreator?": "(value: any) => string",
      "width?": "number",
      "initialWidth?": "number",
      "minWidth?": "number",
      "maxWidth?": "number",
      "flex?": "number",
      "initialFlex?": "number",
      "autoHeight?": "boolean",
      "wrapText?": "boolean",
      "cellClass?": "string | string[] | ((cellClassParams: CellClassParams) => string | string[])",
      "cellStyle?": "{} | ((params: CellClassParams) => {})",
      "cellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "cellRendererFramework?": "any",
      "cellRendererParams?": "any",
      "cellRendererSelector?": "CellRendererSelectorFunc",
      "cellEditor?": "{\n    new (): ICellEditorComp;\n} | string",
      "cellEditorFramework?": "any",
      "cellEditorParams?": "any",
      "cellEditorSelector?": "CellEditorSelectorFunc",
      "cellEditorPopup?": "boolean",
      "cellEditorPopupPosition?": "string",
      "pinnedRowCellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "pinnedRowCellRendererFramework?": "any",
      "pinnedRowCellRendererParams?": "any",
      "valueFormatter?": "((params: ValueFormatterParams) => string) | string",
      "pinnedRowValueFormatter?": "((params: ValueFormatterParams) => string) | string",
      "valueParser?": "((params: ValueParserParams) => any) | string",
      "aggFunc?": "string | IAggFunc | null",
      "initialAggFunc?": "string | IAggFunc",
      "allowedAggFuncs?": "string[]",
      "rowGroupIndex?": "number | null",
      "rowGroup?": "boolean",
      "initialRowGroupIndex?": "number",
      "initialRowGroup?": "boolean",
      "showRowGroup?": "string | boolean",
      "pivotIndex?": "number | null",
      "pivot?": "boolean",
      "initialPivotIndex?": "number",
      "initialPivot?": "boolean",
      "comparator?": "(valueA: any, valueB: any, nodeA: RowNode, nodeB: RowNode, isInverted: boolean) => number",
      "equals?": "(valueA: any, valueB: any) => boolean",
      "pivotComparator?": "(valueA: string, valueB: string) => number",
      "checkboxSelection?": "boolean | ((params: CheckboxSelectionCallbackParams) => boolean)",
      "headerCheckboxSelection?": "boolean | ((params: HeaderCheckboxSelectionCallbackParams) => boolean)",
      "headerCheckboxSelectionFilteredOnly?": "boolean",
      "rowDrag?": "boolean | ((params: RowDragCallbackParams) => boolean)",
      "rowDragText?": "((params: IRowDragItem, dragItemCount: number) => string)",
      "dndSource?": "boolean | ((params: DndSourceCallbackParams) => boolean)",
      "dndSourceOnRowDrag?": "((params: {\n    rowNode: RowNode;\n    dragEvent: DragEvent;\n}) => void)",
      "suppressMenu?": "boolean",
      "menuTabs?": "string[]",
      "sortable?": "boolean",
      "suppressMovable?": "boolean",
      "suppressCellFlash?": "boolean",
      "lockPosition?": "boolean",
      "lockVisible?": "boolean",
      "lockPinned?": "boolean",
      "unSortIcon?": "boolean",
      "suppressSizeToFit?": "boolean",
      "resizable?": "boolean",
      "suppressAutoSize?": "boolean",
      "suppressKeyboardEvent?": "(params: SuppressKeyboardEventParams) => boolean",
      "enableRowGroup?": "boolean",
      "enablePivot?": "boolean",
      "enableValue?": "boolean",
      "editable?": "boolean | ((params: EditableCallbackParams) => boolean)",
      "colSpan?": "(params: ColSpanParams) => number",
      "rowSpan?": "(params: RowSpanParams) => number",
      "suppressPaste?": "boolean | ((params: SuppressPasteCallbackParams) => boolean)",
      "suppressNavigable?": "boolean | ((params: SuppressNavigableCallbackParams) => boolean)",
      "getQuickFilterText?": "(params: GetQuickFilterTextParams) => string",
      "newValueHandler?": "(params: NewValueParams) => boolean",
      "singleClickEdit?": "boolean",
      "template?": "string",
      "templateUrl?": "string",
      "cellClassRules?": "{\n    [cssClassName: string]: (Function | string);\n}",
      "onCellValueChanged?": "Function",
      "onCellClicked?": "(event: CellClickedEvent) => void",
      "onCellDoubleClicked?": "(event: CellDoubleClickedEvent) => void",
      "onCellContextMenu?": "(event: CellContextMenuEvent) => void",
      "icons?": "{\n    [key: string]: Function | string;\n}",
      "enableCellChangeFlash?": "boolean",
      "pivotValueColumn?": "Column | null",
      "pivotTotalColumnIds?": "string[]",
      "headerComponent?": "string | {\n    new (): any;\n}",
      "headerComponentFramework?": "any",
      "headerComponentParams?": "any",
      "floatingFilter?": "boolean",
      "refData?": "{\n    [key: string]: string;\n}",
      "chartDataType?": "'category' | 'series' | 'time' | 'excluded'",
      "columnsMenuParams?": "ColumnsMenuParams"
    },
    "docs": {
      "filter?": "/**\n * One of the built in filter names: [set, number, text], or a filter function */",
      "filterParams?": "/**\n * The filter params are specific to each filter! */",
      "floatingFilterComponent?": "/**\n * The custom component to be used for rendering the floating filter. If none is specified the default AG Grid is used. * */",
      "headerName?": "/**\n * The name to render in the column header */",
      "columnGroupShow?": "/**\n * Whether to show the column when the group is open / closed. */",
      "headerClass?": "/**\n * CSS class for the header */",
      "toolPanelClass?": "/**\n * CSS class for the toolPanel */",
      "headerValueGetter?": "/**\n * Expression or function to get the cells value. */",
      "pivotKeys?": "/**\n * Never set this, it is used internally by grid when doing in-grid pivoting */",
      "suppressColumnsToolPanel?": "/**\n * Set to true to not include this column in the Columns Tool Panel */",
      "suppressFiltersToolPanel?": "/**\n * Set to true to not include this column / filter in the Filters Tool Panel */",
      "headerTooltip?": "/**\n * Tooltip for the column header */",
      "suppressHeaderKeyboardEvent?": "/**\n * Allows the user to suppress certain keyboard events in the grid header */",
      "colId?": "/**\n * The unique ID to give the column. This is optional. If missing, the ID will default to the field.\n * If both field and colId are missing, a unique ID will be generated.\n * This ID is used to identify the column in the API for sorting, filtering etc. */",
      "sort?": "/**\n * If sorting by default, set it here. Set to 'asc' or 'desc' */",
      "sortIndex?": "/**\n * If sorting more than one column by default, specifies order in which the sorting should be applied. */",
      "sortedAt?": "/**\n * @deprecated since v24 - use sortIndex instead\n */",
      "sortingOrder?": "/**\n * The sort order, provide an array with any of the following in any order ['asc','desc',null] */",
      "field?": "/**\n * The field of the row to get the cells data from */",
      "type?": "/**\n * A comma separated string or array of strings containing ColumnType keys which can be used as a template for a column.\n * This helps to reduce duplication of properties when you have a lot of common column properties. */",
      "hide?": "/**\n * Set to true for this column to be hidden. Naturally you might think, it would make more sense to call this field 'visible' and mark it false to hide,\n * however we want all default values to be false and we want columns to be visible by default. */",
      "pinned?": "/**\n * Whether this column is pinned or not. */",
      "tooltipField?": "/**\n * The field where we get the tooltip on the object */",
      "tooltipValueGetter?": "/**\n * The function used to calculate the tooltip of the object, tooltipField takes precedence */",
      "valueGetter?": "/**\n * Expression or function to get the cells value. */",
      "filterValueGetter?": "/**\n * Expression or function to get the cells value for filtering. */",
      "valueSetter?": "/**\n * If not using a field, then this puts the value into the cell */",
      "keyCreator?": "/**\n * Function to return the key for a value - use this if the value is an object (not a primitive type) and you\n * want to a) group by this field or b) use set filter on this field. */",
      "width?": "/**\n * Actual width, in pixels, of the cell */",
      "initialWidth?": "/**\n * Default width, in pixels, of the cell */",
      "minWidth?": "/**\n * Min width, in pixels, of the cell */",
      "maxWidth?": "/**\n * Max width, in pixels, of the cell */",
      "flex?": "/**\n * Sets the grow factor of a column. It specifies how much of the remaining\n * space should be assigned to the column. */",
      "autoHeight?": "/**\n * True if this column should stretch rows height to fit contents */",
      "wrapText?": "/**\n * True if this column should wrap cell contents - typically used with autoHeight */",
      "cellClass?": "/**\n * Class to use for the cell. Can be string, array of strings, or function. */",
      "cellStyle?": "/**\n * An object of css values. Or a function returning an object of css values. */",
      "cellRenderer?": "/**\n * A function for rendering a cell. */",
      "cellEditor?": "/**\n * Cell editor */",
      "pinnedRowCellRenderer?": "/**\n * @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.\n */",
      "pinnedRowCellRendererFramework?": "/**\n * @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.\n */",
      "pinnedRowCellRendererParams?": "/**\n * @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.\n */",
      "valueFormatter?": "/**\n * A function to format a value, should return a string. Not used for CSV export or copy to clipboard, only for UI cell rendering. */",
      "pinnedRowValueFormatter?": "/**\n * @deprecated Use valueFormatter for pinned rows, and check params.node.rowPinned.\n */",
      "valueParser?": "/**\n * Gets called after editing, converts the value in the cell. */",
      "aggFunc?": "/**\n * Name of function to use for aggregation. One of [sum,min,max,first,last] or a function. */",
      "allowedAggFuncs?": "/**\n * Agg funcs allowed on this column. If missing, all installed agg funcs are allowed.\n * Can be eg ['sum','avg']. This will restrict what the GUI allows to select only. */",
      "rowGroupIndex?": "/**\n * To group by this column by default, either provide an index (eg rowGroupIndex=1), or set rowGroup=true. */",
      "showRowGroup?": "/**\n * Set to true to have the grid place the values for the group into the cell, or put the name of a grouped column to just show that group. */",
      "pivotIndex?": "/**\n * To pivot by this column by default, either provide an index (eg pivotIndex=1), or set pivot=true. */",
      "comparator?": "/**\n * Comparator function for custom sorting. */",
      "equals?": "/**\n * Comparator for values, used by renderer to know if values have changed. Cells who's values have not changed don't get refreshed. */",
      "pivotComparator?": "/**\n * Comparator for ordering the pivot columns */",
      "checkboxSelection?": "/**\n * Set to true to render a selection checkbox in the column. */",
      "headerCheckboxSelection?": "/**\n * If true, a 'select all' checkbox will be put into the header */",
      "headerCheckboxSelectionFilteredOnly?": "/**\n * If true, the header checkbox selection will work on filtered items */",
      "rowDrag?": "/**\n * For grid row dragging, set to true to enable row dragging within the grid */",
      "rowDragText?": "/**\n * To configure the text to be displayed in the floating div while dragging a row when rowDrag is true */",
      "dndSource?": "/**\n * For native drag and drop, set to true to enable drag source */",
      "dndSourceOnRowDrag?": "/**\n * For native drag and drop, set to true to allow custom onRowDrag processing */",
      "suppressMenu?": "/**\n * Set to true if no menu should be shown for this column header. */",
      "menuTabs?": "/**\n * The menu tabs to show, and in which order, the valid values for this property are:\n * filterMenuTab, generalMenuTab, columnsMenuTab * */",
      "sortable?": "/**\n * Set to true if sorting allowed for this column. */",
      "suppressMovable?": "/**\n * Set to true to not allow moving this column via dragging it's header */",
      "suppressCellFlash?": "/**\n * Set to true to not flash this column for value changes */",
      "lockPosition?": "/**\n * Set to true to make sure this column is always first. Other columns, if movable, cannot move before this column. */",
      "lockVisible?": "/**\n * Set to true to block the user showing / hiding the column, the column can only be shown / hidden via definitions or API */",
      "lockPinned?": "/**\n * Set to true to block the user pinning the column, the column can only be pinned via definitions or API */",
      "unSortIcon?": "/**\n * Set to true if you want the unsorted icon to be shown when no sort is applied to this column. */",
      "suppressSizeToFit?": "/**\n * Set to true if you want this columns width to be fixed during 'size to fit' operation. */",
      "resizable?": "/**\n * Set to true if this column should be resizable */",
      "suppressAutoSize?": "/**\n * Set to true if you do not want this column to be auto-resizable by double clicking it's edge. */",
      "suppressKeyboardEvent?": "/**\n * Allows the user to suppress certain keyboard events in the grid cell */",
      "enableRowGroup?": "/**\n * If true, GUI will allow adding this columns as a row group */",
      "enablePivot?": "/**\n * If true, GUI will allow adding this columns as a pivot */",
      "enableValue?": "/**\n * If true, GUI will allow adding this columns as a value */",
      "editable?": "/**\n * Set to true if this col is editable, otherwise false. Can also be a function to have different rows editable. */",
      "suppressPaste?": "/**\n * Set to true if this col should not be allowed take new values from the clipboard . */",
      "suppressNavigable?": "/**\n * Set to true if this col should not be navigable with the tab key. Can also be a function to have different rows editable. */",
      "getQuickFilterText?": "/**\n * To create the quick filter text for this column, if toString is not good enough on the value. */",
      "newValueHandler?": "/**\n * Callbacks for editing. See editing section for further details.\n * Return true if the update was successful, or false if not.\n * If false, then skips the UI refresh and no events are emitted.\n * Return false if the values are the same (ie no update). */",
      "singleClickEdit?": "/**\n * If true, this cell will be in editing mode after first click. */",
      "template?": "/**\n * Cell template to use for cell. Useful for AngularJS cells. */",
      "templateUrl?": "/**\n * Cell template URL to load template from to use for cell. Useful for AngularJS cells. */",
      "cellClassRules?": "/**\n * Rules for applying css classes */",
      "onCellValueChanged?": "/**\n * Callbacks for editing.See editing section for further details. */",
      "onCellClicked?": "/**\n * Function callback, gets called when a cell is clicked. */",
      "onCellDoubleClicked?": "/**\n * Function callback, gets called when a cell is double clicked. */",
      "onCellContextMenu?": "/**\n * Function callback, gets called when a cell is right clicked. */",
      "icons?": "/**\n * Icons for this column. Leave blank to use default. */",
      "enableCellChangeFlash?": "/**\n * If true, grid will flash cell after cell is refreshed */",
      "pivotValueColumn?": "/**\n * Never set this, it is used internally by grid when doing in-grid pivoting */",
      "pivotTotalColumnIds?": "/**\n * Never set this, it is used internally by grid when doing in-grid pivoting */",
      "headerComponent?": "/**\n * The custom header component to be used for rendering the component header. If none specified the default AG Grid is used* */",
      "headerComponentFramework?": "/**\n * The custom header component to be used for rendering the component header in the hosting framework (ie: React/Angular). If none specified the default AG Grid is used* */",
      "headerComponentParams?": "/**\n * The custom header component parameters* */",
      "floatingFilter?": "/**\n * Whether to display a floating filter for this column. */",
      "chartDataType?": "/**\n * Defines the column data type used when charting */",
      "columnsMenuParams?": "/**\n * Params to customise the columns menu behaviour and appearance */"
    }
  },
  "ColumnFunctionCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "CheckboxSelectionCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "RowDragCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "DndSourceCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "EditableCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "SuppressPasteCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "SuppressNavigableCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "HeaderCheckboxSelectionCallbackParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "IsColumnFunc": {
    "meta": {
      "isCallSignature": true,
      "doc": "/**\n * @deprecated No longer in use. Replaced with (params: ColumnFunctionCallbackParams) => boolean.\n */"
    },
    "type": {
      "arguments": { "params": "IsColumnFuncParams" },
      "returnType": "boolean"
    }
  },
  "IsColumnFuncParams": {
    "meta": {
      "doc": "/**\n * @deprecated Replaced with ColumnFunctionCallbackParams\n */"
    },
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "GetQuickFilterTextParams": {
    "meta": {},
    "type": {
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any"
    }
  },
  "ColumnsMenuParams": {
    "meta": {},
    "type": {
      "suppressSyncLayoutWithGrid?": "boolean",
      "suppressColumnFilter?": "boolean",
      "suppressColumnSelectAll?": "boolean",
      "suppressColumnExpandAll?": "boolean",
      "contractColumnSelection?": "boolean"
    }
  },
  "BaseColDefParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "BaseWithValueColDefParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "value": "any"
    }
  },
  "ValueGetterParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "getValue": "(field: string) => any"
    }
  },
  "NewValueParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "ValueSetterParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "ValueParserParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "ValueFormatterParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "value": "any"
    }
  },
  "ColSpanParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "RowSpanParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "SuppressKeyboardEventParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "event": "KeyboardEvent",
      "editing": "boolean"
    }
  },
  "SuppressHeaderKeyboardEventParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | ColumnGroup",
      "colDef": "ColDef | ColGroupDef | null",
      "context": "any",
      "headerRowIndex": "number",
      "event": "KeyboardEvent"
    }
  },
  "CellClassParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "colDef": "ColDef",
      "value": "any"
    }
  },
  "SelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellRendererParams | ICellEditorParams" },
      "returnType": "CellRendererSelectorResult | CellEditorSelectorResult"
    }
  },
  "CellRendererSelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellRendererParams" },
      "returnType": "CellRendererSelectorResult"
    }
  },
  "CellEditorSelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellEditorParams" },
      "returnType": "CellEditorSelectorResult"
    }
  },
  "CellRendererSelectorResult": {
    "meta": {},
    "type": {
      "component?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "frameworkComponent?": "any",
      "params?": "any"
    }
  },
  "CellEditorSelectorResult": {
    "meta": {},
    "type": {
      "component?": "{\n    new (): ICellEditorComp;\n} | string",
      "frameworkComponent?": "any",
      "params?": "any"
    }
  },
  "ColumnGroupChild": {
    "meta": {},
    "type": {
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "getUniqueId()": "string",
      "getActualWidth()": "number",
      "getMinWidth()": "number | null | undefined",
      "getLeft()": "number | null",
      "getOldLeft()": "number | null",
      "getDefinition()": "AbstractColDef | null",
      "getColumnGroupShow()": "string | undefined",
      "getParent()": "ColumnGroupChild",
      "isResizable()": "boolean",
      "setParent(parent: ColumnGroup | null)": "void",
      "isEmptyGroup()": "boolean",
      "isMoving()": "boolean",
      "getPinned()": "string | null | undefined"
    }
  },
  "GridOptions": {
    "meta": {},
    "type": {
      "suppressBrowserResizeObserver?": "boolean",
      "rowDragManaged?": "boolean",
      "suppressRowDrag?": "boolean",
      "suppressMoveWhenRowDragging?": "boolean",
      "enableMultiRowDragging?": "boolean",
      "ensureDomOrder?": "boolean",
      "suppressAggFilteredOnly?": "boolean",
      "showOpenedGroup?": "boolean",
      "deltaRowDataMode?": "boolean",
      "deltaColumnMode?": "boolean",
      "applyColumnDefOrder?": "boolean",
      "maintainColumnOrder?": "boolean",
      "immutableData?": "boolean",
      "immutableColumns?": "boolean",
      "scrollbarWidth?": "number",
      "suppressRowClickSelection?": "boolean",
      "suppressRowHoverHighlight?": "boolean",
      "suppressCellSelection?": "boolean",
      "suppressClearOnFillReduction?": "boolean",
      "suppressMaintainUnsortedOrder?": "boolean",
      "sortingOrder?": "(string | null)[]",
      "suppressMultiSort?": "boolean",
      "multiSortKey?": "string",
      "accentedSort?": "boolean",
      "deltaSort?": "boolean",
      "suppressHorizontalScroll?": "boolean",
      "alwaysShowHorizontalScroll?": "boolean",
      "alwaysShowVerticalScroll?": "boolean",
      "debounceVerticalScrollbar?": "boolean",
      "unSortIcon?": "boolean",
      "rowBuffer?": "number",
      "tooltipShowDelay?": "number",
      "tooltipMouseTrack?": "boolean",
      "enableRtl?": "boolean",
      "enableBrowserTooltips?": "boolean",
      "colResizeDefault?": "string",
      "enableCellExpressions?": "boolean",
      "enableCellTextSelection?": "boolean",
      "enableGroupEdit?": "boolean",
      "enterMovesDownAfterEdit?": "boolean",
      "enterMovesDown?": "boolean",
      "suppressMiddleClickScrolls?": "boolean",
      "preventDefaultOnContextMenu?": "boolean",
      "suppressPreventDefaultOnMouseWheel?": "boolean",
      "suppressScrollOnNewData?": "boolean",
      "suppressMenuHide?": "boolean",
      "singleClickEdit?": "boolean",
      "suppressClickEdit?": "boolean",
      "tabIndex?": "number",
      "suppressKeyboardEvent?": "(params: SuppressKeyboardEventParams) => boolean",
      "stopEditingWhenGridLosesFocus?": "boolean",
      "stopEditingWhenCellsLoseFocus?": "boolean",
      "debug?": "boolean",
      "icons?": "{\n    [key: string]: Function | string;\n}",
      "angularCompileRows?": "boolean",
      "angularCompileFilters?": "boolean",
      "suppressLoadingOverlay?": "boolean",
      "suppressNoRowsOverlay?": "boolean",
      "suppressAutoSize?": "boolean",
      "autoSizePadding?": "number",
      "skipHeaderOnAutoSize?": "boolean",
      "animateRows?": "boolean",
      "suppressColumnMoveAnimation?": "boolean",
      "suppressMovableColumns?": "boolean",
      "suppressDragLeaveHidesColumns?": "boolean",
      "suppressMakeColumnVisibleAfterUnGroup?": "boolean",
      "suppressParentsInRowNodes?": "boolean",
      "suppressFieldDotNotation?": "boolean",
      "suppressCopyRowsToClipboard?": "boolean",
      "copyHeadersToClipboard?": "boolean",
      "clipboardDeliminator?": "string",
      "suppressClipboardPaste?": "boolean",
      "suppressClipboardApi?": "boolean",
      "suppressLastEmptyLineOnPaste?": "boolean",
      "suppressAggFuncInHeader?": "boolean",
      "suppressAggAtRootLevel?": "boolean",
      "suppressFocusAfterRefresh?": "boolean",
      "rowModelType?": "string",
      "pivotMode?": "boolean",
      "pivotColumnGroupTotals?": "string",
      "pivotRowTotals?": "string",
      "suppressExpandablePivotGroups?": "boolean",
      "suppressEnterpriseResetOnNewColumns?": "boolean",
      "enableRangeSelection?": "boolean",
      "enableRangeHandle?": "boolean",
      "enableFillHandle?": "boolean",
      "fillHandleDirection?": "string",
      "suppressMultiRangeSelection?": "boolean",
      "rowGroupPanelShow?": "string",
      "pivotPanelShow?": "string",
      "suppressContextMenu?": "boolean",
      "allowContextMenuWithControlKey?": "boolean",
      "rememberGroupStateWhenNewData?": "boolean",
      "suppressModelUpdateAfterUpdateTransaction?": "boolean",
      "viewportRowModelPageSize?": "number",
      "viewportRowModelBufferSize?": "number",
      "enableCellChangeFlash?": "boolean",
      "cellFlashDelay?": "number",
      "cellFadeDelay?": "number",
      "allowShowChangeAfterFilter?": "boolean",
      "quickFilterText?": "string",
      "cacheQuickFilter?": "boolean",
      "aggFuncs?": "{\n    [key: string]: IAggFunc;\n}",
      "suppressColumnVirtualisation?": "boolean",
      "functionsReadOnly?": "boolean",
      "functionsPassive?": "boolean",
      "maxConcurrentDatasourceRequests?": "number",
      "maxBlocksInCache?": "number",
      "purgeClosedRowNodes?": "boolean",
      "domLayout?": "string",
      "suppressChangeDetection?": "boolean",
      "aggregateOnlyChangedColumns?": "boolean",
      "valueCache?": "boolean",
      "valueCacheNeverExpires?": "boolean",
      "batchUpdateWaitMillis?": "number",
      "asyncTransactionWaitMillis?": "number",
      "suppressRowTransform?": "boolean",
      "suppressSetColumnStateEvents?": "boolean",
      "suppressColumnStateEvents?": "boolean",
      "allowDragFromColumnsToolPanel?": "boolean",
      "suppressMaxRenderedRowRestriction?": "boolean",
      "excludeChildrenWhenTreeDataFiltering?": "boolean",
      "undoRedoCellEditing?": "boolean",
      "undoRedoCellEditingLimit?": "number",
      "cacheOverflowSize?": "number",
      "infiniteInitialRowCount?": "number",
      "paginationPageSize?": "number",
      "cacheBlockSize?": "number",
      "blockLoadDebounceMillis?": "number",
      "paginationAutoPageSize?": "boolean",
      "suppressPaginationPanel?": "boolean",
      "pagination?": "boolean",
      "paginateChildRows?": "boolean",
      "editType?": "string",
      "suppressTouch?": "boolean",
      "suppressAsyncEvents?": "boolean",
      "embedFullWidthRows?": "boolean",
      "deprecatedEmbedFullWidthRows?": "boolean",
      "excelStyles?": "ExcelStyle[]",
      "floatingFilter?": "boolean",
      "suppressExcelExport?": "boolean",
      "suppressCsvExport?": "boolean",
      "colWidth?": "number",
      "minColWidth?": "number",
      "maxColWidth?": "number",
      "suppressPropertyNamesCheck?": "boolean",
      "serverSideSortingAlwaysResets?": "boolean",
      "serverSideFilteringAlwaysResets?": "boolean",
      "serverSideStoreType?": "ServerSideStoreType",
      "getServerSideStoreParams?": "(params: GetServerSideStoreParamsParams) => ServerSideStoreParams",
      "isServerSideGroupOpenByDefault?": "(params: IsServerSideGroupOpenByDefaultParams) => boolean",
      "isGroupOpenByDefault?": "(params: IsGroupOpenByDefaultParams) => boolean",
      "statusBar?": "{\n    statusPanels: StatusPanelDef[];\n}",
      "localeText?": "{\n    [key: string]: string;\n}",
      "localeTextFunc?": "(key: string, defaultValue: string) => string",
      "suppressAnimationFrame?": "boolean",
      "defaultColGroupDef?": "Partial<ColGroupDef>",
      "defaultColDef?": "ColDef",
      "defaultExportParams?": "CsvExportParams | ExcelExportParams",
      "defaultCsvExportParams?": "CsvExportParams",
      "defaultExcelExportParams?": "ExcelExportParams",
      "pivotSuppressAutoColumn?": "boolean",
      "groupSelectsChildren?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "groupIncludeFooter?": "boolean",
      "groupIncludeTotalFooter?": "boolean",
      "groupRemoveSingleChildren?": "boolean",
      "groupRemoveLowestSingleChildren?": "boolean",
      "groupHideOpenParents?": "boolean",
      "groupSuppressBlankHeader?": "boolean",
      "autoGroupColumnDef?": "ColDef",
      "enableOldSetFilterModel?": "boolean",
      "enableCharts?": "boolean",
      "groupDisplayType?": "RowGroupingDisplayType",
      "groupMultiAutoColumn?": "boolean",
      "groupUseEntireRow?": "boolean",
      "groupSuppressAutoColumn?": "boolean",
      "context?": "any",
      "rowStyle?": "{\n    [cssProperty: string]: string;\n}",
      "rowClass?": "string | string[]",
      "groupDefaultExpanded?": "number",
      "alignedGrids?": "GridOptions[]",
      "rowSelection?": "string",
      "suppressRowDeselection?": "boolean",
      "rowDeselection?": "boolean",
      "rowMultiSelectWithClick?": "boolean",
      "isRowSelectable?": "IsRowSelectable",
      "overlayLoadingTemplate?": "string",
      "overlayNoRowsTemplate?": "string",
      "rowHeight?": "number",
      "detailRowHeight?": "number",
      "popupParent?": "HTMLElement",
      "masterDetail?": "boolean",
      "keepDetailRows?": "boolean",
      "keepDetailRowsCount?": "number",
      "isRowMaster?": "IsRowMaster",
      "detailCellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "detailCellRendererFramework?": "any",
      "detailCellRendererParams?": "any",
      "detailRowAutoHeight?": "boolean",
      "rowData?": "any[]",
      "pinnedTopRowData?": "any[]",
      "pinnedBottomRowData?": "any[]",
      "sideBar?": "SideBarDef | string | boolean | null",
      "columnDefs?": "(ColDef | ColGroupDef)[]",
      "columnTypes?": "{\n    [key: string]: ColDef;\n}",
      "datasource?": "IDatasource",
      "viewportDatasource?": "IViewportDatasource",
      "serverSideDatasource?": "IServerSideDatasource",
      "headerHeight?": "number",
      "pivotHeaderHeight?": "number",
      "groupHeaderHeight?": "number",
      "pivotGroupHeaderHeight?": "number",
      "floatingFiltersHeight?": "number",
      "paginationNumberFormatter?": "(params: PaginationNumberFormatterParams) => string",
      "postProcessPopup?": "(params: PostProcessPopupParams) => void",
      "frameworkComponents?": "{\n    [p: string]: {\n        new (): any;\n    };\n} | any",
      "components?": "{\n    [p: string]: any;\n}",
      "groupRowRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "groupRowRendererFramework?": "any",
      "groupRowRendererParams?": "any",
      "groupRowInnerRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "groupRowInnerRendererFramework?": "any",
      "createChartContainer?": "(params: ChartRef) => void",
      "fillOperation?": "(params: FillOperationParams) => any",
      "isExternalFilterPresent?()": "boolean",
      "doesExternalFilterPass?(node: RowNode)": "boolean",
      "getRowStyle?": "(params: RowClassParams) => {\n    [cssProperty: string]: string;\n}",
      "getRowClass?": "(params: RowClassParams) => string | string[] | undefined",
      "rowClassRules?": "{\n    [cssClassName: string]: (((params: RowClassParams) => boolean) | string);\n}",
      "getRowHeight?": "(params: RowHeightParams) => number | undefined | null",
      "sendToClipboard?": "(params: SendToClipboardParams) => void",
      "processDataFromClipboard?": "(params: ProcessDataFromClipboardParams) => string[][] | null",
      "navigateToNextHeader?": "(params: NavigateToNextHeaderParams) => HeaderPosition",
      "tabToNextHeader?": "(params: TabToNextHeaderParams) => HeaderPosition",
      "navigateToNextCell?": "(params: NavigateToNextCellParams) => CellPosition",
      "tabToNextCell?": "(params: TabToNextCellParams) => CellPosition",
      "getDocument?": "() => Document",
      "defaultGroupSortComparator?": "(nodeA: RowNode, nodeB: RowNode) => number",
      "defaultGroupOrderComparator?": "(nodeA: RowNode, nodeB: RowNode) => number",
      "loadingCellRenderer?": "{\n    new (): ICellRenderer;\n} | string",
      "loadingCellRendererFramework?": "any",
      "loadingCellRendererParams?": "any",
      "loadingOverlayComponent?": "{\n    new (): ILoadingOverlayComp;\n} | string",
      "loadingOverlayComponentFramework?": "any",
      "loadingOverlayComponentParams?": "any",
      "noRowsOverlayComponent?": "{\n    new (): INoRowsOverlayComp;\n} | string",
      "noRowsOverlayComponentFramework?": "any",
      "noRowsOverlayComponentParams?": "any",
      "fullWidthCellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "fullWidthCellRendererFramework?": "any",
      "fullWidthCellRendererParams?": "any",
      "isFullWidthCell?(rowNode: RowNode)": "boolean",
      "groupRowAggNodes?(nodes: RowNode[])": "any",
      "getBusinessKeyForNode?(node: RowNode)": "string",
      "getDataPath?": "GetDataPath",
      "treeData?": "boolean",
      "treeDataDisplayType?": "TreeDataDisplayType",
      "isServerSideGroup?": "IsServerSideGroup",
      "isApplyServerSideTransaction?": "IsApplyServerSideTransaction",
      "getServerSideGroupKey?": "GetServerSideGroupKey",
      "getContextMenuItems?": "GetContextMenuItems",
      "getMainMenuItems?": "GetMainMenuItems",
      "getChartToolbarItems?": "GetChartToolbarItems",
      "getRowNodeId?": "GetRowNodeIdFunc",
      "getChildCount?(dataItem: any)": "number",
      "processRowPostCreate?(params: ProcessRowParams)": "void",
      "processCellForClipboard?(params: ProcessCellForExportParams)": "any",
      "processHeaderForClipboard?(params: ProcessHeaderForExportParams)": "any",
      "processCellFromClipboard?(params: ProcessCellForExportParams)": "any",
      "processSecondaryColDef?(colDef: ColDef)": "void",
      "processSecondaryColGroupDef?(colGroupDef: ColGroupDef)": "void",
      "postSort?(nodes: RowNode[])": "void",
      "chartThemes?": "string[]",
      "customChartThemes?": "{\n    [name: string]: AgChartTheme;\n}",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "processChartOptions?(params: ProcessChartOptionsParams)": "ChartOptions<any>",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent)": "void",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent)": "void",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent)": "void",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent)": "void",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent)": "void",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent)": "void",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent)": "void",
      "onColumnValueChanged?(event: ColumnValueChangedEvent)": "void",
      "onColumnMoved?(event: ColumnMovedEvent)": "void",
      "onColumnVisible?(event: ColumnVisibleEvent)": "void",
      "onColumnPinned?(event: ColumnPinnedEvent)": "void",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent)": "void",
      "onColumnResized?(event: ColumnResizedEvent)": "void",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent)": "void",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent)": "void",
      "onRowGroupOpened?(event: RowGroupOpenedEvent)": "void",
      "onRowDataChanged?(event: RowDataChangedEvent)": "void",
      "onRowDataUpdated?(event: RowDataUpdatedEvent)": "void",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent)": "void",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent)": "void",
      "onColumnRowGroupChangeRequest?(event: ColumnRowGroupChangeRequestEvent)": "void",
      "onColumnPivotChangeRequest?(event: ColumnPivotChangeRequestEvent)": "void",
      "onColumnValueChangeRequest?(event: ColumnValueChangeRequestEvent)": "void",
      "onColumnAggFuncChangeRequest?(event: ColumnAggFuncChangeRequestEvent)": "void",
      "onModelUpdated?(event: ModelUpdatedEvent)": "void",
      "onCellKeyDown?(event: CellKeyDownEvent | FullWidthCellKeyDownEvent)": "void",
      "onCellKeyPress?(event: CellKeyPressEvent | FullWidthCellKeyPressEvent)": "void",
      "onCellClicked?(event: CellClickedEvent)": "void",
      "onCellMouseDown?(event: CellMouseDownEvent)": "void",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent)": "void",
      "onCellContextMenu?(event: CellContextMenuEvent)": "void",
      "onCellValueChanged?(event: CellValueChangedEvent)": "void",
      "onCellMouseOver?(event: CellMouseOverEvent)": "void",
      "onCellMouseOut?(event: CellMouseOutEvent)": "void",
      "onRowValueChanged?(event: RowValueChangedEvent)": "void",
      "onRowEditingStarted?(event: RowEditingStartedEvent)": "void",
      "onRowEditingStopped?(event: RowEditingStoppedEvent)": "void",
      "onCellEditingStarted?(event: CellEditingStartedEvent)": "void",
      "onCellEditingStopped?(event: CellEditingStoppedEvent)": "void",
      "onCellFocused?(event: CellFocusedEvent)": "void",
      "onRowSelected?(event: RowSelectedEvent)": "void",
      "onSelectionChanged?(event: SelectionChangedEvent)": "void",
      "onFilterOpened?(event: FilterOpenedEvent)": "void",
      "onFilterChanged?(event: FilterChangedEvent)": "void",
      "onFilterModified?(event: FilterModifiedEvent)": "void",
      "onSortChanged?(event: SortChangedEvent)": "void",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent)": "void",
      "onRowClicked?(event: RowClickedEvent)": "void",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent)": "void",
      "onGridReady?(event: GridReadyEvent)": "void",
      "onViewportChanged?(event: ViewportChangedEvent)": "void",
      "onDragStarted?(event: DragStartedEvent)": "void",
      "onDragStopped?(event: DragStoppedEvent)": "void",
      "onPaginationChanged?(event: PaginationChangedEvent)": "void",
      "onRowDragEnter?(event: RowDragEvent)": "void",
      "onRowDragMove?(event: RowDragEvent)": "void",
      "onRowDragLeave?(event: RowDragEvent)": "void",
      "onRowDragEnd?(event: RowDragEvent)": "void",
      "onPasteStart?(event: PasteStartEvent)": "void",
      "onPasteEnd?(event: PasteEndEvent)": "void",
      "onFillStart?(event: FillStartEvent)": "void",
      "onFillEnd?(event: FillEndEvent)": "void",
      "onBodyScroll?(event: BodyScrollEvent)": "void",
      "onFirstDataRendered?(event: FirstDataRenderedEvent)": "void",
      "onExpandOrCollapseAll?(event: ExpandCollapseAllEvent)": "void",
      "onChartCreated?(event: ChartCreated)": "void",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChanged)": "void",
      "onChartOptionsChanged?(event: ChartOptionsChanged)": "void",
      "onChartDestroyed?(event: ChartDestroyed)": "void",
      "onComponentStateChanged?(event: ComponentStateChangedEvent)": "void",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed)": "void",
      "onGridSizeChanged?(event: GridSizeChangedEvent)": "void",
      "api?": "GridApi | null",
      "columnApi?": "ColumnApi | null"
    },
    "docs": {
      "suppressBrowserResizeObserver?": "/**\n * *****************************************************************************************************\n * If you change the properties on this interface, you must also update PropertyKeys to be consistent. *\n * ***************************************************************************************************** */\n/**\n * Set once in init, can never change */",
      "deltaRowDataMode?": "/**\n * @deprecated\n */",
      "deltaColumnMode?": "/**\n * @deprecated\n */",
      "applyColumnDefOrder?": "/**\n * @deprecated\n */",
      "immutableColumns?": "/**\n * @deprecated\n */",
      "suppressKeyboardEvent?": "/**\n * Allows user to suppress certain keyboard events */",
      "stopEditingWhenGridLosesFocus?": "/**\n * @deprecated Use stopEditingWhenCellsLoseFocus instead\n */",
      "rememberGroupStateWhenNewData?": "/**\n * @deprecated - no longer needed, transaction updates keep group state\n */",
      "suppressSetColumnStateEvents?": "/**\n * @deprecated\n */",
      "suppressColumnStateEvents?": "/**\n * @deprecated\n */",
      "deprecatedEmbedFullWidthRows?": "/**\n * @deprecated\n */",
      "floatingFilter?": "/**\n * @deprecated Use floatingFilter on the colDef instead\n */",
      "defaultExportParams?": "/**\n * @deprecated Use defaultCsvExportParams or defaultExcelExportParams\n */",
      "groupMultiAutoColumn?": "/**\n * @deprecated - Use groupDisplayType = 'multipleColumns' instead\n */",
      "groupUseEntireRow?": "/**\n * @deprecated - Use groupDisplayType = 'groupRows' instead\n */",
      "groupSuppressAutoColumn?": "/**\n * @deprecated - Use groupDisplayType = 'custom' instead\n */",
      "rowDeselection?": "/**\n * @deprecated - rowDeselection is now true by default and should be suppressed by using suppressRowDeselection\n */",
      "paginationNumberFormatter?": "/**\n * ****************************************************************************************************\n * If you change the callbacks on this interface, you must also update PropertyKeys to be consistent. *\n * **************************************************************************************************** */",
      "groupRowInnerRenderer?": "/**\n * @deprecated - this is now groupRowRendererParams.innerRenderer\n */",
      "groupRowInnerRendererFramework?": "/**\n * @deprecated - this is now groupRowRendererParams.innerRendererFramework\n */",
      "defaultGroupSortComparator?": "/**\n * @deprecated - Use defaultGroupOrderComparator instead\n */",
      "processChartOptions?(params: ProcessChartOptionsParams)": "/**\n * @deprecated\n */",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent)": "/**\n * ********************************************************************************************************\n * If you change the events on this interface, you do *not* need to update PropertyKeys to be consistent, *\n * as event callbacks are automatically generated.                                                        *\n * ******************************************************************************************************** */\n/** */"
    }
  },
  "RowGroupingDisplayType": {
    "meta": { "isEnum": true },
    "type": [
      "SINGLE_COLUMN = 'singleColumn'",
      "MULTIPLE_COLUMNS = 'multipleColumns'",
      "GROUP_ROWS = 'groupRows'",
      "CUSTOM = 'custom'"
    ]
  },
  "TreeDataDisplayType": {
    "meta": { "isEnum": true },
    "type": ["AUTO = 'auto'", "CUSTOM = 'custom'"]
  },
  "FillOperationParams": {
    "meta": {},
    "type": {
      "event": "MouseEvent",
      "values": "any[]",
      "initialValues": "any[]",
      "currentIndex": "number",
      "currentCellValue": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "direction": "string",
      "column?": "Column",
      "rowNode?": "RowNode"
    }
  },
  "GetDataPath": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "data": "any" }, "returnType": "string[]" }
  },
  "IsServerSideGroup": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "boolean" }
  },
  "IsApplyServerSideTransaction": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "IsApplyServerSideTransactionParams" },
      "returnType": "boolean"
    }
  },
  "IsApplyServerSideTransactionParams": {
    "meta": {},
    "type": {
      "transaction": "ServerSideTransaction",
      "parentNode": "RowNode",
      "storeInfo": "any"
    }
  },
  "GetServerSideGroupKey": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "string" }
  },
  "IsRowMaster": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "boolean" }
  },
  "IsRowSelectable": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "node": "RowNode" }, "returnType": "boolean" }
  },
  "RowClassParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "RowHeightParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "api": "GridApi",
      "context": "any"
    }
  },
  "SendToClipboardParams": { "meta": {}, "type": { "data": "string" } },
  "ProcessChartOptionsParams": {
    "meta": {},
    "type": { "type": "ChartType", "options": "ChartOptions<any>" }
  },
  "ProcessChartParams": {
    "meta": {},
    "type": { "type": "ChartType", "options": "AgChartOptions", "chart": "any" }
  },
  "GetContextMenuItemsParams": {
    "meta": {},
    "type": {
      "defaultItems": "string[] | undefined",
      "column": "Column",
      "node": "RowNode",
      "value": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "GetContextMenuItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetContextMenuItemsParams" },
      "returnType": "(string | MenuItemDef)[]"
    }
  },
  "GetChartToolbarItemsParams": {
    "meta": {},
    "type": {
      "defaultItems?": "ChartMenuOptions[]",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "GetChartToolbarItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetChartToolbarItemsParams" },
      "returnType": "ChartMenuOptions[]"
    }
  },
  "MenuItemDef": {
    "meta": {},
    "type": {
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "() => void",
      "checked?": "boolean",
      "icon?": "HTMLElement | string",
      "subMenu?": "(MenuItemDef | string)[] | IComponent<any>",
      "cssClasses?": "string[]",
      "tooltip?": "string"
    }
  },
  "GetMainMenuItemsParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "defaultItems": "string[]"
    }
  },
  "GetMainMenuItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetMainMenuItemsParams" },
      "returnType": "(string | MenuItemDef)[]"
    }
  },
  "GetRowNodeIdFunc": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "data": "any" }, "returnType": "string" }
  },
  "ProcessRowParams": {
    "meta": {},
    "type": {
      "eRow": "HTMLElement",
      "ePinnedLeftRow": "HTMLElement",
      "ePinnedRightRow": "HTMLElement",
      "rowIndex": "number",
      "node": "RowNode",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "addRenderedRowListener": "(eventType: string, listener: Function) => void",
      "context": "any"
    }
  },
  "NavigateToNextHeaderParams": {
    "meta": {},
    "type": {
      "key": "string",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "event": "KeyboardEvent",
      "headerRowCount": "number"
    }
  },
  "TabToNextHeaderParams": {
    "meta": {},
    "type": {
      "backwards": "boolean",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "headerRowCount": "number"
    }
  },
  "NavigateToNextCellParams": {
    "meta": {},
    "type": {
      "key": "number",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition | null",
      "event": "KeyboardEvent | null"
    }
  },
  "TabToNextCellParams": {
    "meta": {},
    "type": {
      "backwards": "boolean",
      "editing": "boolean",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition"
    }
  },
  "PostProcessPopupParams": {
    "meta": {},
    "type": {
      "column?": "Column | null",
      "rowNode?": "RowNode",
      "ePopup": "HTMLElement",
      "type": "string",
      "eventSource?": "HTMLElement | null",
      "mouseEvent?": "MouseEvent | Touch | null"
    }
  },
  "PaginationNumberFormatterParams": {
    "meta": {},
    "type": { "value": "number" }
  },
  "ProcessDataFromClipboardParams": {
    "meta": {},
    "type": { "data": "string[][]" }
  },
  "ChartRef": {
    "meta": {},
    "type": {
      "chartId": "string",
      "chart": "any",
      "chartElement": "HTMLElement",
      "destroyChart": "() => void"
    }
  },
  "ServerSideStoreType": {
    "meta": { "isEnum": true },
    "type": ["Full = 'full'", "Partial = 'partial'"]
  },
  "ServerSideStoreParams": {
    "meta": {},
    "type": {
      "storeType?": "ServerSideStoreType",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    }
  },
  "GetServerSideStoreParamsParams": {
    "meta": {},
    "type": {
      "level": "number",
      "parentRowNode?": "RowNode",
      "rowGroupColumns": "Column[]",
      "pivotColumns": "Column[]",
      "pivotMode": "boolean"
    }
  },
  "IsServerSideGroupOpenByDefaultParams": {
    "meta": {},
    "type": { "data": "any", "rowNode": "RowNode" }
  },
  "IsGroupOpenByDefaultParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowGroupColumn": "Column",
      "level": "number",
      "field": "string",
      "key": "string"
    }
  },
  "OriginalColumnGroupChild": {
    "meta": {},
    "type": {
      "isVisible()": "boolean",
      "getColumnGroupShow()": "string | undefined",
      "getId()": "string",
      "setOriginalParent(originalParent: OriginalColumnGroup | null)": "void"
    }
  },
  "SetSelectedParams": {
    "meta": {},
    "type": {
      "newValue": "boolean",
      "clearSelection?": "boolean",
      "suppressFinishActions?": "boolean",
      "rangeSelect?": "boolean",
      "groupSelectsFiltered?": "boolean"
    }
  },
  "RowNodeEvent": {
    "meta": {},
    "type": { "type": "string", "node": "RowNode" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "DataChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "oldData": "any",
      "newData": "any",
      "update": "boolean"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "CellChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "column": "Column",
      "newValue": "any",
      "oldValue": "any"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "RowHighlightPosition": {
    "meta": { "isEnum": true },
    "type": ["Above", "Below"]
  },
  "RowPosition": {
    "meta": {},
    "type": { "rowIndex": "number", "rowPinned": "string | null" }
  },
  "ToolPanelDef": {
    "meta": {},
    "type": {
      "id": "string",
      "labelDefault": "string",
      "labelKey": "string",
      "minWidth?": "number",
      "maxWidth?": "number",
      "width?": "number",
      "iconKey": "string",
      "toolPanel?": "{\n    new (): IToolPanelComp;\n} | string",
      "toolPanelFramework?": "any",
      "toolPanelParams?": "any"
    }
  },
  "SideBarDef": {
    "meta": {},
    "type": {
      "toolPanels?": "(ToolPanelDef | string)[]",
      "defaultToolPanel?": "string",
      "hiddenByDefault?": "boolean",
      "position?": "'left' | 'right'"
    }
  },
  "SASS_PROPERTIES": {
    "meta": { "isTypeAlias": true },
    "type": "'headerHeight' | 'headerCellMinWidth' | 'listItemHeight' | 'rowHeight' | 'chartMenuPanelWidth'"
  },
  "HardCodedSize": {
    "meta": {},
    "type": { "[key: string]": "{[key in SASS_PROPERTIES]?: number}" }
  },
  "ModelUpdatedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "animate": "boolean | undefined",
      "keepRenderedRows": "boolean | undefined",
      "newData": "boolean | undefined",
      "newPage": "boolean"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "animate": "/**\n * If true, the grid will try and animate the rows to the new positions */",
      "keepRenderedRows": "/**\n * If true, the grid has new data loaded, eg user called setRowData(), otherwise\n * it's the same data but sorted or filtered, in which case this is true, and rows\n * can animate around (eg rowNode id 24 is the same row node as last time). */",
      "newData": "/**\n * If true, then this update was a result of setRowData() getting called. This\n * gets the grid to scroll to the top again. */",
      "newPage": "/**\n * True when pagination and a new page is navigated to. */"
    }
  },
  "PaginationChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "animate?": "boolean",
      "keepRenderedRows?": "boolean",
      "newData?": "boolean",
      "newPage": "boolean"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "animate?": "/**\n * True if rows were animated to new position */",
      "keepRenderedRows?": "/**\n * True if rows were kept (otherwise complete redraw) */",
      "newData?": "/**\n * True if data was new (i.e user set new data) */",
      "newPage": "/**\n * True if user went to a new page */"
    }
  },
  "AgEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "AgGridEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ToolPanelVisibleChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string | undefined"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnPivotModeChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "VirtualColumnsChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnEverythingChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "NewColumnsLoadedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "GridColumnsChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "DisplayedColumnsChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "RowDataChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "RowDataUpdatedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "PinnedRowDataChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "SelectionChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "FilterChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "afterDataChange?": "boolean",
      "afterFloatingFilter?": "boolean"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "afterDataChange?": "/**\n * True if the filter was changed as a result of data changing */",
      "afterFloatingFilter?": "/**\n * True if filter was changed via floating filter */"
    }
  },
  "FilterModifiedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "filterInstance": "IFilterComp",
      "column": "Column"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "FilterOpenedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | OriginalColumnGroup",
      "source": "FilterRequestSource",
      "eGui": "HTMLElement"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * Column / OriginalColumnGroup that contains the filter */",
      "source": "/**\n * Source of the open request */",
      "eGui": "/**\n * Parent element of the filter */"
    }
  },
  "SortChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "GridReadyEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "DisplayedColumnsWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnHoverChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "BodyHeightChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ComponentStateChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "DragEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "target": "HTMLElement"
    },
    "docs": {
      "type": "/**\n * One of {'cell','row','headerCell','toolPanel'} */",
      "target": "/**\n * The DOM element that started the event. */"
    }
  },
  "DragStartedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "target": "HTMLElement"
    },
    "docs": {
      "type": "/**\n * One of {'cell','row','headerCell','toolPanel'} */",
      "target": "/**\n * The DOM element that started the event. */"
    }
  },
  "DragStoppedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "target": "HTMLElement"
    },
    "docs": {
      "type": "/**\n * One of {'cell','row','headerCell','toolPanel'} */",
      "target": "/**\n * The DOM element that started the event. */"
    }
  },
  "CheckboxChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "id": "string",
      "name": "string",
      "selected?": "boolean",
      "previousValue": "boolean | undefined"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "GridSizeChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "clientWidth": "number",
      "clientHeight": "number"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "clientWidth": "/**\n * The grid's DIV's clientWidth */",
      "clientHeight": "/**\n * The grid's DIV's clientHeight */"
    }
  },
  "RowDragEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "node": "/**\n * The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/**\n * The list of nodes being dragged. */",
      "y": "/**\n * The vertical pixel location the mouse is over. */",
      "vDirection": "/**\n * Direction of the drag, either 'up', 'down' or null. */",
      "event": "/**\n * The underlying mouse move event associated with the drag. */",
      "overIndex": "/**\n * The row index the mouse is dragging over. */",
      "overNode": "/**\n * The row node the mouse is dragging over. */"
    }
  },
  "RowDragEnterEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "node": "/**\n * The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/**\n * The list of nodes being dragged. */",
      "y": "/**\n * The vertical pixel location the mouse is over. */",
      "vDirection": "/**\n * Direction of the drag, either 'up', 'down' or null. */",
      "event": "/**\n * The underlying mouse move event associated with the drag. */",
      "overIndex": "/**\n * The row index the mouse is dragging over. */",
      "overNode": "/**\n * The row node the mouse is dragging over. */"
    }
  },
  "RowDragEndEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "node": "/**\n * The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/**\n * The list of nodes being dragged. */",
      "y": "/**\n * The vertical pixel location the mouse is over. */",
      "vDirection": "/**\n * Direction of the drag, either 'up', 'down' or null. */",
      "event": "/**\n * The underlying mouse move event associated with the drag. */",
      "overIndex": "/**\n * The row index the mouse is dragging over. */",
      "overNode": "/**\n * The row node the mouse is dragging over. */"
    }
  },
  "RowDragMoveEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "node": "/**\n * The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/**\n * The list of nodes being dragged. */",
      "y": "/**\n * The vertical pixel location the mouse is over. */",
      "vDirection": "/**\n * Direction of the drag, either 'up', 'down' or null. */",
      "event": "/**\n * The underlying mouse move event associated with the drag. */",
      "overIndex": "/**\n * The row index the mouse is dragging over. */",
      "overNode": "/**\n * The row node the mouse is dragging over. */"
    }
  },
  "RowDragLeaveEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "node": "/**\n * The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/**\n * The list of nodes being dragged. */",
      "y": "/**\n * The vertical pixel location the mouse is over. */",
      "vDirection": "/**\n * Direction of the drag, either 'up', 'down' or null. */",
      "event": "/**\n * The underlying mouse move event associated with the drag. */",
      "overIndex": "/**\n * The row index the mouse is dragging over. */",
      "overNode": "/**\n * The row node the mouse is dragging over. */"
    }
  },
  "PasteStartEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "PasteEndEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "FillStartEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "FillEndEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "initialRange": "CellRange",
      "finalRange": "CellRange"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ViewportChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "firstRow": "number",
      "lastRow": "number"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "firstRow": "/**\n * Index of the first rendered row */",
      "lastRow": "/**\n * Index of the last rendered row */"
    }
  },
  "FirstDataRenderedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "firstRow": "number",
      "lastRow": "number"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "firstRow": "/**\n * Index of the first rendered row */",
      "lastRow": "/**\n * Index of the last rendered row */"
    }
  },
  "RangeSelectionChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "id?": "string",
      "finished": "boolean",
      "started": "boolean"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ChartCreated": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "chartId": "string"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ChartRangeSelectionChanged": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "id": "string",
      "chartId": "string",
      "cellRange": "CellRangeParams"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ChartOptionsChanged": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "chartId": "string",
      "chartType": "ChartType",
      "chartThemeName": "string",
      "chartOptions": "ChartOptions<any>"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ChartDestroyed": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "chartId": "string"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnGroupOpenedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columnGroup": "OriginalColumnGroup"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ItemsAddedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "items": "RowNode[]"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ScrollDirection": {
    "meta": { "isTypeAlias": true },
    "type": "'horizontal' | 'vertical'"
  },
  "BodyScrollEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "direction": "ScrollDirection",
      "left": "number",
      "top": "number"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "FlashCellsEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cells": "any"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "PaginationPixelOffsetChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "CellFocusedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "rowIndex": "number | null",
      "column": "Column | null",
      "rowPinned?": "string | null",
      "isFullWidthCell": "boolean",
      "forceBrowserFocus?": "boolean",
      "floating": "string | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "rowIndex": "/**\n * Row index of the focused cell */",
      "column": "/**\n * Column of the focused cell */",
      "rowPinned?": "/**\n * either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell": "/**\n * Whether the cell a full width cell or a regular cell */",
      "forceBrowserFocus?": "/**\n * Whether browser focus is also set (false when editing) */"
    }
  },
  "ExpandCollapseAllEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnEventType": {
    "meta": { "isTypeAlias": true },
    "type": "\"sizeColumnsToFit\" | \"autosizeColumns\" | \"alignedGridChanged\" | \"filterChanged\" | \"filterDestroyed\" | \"gridOptionsChanged\" | \"gridInitializing\" | \"toolPanelDragAndDrop\" | \"toolPanelUi\" | \"uiColumnMoved\" | \"uiColumnResized\" | \"uiColumnDragged\" | \"uiColumnExpanded\" | \"uiColumnSorted\" | \"contextMenu\" | \"columnMenu\" | \"rowModelUpdated\" | \"api\" | \"flex\" | \"pivotChart\""
  },
  "ColumnEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */"
    }
  },
  "ColumnResizedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "finished": "boolean",
      "flexColumns": "Column[] | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */",
      "finished": "/**\n * Set to true for last event in a sequence of move events */",
      "flexColumns": "/**\n * Any columns resized due to flex */"
    }
  },
  "ColumnPivotChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */"
    }
  },
  "ColumnRowGroupChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */"
    }
  },
  "ColumnValueChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */"
    }
  },
  "ColumnMovedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "toIndex?": "number"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */",
      "toIndex?": "/**\n * The position the column was moved to */"
    }
  },
  "ColumnVisibleEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "visible?": "boolean"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */",
      "visible?": "/**\n * True if column was set to visible, false if set to hide */"
    }
  },
  "ColumnPinnedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "pinned": "string | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "column": "/**\n * The impacted column, only set if action was on one column */",
      "columns": "/**\n * List of all impacted columns */",
      "source": "/**\n * String describing where the event is coming from */",
      "pinned": "/**\n * Either 'left', 'right', or null (it not pinned) */"
    }
  },
  "RowEvent": {
    "meta": {
      "doc": "/**\n * ------------ */\n/**\n * ROW EVENTS */\n/**\n * ------------ */"
    },
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "RowGroupOpenedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "expanded": "boolean"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "expanded": "/**\n * True if the group is expanded. */"
    }
  },
  "RowValueChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "RowSelectedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "VirtualRowRemovedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "RowClickedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "RowDoubleClickedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "RowEditingStartedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "RowEditingStoppedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "FullWidthCellKeyDownEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "FullWidthCellKeyPressEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */"
    }
  },
  "CellEvent": {
    "meta": {
      "doc": "/**\n * ------------ */\n/**\n * CELL EVENTS */\n/**\n * ------------ */"
    },
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellKeyDownEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellKeyPressEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellClickedEvent": {
    "meta": { "doc": "/**\n * Cell is clicked */" },
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellMouseDownEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellDoubleClickedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellMouseOverEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellMouseOutEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellContextMenuEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellEditingStartedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "CellEditingStoppedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "oldValue": "any",
      "newValue": "any"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */",
      "oldValue": "/**\n * The old value before editing */",
      "newValue": "/**\n * The new value after editing */"
    }
  },
  "CellValueChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "oldValue": "any",
      "newValue": "any",
      "source": "string | undefined"
    },
    "docs": {
      "type": "/**\n * Event identifier */",
      "data": "/**\n * The user provided data for the row */",
      "rowIndex": "/**\n * The visible row index for the row */",
      "rowPinned": "/**\n * Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/**\n * Bag of attributes, provided by user */",
      "event?": "/**\n * If event was due to browser event (eg click), this is the browser event */",
      "value": "/**\n * The value for the cell */"
    }
  },
  "AsyncTransactionsFlushed": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "results": "(RowNodeTransaction | ServerSideTransactionResult)[]"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnRowGroupChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnPivotChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnValueChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColumnAggFuncChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]",
      "aggFunc": "any"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ScrollVisibilityChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "StoreUpdatedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "LeftPinnedWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "RightPinnedWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "RowContainerHeightChanged": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "DisplayedRowsChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "IFilterLocaleText": {
    "meta": {},
    "type": {
      "applyFilter": "string",
      "clearFilter": "string",
      "resetFilter": "string",
      "cancelFilter": "string",
      "filterOoo": "string",
      "empty": "string",
      "equals": "string",
      "notEqual": "string",
      "lessThan": "string",
      "greaterThan": "string",
      "inRange": "string",
      "inRangeStart": "string",
      "inRangeEnd": "string",
      "lessThanOrEqual": "string",
      "greaterThanOrEqual": "string",
      "contains": "string",
      "notContains": "string",
      "startsWith": "string",
      "endsWith": "string",
      "andCondition": "string",
      "orCondition": "string",
      "dateFormatOoo": "string"
    }
  },
  "IFilterTitleLocaleText": {
    "meta": {},
    "type": {
      "textFilter": "string",
      "numberFilter": "string",
      "dateFilter": "string",
      "setFilter": "string"
    }
  },
  "FilterRequestSource": {
    "meta": { "isTypeAlias": true },
    "type": "'COLUMN_MENU' | 'TOOLBAR' | 'NO_UI'"
  },
  "FilterWrapper": {
    "meta": {},
    "type": {
      "compiledElement": "any",
      "column": "Column",
      "filterPromise": "AgPromise<IFilterComp> | null",
      "scope": "any",
      "guiPromise": "AgPromise<HTMLElement | null>"
    }
  },
  "IFloatingFilterParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "filterParams": "IFilterParams",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: (filterInstance: IFilterComp) => void) => void",
      "showParentFilter": "() => void",
      "suppressFilterButton": "boolean",
      "api": "GridApi",
      "onFloatingFilterChanged": "(change: any) => boolean"
    },
    "docs": {
      "onFloatingFilterChanged": "/**\n * @deprecated in v21, use parentFilterInstance() callback instead and tell filter directly\n */"
    }
  },
  "IFloatingFilter": {
    "meta": {},
    "type": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void"
    }
  },
  "IFloatingFilterComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IFloatingFilterParams)": "AgPromise<void> | void",
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IFloatingFilterParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "BaseFloatingFilterChange": {
    "meta": {},
    "type": { "model": "ProvidedFilterModel", "apply": "boolean" }
  },
  "DateFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "string",
      "type?": "string | null",
      "dateFrom": "string | null",
      "dateTo": "string | null"
    }
  },
  "IDateFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator",
      "comparator?": "IDateComparatorFunc",
      "browserDatePicker?": "boolean",
      "minValidYear?": "number"
    },
    "docs": {
      "clearButton?": "/**\n * @deprecated\n */",
      "resetButton?": "/**\n * @deprecated\n */",
      "applyButton?": "/**\n * @deprecated\n */",
      "newRowsAction?": "/**\n * @deprecated\n */",
      "nullComparator?": "/**\n * @deprecated in v21\n */"
    }
  },
  "IDateComparatorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "filterLocalDateAtMidnight": "Date", "cellValue": "any" },
      "returnType": "number"
    }
  },
  "NumberFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "string",
      "type?": "string | null",
      "filter?": "number | null",
      "filterTo?": "number | null"
    }
  },
  "INumberFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator",
      "allowedCharPattern?": "string",
      "numberParser?": "(text: string | null) => number"
    },
    "docs": {
      "clearButton?": "/**\n * @deprecated\n */",
      "resetButton?": "/**\n * @deprecated\n */",
      "applyButton?": "/**\n * @deprecated\n */",
      "newRowsAction?": "/**\n * @deprecated\n */",
      "nullComparator?": "/**\n * @deprecated in v21\n */"
    }
  },
  "FilterButtonType": {
    "meta": { "isTypeAlias": true },
    "type": "'apply' | 'clear' | 'reset' | 'cancel'"
  },
  "IProvidedFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number"
    },
    "docs": {
      "clearButton?": "/**\n * @deprecated\n */",
      "resetButton?": "/**\n * @deprecated\n */",
      "applyButton?": "/**\n * @deprecated\n */",
      "newRowsAction?": "/**\n * @deprecated\n */"
    }
  },
  "NullComparator": {
    "meta": { "doc": "/**\n * @deprecated in v21\n */" },
    "type": {
      "equals?": "boolean",
      "lessThan?": "boolean",
      "greaterThan?": "boolean"
    }
  },
  "IScalarFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator"
    },
    "docs": {
      "clearButton?": "/**\n * @deprecated\n */",
      "resetButton?": "/**\n * @deprecated\n */",
      "applyButton?": "/**\n * @deprecated\n */",
      "newRowsAction?": "/**\n * @deprecated\n */",
      "nullComparator?": "/**\n * @deprecated in v21\n */"
    }
  },
  "Comparator": {
    "meta": { "isCallSignature": true, "typeParams": ["T"] },
    "type": {
      "arguments": { "left": "T", "right": "T" },
      "returnType": "number"
    }
  },
  "JoinOperator": { "meta": { "isTypeAlias": true }, "type": "'AND' | 'OR'" },
  "ISimpleFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean"
    },
    "docs": {
      "clearButton?": "/**\n * @deprecated\n */",
      "resetButton?": "/**\n * @deprecated\n */",
      "applyButton?": "/**\n * @deprecated\n */",
      "newRowsAction?": "/**\n * @deprecated\n */"
    }
  },
  "ISimpleFilterModel": {
    "meta": {},
    "type": { "filterType?": "string", "type?": "string | null" }
  },
  "ICombinedSimpleModel": {
    "meta": { "typeParams": ["M extends ISimpleFilterModel"] },
    "type": {
      "filterType?": "string",
      "operator": "JoinOperator",
      "condition1": "M",
      "condition2": "M"
    }
  },
  "ConditionPosition": { "meta": { "isEnum": true }, "type": ["One", "Two"] },
  "TextFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "string",
      "type?": "string | null",
      "filter?": "string | null"
    }
  },
  "TextComparator": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": {
        "filter": "string | null | undefined",
        "gridValue": "any",
        "filterText": "string | null"
      },
      "returnType": "boolean"
    }
  },
  "TextFormatter": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "from": "string | null" },
      "returnType": "string | null"
    }
  },
  "ITextFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "textCustomComparator?": "TextComparator",
      "caseSensitive?": "boolean",
      "textFormatter?": "(from: string) => string",
      "trimInput?": "boolean"
    },
    "docs": {
      "clearButton?": "/**\n * @deprecated\n */",
      "resetButton?": "/**\n * @deprecated\n */",
      "applyButton?": "/**\n * @deprecated\n */",
      "newRowsAction?": "/**\n * @deprecated\n */"
    }
  },
  "GridParams": {
    "meta": {},
    "type": {
      "globalEventListener?": "Function",
      "$scope?": "any",
      "$compile?": "any",
      "frameworkOverrides?": "IFrameworkOverrides",
      "providedBeanInstances?": "{\n    [key: string]: any;\n}",
      "modules?": "Module[]"
    }
  },
  "StartEditingCellParams": {
    "meta": {},
    "type": {
      "rowIndex": "number",
      "colKey": "string | Column",
      "rowPinned?": "string",
      "keyPress?": "number",
      "charPress?": "string"
    }
  },
  "GetCellsParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" }
  },
  "RefreshCellsParams": {
    "meta": {},
    "type": {
      "rowNodes?": "RowNode[]",
      "columns?": "(string | Column)[]",
      "force?": "boolean",
      "suppressFlash?": "boolean"
    }
  },
  "FlashCellsParams": {
    "meta": {},
    "type": {
      "rowNodes?": "RowNode[]",
      "columns?": "(string | Column)[]",
      "flashDelay?": "number",
      "fadeDelay?": "number"
    }
  },
  "GetCellRendererInstancesParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" }
  },
  "GetCellEditorInstancesParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" }
  },
  "RedrawRowsParams": { "meta": {}, "type": { "rowNodes?": "RowNode[]" } },
  "CreateRangeChartParams": {
    "meta": {},
    "type": {
      "cellRange": "CellRangeParams",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean",
      "processChartOptions?": "(params: ProcessChartOptionsParams) => ChartOptions<any>"
    },
    "docs": {
      "processChartOptions?": "/**\n * @deprecated since v24.0.0, use `chartThemeOverrides` instead\n */"
    }
  },
  "CreatePivotChartParams": {
    "meta": {},
    "type": {
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean",
      "processChartOptions?": "(params: ProcessChartOptionsParams) => ChartOptions<any>"
    },
    "docs": {
      "processChartOptions?": "/**\n * @deprecated since v24.0.0, use `chartThemeOverrides` instead\n */"
    }
  },
  "CreateCrossFilterChartParams": {
    "meta": {},
    "type": {
      "cellRange": "CellRangeParams",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    }
  },
  "DetailGridInfo": {
    "meta": {},
    "type": { "api?": "GridApi", "columnApi?": "ColumnApi", "id": "string" }
  },
  "IFakeHScrollComp": {
    "meta": {},
    "type": {
      "setHeight(height: number)": "void",
      "setViewportHeight(height: number)": "void",
      "setContainerHeight(height: number)": "void",
      "setRightSpacerFixedWidth(width: number)": "void",
      "setLeftSpacerFixedWidth(width: number)": "void",
      "setInvisibleStyles(isInvisible: boolean)": "void",
      "includeLeftSpacerScrollerCss(cssClass: string, include: boolean)": "void",
      "includeRightSpacerScrollerCss(cssClass: string, include: boolean)": "void"
    }
  },
  "RowAnimationCssClasses": {
    "meta": { "isEnum": true },
    "type": [
      "ANIMATION_ON = 'ag-row-animation'",
      "ANIMATION_OFF = 'ag-row-no-animation'"
    ]
  },
  "IGridBodyComp": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void",
      "setColumnMovingCss(cssClass: string | null, on: boolean)": "void",
      "setCellSelectableCss(cssClass: string | null, on: boolean)": "void",
      "setTopHeight(height: number)": "void",
      "setTopDisplay(display: string)": "void",
      "setBottomHeight(height: number)": "void",
      "setBottomDisplay(display: string)": "void",
      "setColumnCount(count: number)": "void",
      "setRowCount(count: number)": "void",
      "setRowAnimationCssOnBodyViewport(cssClass: string, animate: boolean)": "void",
      "setAlwaysVerticalScrollClass(cssClass: string | null, on: boolean)": "void",
      "setPinnedTopBottomOverflowY(overflow: string)": "void",
      "registerBodyViewportResizeListener(listener: (() => void))": "void"
    }
  },
  "NavigateParams": {
    "meta": {},
    "type": {
      "scrollIndex": "number",
      "scrollType": "'top' | 'bottom' | null",
      "scrollColumn": "Column | null",
      "focusIndex": "number",
      "focusColumn": "Column"
    }
  },
  "RenderParams": { "meta": {}, "type": { "rows": "RowNode" } },
  "RenderRowsFeature": {
    "meta": {},
    "type": { "render(rows: RowNode[])": "void" }
  },
  "RowContainerName": {
    "meta": { "isEnum": true },
    "type": [
      "LEFT = 'left'",
      "RIGHT = 'right'",
      "CENTER = 'center'",
      "FULL_WIDTH = 'fullWidth'",
      "TOP_LEFT = 'topLeft'",
      "TOP_RIGHT = 'topRight'",
      "TOP_CENTER = 'topCenter'",
      "TOP_FULL_WITH = 'topFullWidth'",
      "BOTTOM_LEFT = 'bottomLeft'",
      "BOTTOM_RIGHT = 'bottomRight'",
      "BOTTOM_CENTER = 'bottomCenter'",
      "BOTTOM_FULL_WITH = 'bottomFullWidth'"
    ]
  },
  "IRowContainerComp": {
    "meta": {},
    "type": {
      "setViewportHeight(height: string)": "void",
      "setRowCtrls(rowCtrls: RowCtrl[])": "void",
      "setDomOrder(domOrder: boolean)": "void",
      "setContainerWidth(width: string)": "void"
    }
  },
  "RowDropZoneEvents": {
    "meta": {},
    "type": {
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void"
    }
  },
  "RowDropZoneParams": {
    "meta": {},
    "type": {
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void",
      "getContainer": "() => HTMLElement"
    }
  },
  "SetScrollsVisibleParams": {
    "meta": {},
    "type": {
      "horizontalScrollShowing": "boolean",
      "verticalScrollShowing": "boolean"
    }
  },
  "IGridComp": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void",
      "setRtlClass(cssClass: string)": "void",
      "destroyGridUi()": "void",
      "forceFocusOutOfContainer(up: boolean)": "void",
      "addOrRemoveKeyboardFocusClass(value: boolean)": "void",
      "getFocusableContainers()": "HTMLElement[]",
      "setCursor(value: string | null)": "void",
      "setUserSelect(value: string | null)": "void"
    }
  },
  "PropertyChangedEvent": {
    "meta": {},
    "type": { "type": "string", "currentValue": "any", "previousValue": "any" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "DropListener": {
    "meta": {},
    "type": {
      "getIconName()": "string | null",
      "onDragEnter(params: DraggingEvent)": "void",
      "onDragLeave(params: DraggingEvent)": "void",
      "onDragging(params: DraggingEvent)": "void",
      "onDragStop(params: DraggingEvent)": "void"
    }
  },
  "IHeaderParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "displayName": "string",
      "enableSorting": "boolean",
      "enableMenu": "boolean",
      "showColumnMenu": "(source: HTMLElement) => void",
      "progressSort": "(multiSort?: boolean) => void",
      "setSort": "(sort: string, multiSort?: boolean) => void",
      "columnApi": "ColumnApi",
      "eGridHeader": "HTMLElement",
      "api": "GridApi",
      "context": "any",
      "template": "string"
    }
  },
  "IHeader": {
    "meta": {},
    "type": { "refresh(params: IHeaderParams)": "boolean" },
    "docs": {
      "refresh(params: IHeaderParams)": "/**\n * Get the header to refresh. Gets called whenever Column Defs are updated. */"
    }
  },
  "IHeaderComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IHeaderParams)": "AgPromise<void> | void",
      "refresh(params: IHeaderParams)": "boolean"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IHeaderParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */",
      "refresh(params: IHeaderParams)": "/**\n * Get the header to refresh. Gets called whenever Column Defs are updated. */"
    }
  },
  "HeaderNavigationDirection": {
    "meta": { "isEnum": true },
    "type": ["UP", "DOWN", "LEFT", "RIGHT"]
  },
  "HeaderPosition": {
    "meta": {},
    "type": { "headerRowIndex": "number", "column": "Column | ColumnGroup" }
  },
  "SelectionCount": {
    "meta": {},
    "type": { "selected": "number", "notSelected": "number" }
  },
  "IHeaderGroupParams": {
    "meta": {},
    "type": {
      "columnGroup": "ColumnGroup",
      "displayName": "string",
      "setExpanded": "(expanded: boolean) => void",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "IHeaderGroup": { "meta": {}, "type": {} },
  "IHeaderGroupComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IHeaderGroupParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IHeaderGroupParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "HeaderContainerPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'left' | 'right' | 'center'"
  },
  "HeaderRowType": {
    "meta": { "isEnum": true },
    "type": ["COLUMN_GROUP", "COLUMN", "FLOATING_FILTER"]
  },
  "HorizontalResizeParams": {
    "meta": {},
    "type": {
      "eResizeBar": "HTMLElement",
      "dragStartPixels?": "number",
      "onResizeStart": "(shiftKey: boolean) => void",
      "onResizing": "(delta: number) => void",
      "onResizeEnd": "(delta: number) => void"
    }
  },
  "ILogger": { "meta": {}, "type": { "log(message: string)": "void" } },
  "BaseExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean"
    },
    "docs": {
      "columnGroups?": "/**\n * @deprecated\n */",
      "skipGroups?": "/**\n * @deprecated\n */",
      "skipHeader?": "/**\n * @deprecated\n */"
    }
  },
  "ExportParams": {
    "meta": { "typeParams": ["T"] },
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean",
      "prependContent?": "T",
      "appendContent?": "T",
      "customHeader?": "T",
      "customFooter?": "T",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => T | undefined"
    },
    "docs": {
      "columnGroups?": "/**\n * @deprecated\n */",
      "skipGroups?": "/**\n * @deprecated\n */",
      "skipHeader?": "/**\n * @deprecated\n */",
      "customHeader?": "/**\n * @deprecated Use prependContent\n */",
      "customFooter?": "/**\n * @deprecated Use appendContent\n */"
    }
  },
  "PackageFileParams": { "meta": { "typeParams": ["T"] }, "type": {} },
  "CsvCell": {
    "meta": {},
    "type": { "data": "CsvCellData", "mergeAcross?": "number" }
  },
  "CsvCellData": { "meta": {}, "type": { "value": "string | null" } },
  "CsvCustomContent": {
    "meta": { "isTypeAlias": true },
    "type": "CsvCell[][] | string"
  },
  "CsvExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean",
      "prependContent?": "CsvCustomContent",
      "appendContent?": "CsvCustomContent",
      "customHeader?": "CsvCustomContent",
      "customFooter?": "CsvCustomContent",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => CsvCustomContent | undefined",
      "columnSeparator?": "string",
      "suppressQuotes?": "boolean"
    },
    "docs": {
      "columnGroups?": "/**\n * @deprecated\n */",
      "skipGroups?": "/**\n * @deprecated\n */",
      "skipHeader?": "/**\n * @deprecated\n */",
      "customHeader?": "/**\n * @deprecated Use prependContent\n */",
      "customFooter?": "/**\n * @deprecated Use appendContent\n */"
    }
  },
  "ShouldRowBeSkippedParams": {
    "meta": {},
    "type": { "node": "RowNode", "api": "GridApi", "context": "any" }
  },
  "ProcessCellForExportParams": {
    "meta": {},
    "type": {
      "value": "any",
      "accumulatedRowIndex?": "number",
      "node?": "RowNode | null",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "type": "string"
    }
  },
  "ProcessHeaderForExportParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "ProcessGroupHeaderForExportParams": {
    "meta": {},
    "type": {
      "columnGroup": "ColumnGroup",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "ProcessRowGroupForExportParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "ContainerType": {
    "meta": { "isTypeAlias": true },
    "type": "'columnMenu' | 'contextMenu' | 'toolPanel' | 'floatingFilter'"
  },
  "IAfterGuiAttachedParams": {
    "meta": {},
    "type": {
      "container?": "ContainerType",
      "hidePopup?": "() => void",
      "suppressFocus?": "boolean"
    }
  },
  "FontStyle": {
    "meta": { "isTypeAlias": true },
    "type": "'normal' | 'italic' | 'oblique'"
  },
  "FontWeight": {
    "meta": { "isTypeAlias": true },
    "type": "'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'"
  },
  "AgChartThemeName": {
    "meta": { "isTypeAlias": true },
    "type": "'ag-default' | 'ag-default-dark' | 'ag-material' | 'ag-material-dark' | 'ag-pastel' | 'ag-pastel-dark' | 'ag-solar' | 'ag-solar-dark' | 'ag-vivid' | 'ag-vivid-dark'"
  },
  "AgChartThemePalette": {
    "meta": {},
    "type": { "fills": "string[]", "strokes": "string[]" }
  },
  "AgChartThemeOptions": {
    "meta": {},
    "type": {
      "palette?": "AgChartThemePalette",
      "overrides?": "AgChartThemeOverrides"
    }
  },
  "AgChartTheme": {
    "meta": {},
    "type": {
      "palette?": "AgChartThemePalette",
      "overrides?": "AgChartThemeOverrides",
      "baseTheme?": "AgChartThemeName"
    }
  },
  "AgChartThemeOverrides": {
    "meta": {},
    "type": {
      "cartesian?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgCartesianSeriesTheme>",
      "column?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgBarSeriesOptions>",
      "bar?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgBarSeriesOptions>",
      "line?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgLineSeriesOptions>",
      "area?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgAreaSeriesOptions>",
      "scatter?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgScatterSeriesOptions>",
      "histogram?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgHistogramSeriesOptions>",
      "polar?": "AgPolarChartOptions<AgPolarAxesTheme, AgPolarSeriesTheme>",
      "pie?": "AgPolarChartOptions<AgPolarAxesTheme, AgPieSeriesOptions>",
      "common?": "any"
    }
  },
  "AgCartesianAxesTheme": {
    "meta": {},
    "type": {
      "number?": "Omit<AgNumberAxisOptions, 'type'>",
      "category?": "Omit<AgCategoryAxisOptions, 'type'>",
      "groupedCategory?": "Omit<AgGroupedCategoryAxisOptions, 'type'>",
      "time?": "Omit<AgTimeAxisOptions, 'type'>"
    }
  },
  "AgCartesianSeriesTheme": {
    "meta": {},
    "type": {
      "line?": "AgLineSeriesOptions",
      "scatter?": "AgScatterSeriesOptions",
      "area?": "AgAreaSeriesOptions",
      "bar?": "AgBarSeriesOptions",
      "histogram?": "AgHistogramSeriesOptions"
    }
  },
  "AgPolarAxesTheme": { "meta": {}, "type": {} },
  "AgPolarSeriesTheme": {
    "meta": {},
    "type": { "pie?": "AgPieSeriesOptions" }
  },
  "AgChartPaddingOptions": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number"
    }
  },
  "AgChartLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgDropShadowOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "color?": "string",
      "xOffset?": "number",
      "yOffset?": "number",
      "blue?": "number"
    }
  },
  "AgChartCaptionOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "text?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgNavigatorMaskOptions": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "fillOpacity?": "number"
    }
  },
  "AgNavigatorHandleOptions": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "width?": "number",
      "height?": "number",
      "gripLineGap?": "number",
      "gripLineLength?": "number"
    }
  },
  "AgNavigatorOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "height?": "number",
      "margin?": "number",
      "min?": "number",
      "max?": "number",
      "mask?": "AgNavigatorMaskOptions",
      "minHandle?": "AgNavigatorHandleOptions",
      "maxHandle?": "AgNavigatorHandleOptions"
    }
  },
  "AgChartLegendPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'top' | 'right' | 'bottom' | 'left'"
  },
  "AgChartLegendMarkerOptions": {
    "meta": {},
    "type": {
      "size?": "number",
      "shape?": "string | (new () => any)",
      "padding?": "number",
      "strokeWidth?": "number"
    }
  },
  "AgChartLegendLabelOptions": {
    "meta": {},
    "type": {
      "color?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string"
    }
  },
  "AgChartLegendItemOptions": {
    "meta": {},
    "type": {
      "marker?": "AgChartLegendMarkerOptions",
      "label?": "AgChartLegendLabelOptions",
      "paddingX?": "number",
      "paddingY?": "number"
    }
  },
  "AgChartLegendOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "position?": "AgChartLegendPosition",
      "spacing?": "number",
      "item?": "AgChartLegendItemOptions",
      "layoutHorizontalSpacing?": "number",
      "layoutVerticalSpacing?": "number",
      "itemSpacing?": "number",
      "markerShape?": "string | (new () => any)",
      "markerSize?": "number",
      "strokeWidth?": "number",
      "color?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string"
    },
    "docs": {
      "layoutHorizontalSpacing?": "/**\n * @deprecated\n */",
      "layoutVerticalSpacing?": "/**\n * @deprecated\n */",
      "itemSpacing?": "/**\n * @deprecated\n */",
      "markerShape?": "/**\n * @deprecated\n */",
      "markerSize?": "/**\n * @deprecated\n */",
      "strokeWidth?": "/**\n * @deprecated\n */",
      "color?": "/**\n * @deprecated\n */",
      "fontStyle?": "/**\n * @deprecated\n */",
      "fontWeight?": "/**\n * @deprecated\n */",
      "fontSize?": "/**\n * @deprecated\n */",
      "fontFamily?": "/**\n * @deprecated\n */"
    }
  },
  "AgBaseChartOptions": {
    "meta": {},
    "type": {
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{\n    visible?: boolean;\n    fill?: string;\n}",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme"
    }
  },
  "AgBaseAxisOptions": { "meta": {}, "type": { "keys?": "string[]" } },
  "AgCartesianAxisPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'top' | 'right' | 'bottom' | 'left'"
  },
  "AgAxisLineOptions": {
    "meta": {},
    "type": { "width?": "number", "color?": "string" }
  },
  "AgAxisTickOptions": {
    "meta": {},
    "type": {
      "width?": "number",
      "size?": "number",
      "color?": "string",
      "count?": "any"
    }
  },
  "AgAxisLabelFormatterParams": {
    "meta": {},
    "type": {
      "value": "any",
      "index": "number",
      "fractionDigits?": "number",
      "formatter?": "(x: any) => string"
    }
  },
  "AgAxisLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "padding?": "number",
      "color?": "string",
      "rotation?": "number",
      "format?": "string",
      "formatter?": "(params: AgAxisLabelFormatterParams) => string"
    }
  },
  "AgAxisGridStyle": {
    "meta": {},
    "type": { "stroke?": "string", "lineDash?": "number[]" }
  },
  "AgBaseCartesianAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]"
    }
  },
  "AgNumberAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'number'",
      "nice?": "boolean",
      "min?": "number",
      "max?": "number"
    }
  },
  "AgCategoryAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'category'",
      "paddingInner?": "number",
      "paddingOuter?": "number"
    }
  },
  "AgGroupedCategoryAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'groupedCategory'"
    }
  },
  "AgTimeAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'time'",
      "nice?": "boolean"
    }
  },
  "AgCartesianAxisOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgNumberAxisOptions | AgCategoryAxisOptions | AgGroupedCategoryAxisOptions | AgTimeAxisOptions"
  },
  "AgPolarAxisOptions": { "meta": {}, "type": {} },
  "AgBaseSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "AgTooltipRendererResult": {
    "meta": {},
    "type": { "title?": "string", "content?": "string" }
  },
  "AgSeriesTooltipRendererParams": {
    "meta": {},
    "type": { "datum": "any", "title?": "string", "color?": "string" }
  },
  "AgCartesianSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "xKey": "string",
      "xValue?": "any",
      "xName?": "string",
      "yKey": "string",
      "yValue?": "any",
      "yName?": "string"
    }
  },
  "AgPolarSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "angleKey": "string",
      "angleValue?": "any",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusValue?": "any",
      "radiusName?": "string"
    }
  },
  "AgScatterSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "xKey": "string",
      "xValue?": "any",
      "xName?": "string",
      "yKey": "string",
      "yValue?": "any",
      "yName?": "string",
      "sizeKey?": "string",
      "sizeName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "AgSeriesMarker": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "maxSize?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    }
  },
  "AgCartesianSeriesMarkerFormatterParams": {
    "meta": {},
    "type": { "xKey": "string", "yKey": "string" }
  },
  "AgCartesianSeriesMarkerFormat": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "size?": "number"
    }
  },
  "AgCartesianSeriesMarker": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "maxSize?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "formatter?": "(params: AgCartesianSeriesMarkerFormatterParams) => AgCartesianSeriesMarkerFormat"
    }
  },
  "AgSeriesTooltip": { "meta": {}, "type": { "enabled?": "boolean" } },
  "AgLineSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgLineSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "AgLineSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'line'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgLineSeriesLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "xName?": "string",
      "yName?": "string",
      "title?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgLineSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgScatterSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgScatterSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgScatterSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgScatterSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'scatter'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgScatterSeriesLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "xName?": "string",
      "yName?": "string",
      "title?": "string",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgScatterSeriesTooltip",
      "tooltipRenderer?": "(params: AgScatterSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgAreaSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "format?": "string"
    }
  },
  "AgAreaSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "AgAreaSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'area'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgAreaSeriesLabelOptions",
      "xKey?": "string",
      "yKeys?": "string[]",
      "xName?": "string",
      "yNames?": "string[]",
      "fills?": "string[]",
      "strokes?": "string[]",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgAreaSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgBarSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: number;\n}) => string"
    }
  },
  "AgBarSeriesFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean",
      "xKey": "string",
      "yKey": "string"
    }
  },
  "AgBarSeriesFormat": {
    "meta": {},
    "type": { "fill?": "string", "stroke?": "string", "strokeWidth?": "number" }
  },
  "AgBarSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgBarSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'bar' | 'column'",
      "grouped?": "boolean",
      "normalizedTo?": "number",
      "xKey?": "string",
      "yKeys?": "string[] | string[][]",
      "xName?": "string",
      "yNames?": "string[] | {\n    [key in string]: string;\n}",
      "fills?": "string[]",
      "strokes?": "string[]",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "label?": "AgBarSeriesLabelOptions",
      "tooltip?": "AgBarSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "formatter?": "(params: AgBarSeriesFormatterParams) => AgBarSeriesFormat"
    }
  },
  "AgHistogramSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: number;\n}) => string"
    }
  },
  "AgHistogramSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgHistogramSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'histogram'",
      "fill?": "string",
      "stroke?": "string",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "strokeWidth?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "xKey?": "string",
      "xName?": "string",
      "yKey?": "string",
      "yName?": "string",
      "areaPlot?": "boolean",
      "bins?": "[number, number][]",
      "binCount?": "number",
      "aggregation?": "'count' | 'sum' | 'mean'",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "label?": "AgHistogramSeriesLabelOptions",
      "tooltip?": "AgHistogramSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgPieSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "offset?": "number",
      "minAngle?": "number"
    }
  },
  "AgPieSeriesFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean",
      "angleKey": "string",
      "radiusKey?": "string"
    }
  },
  "AgPieSeriesFormat": {
    "meta": {},
    "type": { "fill?": "string", "stroke?": "string", "strokeWidth?": "number" }
  },
  "AgPieSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgPieSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgPieSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'pie'",
      "title?": "AgChartCaptionOptions",
      "label?": "AgPieSeriesLabelOptions",
      "callout?": "{\n    colors?: string[];\n    length?: number;\n    strokeWidth?: number;\n}",
      "angleKey?": "string",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusName?": "string",
      "labelKey?": "string",
      "labelName?": "string",
      "fills?": "string[]",
      "strokes?": "string[]",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "strokeWidth?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "rotation?": "number",
      "outerRadiusOffset?": "number",
      "innerRadiusOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgPieSeriesTooltip",
      "tooltipRenderer?": "(params: AgPieSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "formatter?": "(params: AgPieSeriesFormatterParams) => AgPieSeriesFormat"
    }
  },
  "AgPieSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "angleKey": "string",
      "angleValue?": "any",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusValue?": "any",
      "radiusName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "AgCartesianSeriesOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgLineSeriesOptions | AgScatterSeriesOptions | AgAreaSeriesOptions | AgBarSeriesOptions | AgHistogramSeriesOptions"
  },
  "AgPolarSeriesOptions": { "meta": {}, "type": {} },
  "AgCartesianChartOptions": {
    "meta": { "typeParams": ["TAxisOptions", "TSeriesOptions"] },
    "type": {
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{\n    visible?: boolean;\n    fill?: string;\n}",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme",
      "type?": "'cartesian' | 'groupedCategory' | 'line' | 'bar' | 'column' | 'area' | 'scatter'",
      "axes?": "TAxisOptions",
      "series?": "TSeriesOptions"
    }
  },
  "AgPolarChartOptions": {
    "meta": { "typeParams": ["TAxisOptions", "TSeriesOptions"] },
    "type": {
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{\n    visible?: boolean;\n    fill?: string;\n}",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme",
      "type?": "'polar' | 'pie'",
      "axes?": "TAxisOptions",
      "series?": "TSeriesOptions"
    }
  },
  "AgChartOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgCartesianChartOptions | AgPolarChartOptions"
  },
  "IAggFuncService": {
    "meta": {},
    "type": {
      "addAggFuncs(aggFuncs: {\n    [key: string]: IAggFunc;\n})": "void",
      "addAggFunc(key: string, aggFunc: IAggFunc)": "void",
      "clear()": "void",
      "getDefaultAggFunc(column: Column)": "string | null",
      "getFuncNames(column: Column)": "string[]"
    }
  },
  "IAggregationStage": {
    "meta": {},
    "type": {
      "aggregateValues(values: any[], aggFuncOrString: string | IAggFunc)": "any"
    }
  },
  "ICellEditor": {
    "meta": {},
    "type": {
      "getValue()": "any",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "string | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getFrameworkComponentInstance?()": "any"
    },
    "docs": {
      "getValue()": "/**\n * Return the final value - called by the grid once after editing is complete */",
      "isPopup?()": "/**\n * Gets called once after initialised. If you return true, the editor will\n * appear in a popup, so is not constrained to the boundaries of the cell.\n * This is great if you want to, for example, provide you own custom dropdown list\n * for selection. Default is false (ie if you don't provide the method). */",
      "getPopupPosition?()": "/**\n * Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n * should cover the cell, or \"under\" if it should be positioned below leaving the\n * cell value visible. If this method is not present, the default is \"over\". */",
      "isCancelBeforeStart?()": "/**\n * Gets called once after initialised. If you return true, the editor will not be\n * used and the grid will continue editing. Use this to make a decision on editing\n * inside the init() function, eg maybe you want to only start editing if the user\n * hits a numeric key, but not a letter, if the editor is for numbers. */",
      "isCancelAfterEnd?()": "/**\n * Gets called once after editing is complete. If your return true, then the new\n * value will not be used. The editing will have no impact on the record. Use this\n * if you do not want a new value from your gui, i.e. you want to cancel the editing. */",
      "focusIn?()": "/**\n * If doing full line edit, then gets called when focus should be put into the editor */",
      "focusOut?()": "/**\n * If doing full line edit, then gets called when focus is leaving the editor */",
      "getFrameworkComponentInstance?()": "/**\n * If using a framework this returns the underlying component instance, so you can call\n * methods on it if you want. */"
    }
  },
  "ICellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any"
    }
  },
  "ICellEditorComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "isPopup?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getValue()": "any",
      "getPopupPosition?()": "string | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "getFrameworkComponentInstance?()": "any"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: T)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */",
      "isPopup?()": "/**\n * Gets called once after initialised. If you return true, the editor will\n * appear in a popup, so is not constrained to the boundaries of the cell.\n * This is great if you want to, for example, provide you own custom dropdown list\n * for selection. Default is false (ie if you don't provide the method). */",
      "focusIn?()": "/**\n * If doing full line edit, then gets called when focus should be put into the editor */",
      "focusOut?()": "/**\n * If doing full line edit, then gets called when focus is leaving the editor */",
      "getValue()": "/**\n * Return the final value - called by the grid once after editing is complete */",
      "getPopupPosition?()": "/**\n * Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n * should cover the cell, or \"under\" if it should be positioned below leaving the\n * cell value visible. If this method is not present, the default is \"over\". */",
      "isCancelBeforeStart?()": "/**\n * Gets called once after initialised. If you return true, the editor will not be\n * used and the grid will continue editing. Use this to make a decision on editing\n * inside the init() function, eg maybe you want to only start editing if the user\n * hits a numeric key, but not a letter, if the editor is for numbers. */",
      "isCancelAfterEnd?()": "/**\n * Gets called once after editing is complete. If your return true, then the new\n * value will not be used. The editing will have no impact on the record. Use this\n * if you do not want a new value from your gui, i.e. you want to cancel the editing. */",
      "getFrameworkComponentInstance?()": "/**\n * If using a framework this returns the underlying component instance, so you can call\n * methods on it if you want. */"
    }
  },
  "ChartType": {
    "meta": { "isEnum": true },
    "type": [
      "Column = 'column'",
      "GroupedColumn = 'groupedColumn'",
      "StackedColumn = 'stackedColumn'",
      "NormalizedColumn = 'normalizedColumn'",
      "Bar = 'bar'",
      "GroupedBar = 'groupedBar'",
      "StackedBar = 'stackedBar'",
      "NormalizedBar = 'normalizedBar'",
      "Line = 'line'",
      "Scatter = 'scatter'",
      "Bubble = 'bubble'",
      "Pie = 'pie'",
      "Doughnut = 'doughnut'",
      "Area = 'area'",
      "StackedArea = 'stackedArea'",
      "NormalizedArea = 'normalizedArea'",
      "Histogram = 'histogram'"
    ]
  },
  "ChartMenuOptions": {
    "meta": { "isTypeAlias": true },
    "type": "'chartSettings' | 'chartData' | 'chartFormat' | 'chartLink' | 'chartUnlink' | 'chartDownload'"
  },
  "SeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "ChartTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "class?": "string",
      "tracking?": "boolean",
      "delay?": "number"
    }
  },
  "ChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "PaddingOptions": {
    "meta": {},
    "type": {
      "top": "number",
      "right": "number",
      "bottom": "number",
      "left": "number"
    }
  },
  "BackgroundOptions": {
    "meta": {},
    "type": { "fill": "string", "visible": "boolean" }
  },
  "FontOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "CaptionOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "text?": "string"
    }
  },
  "LegendOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "position": "LegendPosition",
      "spacing": "number",
      "item": "LegendItemOptions"
    }
  },
  "LegendPosition": {
    "meta": { "isEnum": true },
    "type": [
      "Top = 'top'",
      "Right = 'right'",
      "Bottom = 'bottom'",
      "Left = 'left'"
    ]
  },
  "LegendItemOptions": {
    "meta": {},
    "type": {
      "label": "LegendLabelOptions",
      "marker": "LegendMarkerOptions",
      "paddingX": "number",
      "paddingY": "number"
    }
  },
  "LegendLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "NavigatorOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "height": "number",
      "min": "number",
      "max": "number",
      "mask": "NavigatorMaskOptions",
      "minHandle": "NavigatorHandleOptions",
      "maxHandle": "NavigatorHandleOptions"
    }
  },
  "NavigatorMaskOptions": {
    "meta": {},
    "type": {
      "fill": "string",
      "stroke": "string",
      "strokeWidth": "number",
      "fillOpacity": "number"
    }
  },
  "NavigatorHandleOptions": {
    "meta": {},
    "type": {
      "fill": "string",
      "stroke": "string",
      "strokeWidth": "number",
      "width": "number",
      "height": "number",
      "gripLineGap": "number",
      "gripLineLength": "number"
    }
  },
  "MarkerShape": {
    "meta": { "isTypeAlias": true },
    "type": "'circle' | 'cross' | 'diamond' | 'plus' | 'square' | 'triangle'"
  },
  "LegendMarkerOptions": {
    "meta": {},
    "type": {
      "shape": "MarkerShape",
      "size": "number",
      "padding": "number",
      "strokeWidth": "number"
    }
  },
  "CartesianChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}",
      "xAxis": "AxisOptions",
      "yAxis": "AxisOptions"
    }
  },
  "PolarChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "AxisOptions": {
    "meta": {},
    "type": {
      "type?": "AxisType",
      "title": "CaptionOptions",
      "line": "AxisLineOptions",
      "tick": "AxisTickOptions",
      "label": "AxisLabelOptions",
      "gridStyle": "GridStyle[]"
    }
  },
  "AxisType": {
    "meta": { "isTypeAlias": true },
    "type": "'category' | 'number' | 'time'"
  },
  "AxisLineOptions": {
    "meta": {},
    "type": { "width": "number", "color": "string" }
  },
  "AxisTickOptions": {
    "meta": {},
    "type": { "width": "number", "size": "number", "color": "string" }
  },
  "AxisLabelFormatterParams": {
    "meta": {},
    "type": {
      "value": "any",
      "index": "number",
      "fractionDigits?": "number",
      "formatter?": "(x: any) => string"
    }
  },
  "AxisLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "padding": "number",
      "rotation": "number",
      "format?": "string",
      "formatter?": "(params: AxisLabelFormatterParams) => string"
    }
  },
  "GridStyle": {
    "meta": {},
    "type": { "stroke": "string", "lineDash?": "number[]" }
  },
  "HighlightOptions": {
    "meta": {},
    "type": { "fill": "string", "stroke?": "string", "dimOpacity?": "number" }
  },
  "FillOptions": {
    "meta": {},
    "type": { "colors": "string[]", "opacity": "number" }
  },
  "StrokeOptions": {
    "meta": {},
    "type": { "colors": "string[]", "opacity": "number", "width": "number" }
  },
  "DropShadowOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "color": "string",
      "xOffset": "number",
      "yOffset": "number",
      "blur": "number"
    }
  },
  "SeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean"
    }
  },
  "TooltipRendererResult": {
    "meta": {},
    "type": { "content": "string", "title?": "string" }
  },
  "TooltipOptions": {
    "meta": { "typeParams": ["TParams"] },
    "type": {
      "enabled": "boolean",
      "renderer?": "(params: TParams) => string | TooltipRendererResult"
    }
  },
  "TooltipRendererParams": {
    "meta": {},
    "type": { "datum": "any", "title?": "string", "color": "string" }
  },
  "CartesianTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "BarSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "shadow": "DropShadowOptions",
      "label": "BarSeriesLabelOptions",
      "tooltip": "TooltipOptions<BarTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "HistogramSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "shadow": "DropShadowOptions",
      "label": "BarSeriesLabelOptions",
      "tooltip": "TooltipOptions<BarTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number",
      "binCount?": "number"
    }
  },
  "BarSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "formatter?": "(params: {\n    value: number;\n}) => string"
    }
  },
  "BarTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "LineSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "marker": "MarkerOptions",
      "label": "LineSeriesLabelOptions",
      "tooltip": "TooltipOptions<LineTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "LineSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "MarkerOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "shape": "MarkerShape",
      "size": "number",
      "strokeWidth": "number",
      "formatter?": "Function"
    }
  },
  "LineTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "ScatterSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean"
    }
  },
  "ScatterSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "marker": "ScatterMarkerOptions",
      "label": "ScatterSeriesLabelOptions",
      "tooltip": "TooltipOptions<ScatterTooltipRendererParams>",
      "paired": "boolean"
    }
  },
  "ScatterMarkerOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "shape": "MarkerShape",
      "size": "number",
      "strokeWidth": "number",
      "formatter?": "Function",
      "maxSize?": "number"
    }
  },
  "ScatterTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string",
      "sizeKey?": "string",
      "sizeName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "AreaSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "AreaSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "marker": "MarkerOptions",
      "label": "AreaSeriesLabelOptions",
      "shadow": "DropShadowOptions",
      "tooltip": "TooltipOptions<AreaTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "AreaTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "PieSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "title": "CaptionOptions",
      "label": "PieSeriesLabelOptions",
      "callout": "PieSeriesCalloutOptions",
      "shadow": "DropShadowOptions",
      "tooltip": "TooltipOptions<PieTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "PieSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "minAngle": "number",
      "offset": "number"
    }
  },
  "PieSeriesCalloutOptions": {
    "meta": {},
    "type": {
      "length": "number",
      "strokeWidth": "number",
      "colors": "string[]"
    }
  },
  "PieTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "angleKey": "string",
      "angleValue": "any",
      "angleName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "GetChartImageDataUrlParams": {
    "meta": {},
    "type": { "chartId": "string", "fileFormat?": "string" }
  },
  "ChartModelType": {
    "meta": { "isTypeAlias": true },
    "type": "'range' | 'pivot'"
  },
  "ChartModel": {
    "meta": {},
    "type": {
      "modelType": "ChartModelType",
      "chartId": "string",
      "chartType": "ChartType",
      "cellRange": "CellRangeParams",
      "chartThemeName?": "string",
      "chartOptions": "ChartOptions<any>",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "unlinkChart?": "boolean"
    }
  },
  "IChartService": {
    "meta": {},
    "type": {
      "getChartModels()": "ChartModel[]",
      "getChartRef(chartId: string)": "ChartRef | undefined",
      "createRangeChart(params: CreateRangeChartParams)": "ChartRef | undefined",
      "createCrossFilterChart(params: CreateCrossFilterChartParams)": "ChartRef | undefined",
      "createChartFromCurrentRange(chartType: ChartType)": "ChartRef | undefined",
      "createPivotChart(params: CreatePivotChartParams)": "ChartRef | undefined",
      "restoreChart(model: ChartModel, chartContainer?: HTMLElement)": "ChartRef | undefined",
      "getChartImageDataURL(params: GetChartImageDataUrlParams)": "string | undefined"
    }
  },
  "ClientSideRowModelSteps": {
    "meta": { "isEnum": true },
    "type": [
      "EVERYTHING = 'group'",
      "FILTER = 'filter'",
      "SORT = 'sort'",
      "MAP = 'map'",
      "AGGREGATE = 'aggregate'",
      "PIVOT = 'pivot'",
      "NOTHING = 'nothing'"
    ]
  },
  "IClientSideRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void",
      "updateRowData(rowDataTran: RowDataTransaction, rowNodeOrder?: {\n    [id: string]: number;\n} | null)": "RowNodeTransaction | null",
      "setRowData(rowData: any[])": "void",
      "refreshModel(params: RefreshModelParams)": "void",
      "expandOrCollapseAll(expand: boolean)": "void",
      "forEachLeafNode(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNode(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNodeAfterFilter(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void)": "void",
      "resetRowHeights()": "void",
      "onRowHeightChanged()": "void",
      "batchUpdateRowData(rowDataTransaction: RowDataTransaction, callback?: (res: RowNodeTransaction) => void)": "void",
      "flushAsyncTransactions()": "void",
      "getRootNode()": "RowNode",
      "doAggregate(changedPath?: ChangedPath)": "void",
      "getTopLevelNodes()": "RowNode[] | null",
      "forEachPivotNode(callback: (node: RowNode, index: number) => void)": "void",
      "ensureRowsAtPixel(rowNode: RowNode[], pixel: number, increment: number)": "boolean",
      "highlightRowAtPixel(rowNode: RowNode | null, pixel?: number)": "void",
      "getHighlightPosition(pixel: number, rowNode?: RowNode)": "RowHighlightPosition",
      "getLastHighlightedRowNode()": "RowNode | null"
    },
    "docs": {
      "getRow(index: number)": "/**\n * Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/**\n * Returns the rowNode for given id. */",
      "getRowCount()": "/**\n * This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/**\n * Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/**\n * Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/**\n * Returns row top and bottom for a given row */",
      "isEmpty()": "/**\n * Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/**\n * Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/**\n * Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/**\n * Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/**\n * The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/**\n * It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/**\n * Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/**\n * Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "RefreshModelParams": {
    "meta": {},
    "type": {
      "step": "ClientSideRowModelSteps",
      "groupState?": "any",
      "keepRenderedRows?": "boolean",
      "animate?": "boolean",
      "keepEditingRows?": "boolean",
      "rowNodeTransactions?": "RowNodeTransaction[]",
      "rowNodeOrder?": "{\n    [id: string]: number;\n}",
      "newData?": "boolean",
      "afterColumnsChanged?": "boolean"
    }
  },
  "IClipboardService": {
    "meta": {},
    "type": {
      "pasteFromClipboard()": "void",
      "copyToClipboard(includeHeader?: boolean)": "void",
      "copySelectedRowsToClipboard(includeHeader?: boolean, columnKeys?: (string | Column)[])": "void",
      "copySelectedRangeToClipboard(includeHeader?: boolean)": "void",
      "copyRangeDown()": "void"
    }
  },
  "IColumnToolPanel": {
    "meta": {},
    "type": {
      "expandColumnGroups(groupIds?: string[])": "void",
      "collapseColumnGroups(groupIds?: string[])": "void",
      "setColumnLayout(colDefs: (ColDef | ColGroupDef)[])": "void",
      "syncLayoutWithGrid()": "void",
      "setPivotModeSectionVisible(visible: boolean)": "void",
      "setRowGroupsSectionVisible(visible: boolean)": "void",
      "setValuesSectionVisible(visible: boolean)": "void",
      "setPivotSectionVisible(visible: boolean)": "void"
    }
  },
  "ColumnVO": {
    "meta": {},
    "type": {
      "id": "string",
      "displayName": "string",
      "field?": "string",
      "aggFunc?": "string"
    }
  },
  "IComponent": {
    "meta": {
      "typeParams": ["T"],
      "doc": "/**\n * This is for User Components only, do not implement this for internal components. */"
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: T)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "IContextMenuFactory": {
    "meta": {},
    "type": {
      "onContextMenu(mouseEvent: MouseEvent | null, touchEvent: TouchEvent | null, rowNode: RowNode | null, column: Column | null, value: any, anchorToElement: HTMLElement)": "void",
      "hideActiveMenu()": "void"
    }
  },
  "ICsvCreator": {
    "meta": {},
    "type": {
      "getDataAsCsv(params?: CsvExportParams)": "string",
      "exportDataAsCsv(params?: CsvExportParams)": "string"
    }
  },
  "IDatasource": {
    "meta": {
      "doc": "/**\n * Datasource used by both PaginationController and InfiniteRowModel */"
    },
    "type": {
      "rowCount?": "number",
      "getRows(params: IGetRowsParams)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "rowCount?": "/**\n * If you know up front how many rows are in the dataset, set it here. Otherwise leave blank. */",
      "getRows(params: IGetRowsParams)": "/**\n * Callback the grid calls that you implement to fetch rows from the server. See below for params. */"
    }
  },
  "IGetRowsParams": {
    "meta": { "doc": "/**\n * Params for the above IDatasource.getRows() */" },
    "type": {
      "startRow": "number",
      "endRow": "number",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "void",
      "failCallback()": "void",
      "sortModel": "any",
      "filterModel": "any",
      "context": "any"
    },
    "docs": {
      "startRow": "/**\n * The first row index to get. */",
      "endRow": "/**\n * The first row index to NOT get. */",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "/**\n * Callback to call for the result when successful. */",
      "failCallback()": "/**\n * Callback to call when the request fails. */",
      "sortModel": "/**\n * If doing server side sorting, contains the sort model */",
      "filterModel": "/**\n * If doing server side filtering, contains the filter model */",
      "context": "/**\n * The grid context object */"
    }
  },
  "IEventEmitter": {
    "meta": {},
    "type": {
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void"
    }
  },
  "ExcelStyle": {
    "meta": {},
    "type": {
      "id": "string",
      "alignment?": "ExcelAlignment",
      "borders?": "ExcelBorders",
      "dataType?": "ExcelDataType",
      "font?": "ExcelFont",
      "interior?": "ExcelInterior",
      "numberFormat?": "ExcelNumberFormat",
      "protection?": "ExcelProtection",
      "name?": "string"
    },
    "docs": { "name?": "/**\n * @deprecated Legacy property\n */" }
  },
  "ExcelAlignment": {
    "meta": {},
    "type": {
      "horizontal?": "'Automatic' | 'Left' | 'Center' | 'Right' | 'Fill' | 'Justify' | 'CenterAcrossSelection' | 'Distributed' | 'JustifyDistributed'",
      "indent?": "number",
      "readingOrder?": "'RightToLeft' | 'LeftToRight' | 'Context'",
      "rotate?": "number",
      "shrinkToFit?": "boolean",
      "vertical?": "'Automatic' | 'Top' | 'Bottom' | 'Center' | 'Justify' | 'Distributed' | 'JustifyDistributed'",
      "wrapText?": "boolean",
      "verticalText?": "boolean"
    },
    "docs": { "verticalText?": "/**\n * @deprecated Legacy property\n */" }
  },
  "ExcelBorders": {
    "meta": {},
    "type": {
      "borderBottom?": "ExcelBorder",
      "borderLeft?": "ExcelBorder",
      "borderRight?": "ExcelBorder",
      "borderTop?": "ExcelBorder"
    }
  },
  "ExcelBorder": {
    "meta": {},
    "type": {
      "color?": "string",
      "lineStyle?": "'None' | 'Continuous' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot' | 'SlantDashDot' | 'Double'",
      "weight?": "0 | 1 | 2 | 3"
    }
  },
  "ExcelFont": {
    "meta": {},
    "type": {
      "bold?": "boolean",
      "color?": "string",
      "family?": "string",
      "fontName?": "string",
      "italic?": "boolean",
      "outline?": "boolean",
      "shadow?": "boolean",
      "size?": "number",
      "strikeThrough?": "boolean",
      "underline?": "'Single' | 'Double'",
      "verticalAlign?": "'Superscript' | 'Subscript'",
      "charSet?": "number"
    },
    "docs": { "charSet?": "/**\n * @deprecated Legacy property\n */" }
  },
  "ExcelInterior": {
    "meta": {},
    "type": {
      "color": "string",
      "pattern": "'None' | 'Solid' | 'Gray75' | 'Gray50' | 'Gray25' | 'Gray125' | 'Gray0625' | 'HorzStripe' | 'VertStripe' | 'ReverseDiagStripe' | 'DiagStripe' | 'DiagCross' | 'ThickDiagCross' | 'ThinHorzStripe' | 'ThinVertStripe' | 'ThinReverseDiagStripe' | 'ThinDiagStripe' | 'ThinHorzCross' | 'ThinDiagCross'",
      "patternColor": "string"
    }
  },
  "ExcelNumberFormat": { "meta": {}, "type": { "format": "string" } },
  "ExcelProtection": {
    "meta": {},
    "type": { "protected": "boolean", "hideFormula": "boolean" }
  },
  "ExcelWorksheet": {
    "meta": {},
    "type": { "name": "string", "table": "ExcelTable" }
  },
  "ExcelTable": {
    "meta": {},
    "type": { "columns": "ExcelColumn[]", "rows": "ExcelRow[]" }
  },
  "ExcelColumn": {
    "meta": {},
    "type": {
      "min?": "number",
      "max?": "number",
      "width?": "number",
      "s?": "number",
      "hidden?": "boolean",
      "bestFit?": "boolean"
    }
  },
  "ExcelRow": {
    "meta": {},
    "type": {
      "index?": "number",
      "collapsed?": "boolean",
      "hidden?": "boolean",
      "height?": "number",
      "outlineLevel?": "number",
      "s?": "number",
      "cells": "ExcelCell[]"
    }
  },
  "ExcelCell": {
    "meta": {},
    "type": {
      "ref?": "string",
      "styleId?": "string",
      "data": "ExcelData",
      "mergeAcross?": "number"
    }
  },
  "ExcelImage": {
    "meta": {},
    "type": {
      "id": "string",
      "base64": "string",
      "imageType": "'jpg' | 'png' | 'gif'",
      "altText?": "string",
      "fitCell?": "boolean",
      "transparency?": "number",
      "rotation?": "number",
      "recolor?": "'Grayscale' | 'Sepia' | 'Washout'",
      "width?": "number",
      "height?": "number",
      "position?": "{\n    row?: number;\n    rowSpan?: number;\n    column?: number;\n    colSpan?: number;\n    offsetX?: number;\n    offsetY?: number;\n}"
    }
  },
  "ExcelDataType": {
    "meta": { "isTypeAlias": true },
    "type": "'String' | 'Formula' | 'Number' | 'Boolean' | 'DateTime' | 'Error'"
  },
  "ExcelOOXMLDataType": {
    "meta": { "isTypeAlias": true },
    "type": "'str' | 's' | 'f' | 'inlineStr' | 'n' | 'b' | 'd' | 'e' | 'empty'"
  },
  "ExcelData": {
    "meta": {},
    "type": {
      "type": "ExcelDataType | ExcelOOXMLDataType",
      "value": "string | null"
    }
  },
  "ExcelRelationship": {
    "meta": {},
    "type": { "Id": "string", "Type": "string", "Target": "string" }
  },
  "ExcelContentType": {
    "meta": {},
    "type": {
      "name": "'Default' | 'Override'",
      "ContentType": "string",
      "Extension?": "string",
      "PartName?": "string"
    }
  },
  "ExcelXMLTemplate": {
    "meta": {},
    "type": {
      "getTemplate(styleProperties?: ExcelStyle | ExcelWorksheet | ExcelColumn | ExcelRow | ExcelCell)": "XmlElement"
    }
  },
  "ExcelOOXMLTemplate": {
    "meta": {},
    "type": {
      "getTemplate(config?: any, idx?: number, currentSheet?: number)": "XmlElement",
      "convertType?(type: string)": "string"
    }
  },
  "ExcelFactoryMode": {
    "meta": { "isEnum": true },
    "type": ["SINGLE_SHEET", "MULTI_SHEET"]
  },
  "ColumnWidthCallbackParams": {
    "meta": {},
    "type": { "column": "Column | null", "index": "number" }
  },
  "RowHeightCallbackParams": { "meta": {}, "type": { "rowIndex": "number" } },
  "ExcelExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean",
      "prependContent?": "ExcelCell[][]",
      "appendContent?": "ExcelCell[][]",
      "customHeader?": "ExcelCell[][]",
      "customFooter?": "ExcelCell[][]",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => ExcelCell[][] | undefined",
      "author?": "string",
      "autoConvertFormulas?": "boolean",
      "columnWidth?": "number | ((params: ColumnWidthCallbackParams) => number)",
      "exportMode?": "'xlsx' | 'xml'",
      "fontSize?": "number",
      "headerRowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "rowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "sheetName?": "string",
      "margins?": "ExcelSheetMargin",
      "pageSetup?": "ExcelSheetPageSetup",
      "headerFooterConfig?": "ExcelHeaderFooterConfig",
      "suppressTextAsCDATA?": "boolean",
      "addImageToCell?": "(rowIndex: number, column: Column, value: string) => {\n    image: ExcelImage;\n    value?: string;\n} | undefined"
    },
    "docs": {
      "columnGroups?": "/**\n * @deprecated\n */",
      "skipGroups?": "/**\n * @deprecated\n */",
      "skipHeader?": "/**\n * @deprecated\n */",
      "customHeader?": "/**\n * @deprecated Use prependContent\n */",
      "customFooter?": "/**\n * @deprecated Use appendContent\n */"
    }
  },
  "ExcelExportMultipleSheetParams": {
    "meta": {},
    "type": {
      "author?": "string",
      "data": "string[]",
      "fileName?": "string",
      "fontSize?": "number"
    }
  },
  "ExcelHeaderFooterConfig": {
    "meta": {},
    "type": {
      "all?": "ExcelHeaderFooter",
      "first?": "ExcelHeaderFooter",
      "even?": "ExcelHeaderFooter"
    }
  },
  "ExcelHeaderFooter": {
    "meta": {},
    "type": {
      "header?": "ExcelHeaderFooterContent[]",
      "footer?": "ExcelHeaderFooterContent[]"
    }
  },
  "ExcelHeaderFooterContent": {
    "meta": {},
    "type": {
      "value": "string",
      "position?": "'Left' | 'Center' | 'Right'",
      "font?": "ExcelFont"
    }
  },
  "IExcelCreator": {
    "meta": {},
    "type": {
      "exportDataAsExcel(params?: ExcelExportParams)": "void",
      "getDataAsExcel(params?: ExcelExportParams)": "Blob | string | undefined",
      "getSheetDataForExcel(params?: ExcelExportParams)": "string",
      "getMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "Blob | undefined",
      "exportMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "void",
      "setFactoryMode(factoryMode: ExcelFactoryMode, exportMode: 'xml' | 'xlsx')": "void",
      "getFactoryMode(exportMode: 'xml' | 'xlsx')": "ExcelFactoryMode"
    },
    "docs": {
      "setFactoryMode(factoryMode: ExcelFactoryMode, exportMode: 'xml' | 'xlsx')": "/**\n * private methods */"
    }
  },
  "ExcelSheetMargin": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number",
      "header?": "number",
      "footer?": "number"
    }
  },
  "ExcelSheetPageSetup": {
    "meta": {},
    "type": {
      "orientation?": "'Portrait' | 'Landscape'",
      "pageSize?": "'Letter' | 'Letter Small' | 'Tabloid' | 'Ledger' | 'Legal' | 'Statement' | 'Executive' | 'A3' | 'A4' | 'A4 Small' | 'A5' | 'A6' | 'B4' | 'B5' | 'Folio' | 'Envelope' | 'Envelope DL' | 'Envelope C5' | 'Envelope B5' | 'Envelope C3' | 'Envelope C4' | 'Envelope C6' | 'Envelope Monarch' | 'Japanese Postcard' | 'Japanese Double Postcard'"
    }
  },
  "IFilterType": {
    "meta": { "isTypeAlias": true },
    "type": "string | {\n    new (): IFilterComp;\n} | boolean"
  },
  "IFilterDef": {
    "meta": {},
    "type": {
      "filter?": "IFilterType",
      "filterFramework?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "string | {\n    new (): IFloatingFilterComp;\n}",
      "floatingFilterComponentParams?": "any",
      "floatingFilterComponentFramework?": "any"
    },
    "docs": {
      "filter?": "/**\n * One of the built in filter names: [set, number, text], or a filter function */",
      "filterParams?": "/**\n * The filter params are specific to each filter! */",
      "floatingFilterComponent?": "/**\n * The custom component to be used for rendering the floating filter. If none is specified the default AG Grid is used. * */"
    }
  },
  "IFilter": {
    "meta": {},
    "type": {
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "isFilterActive()": "/**\n * This is used to let the grid know if the filter is active or not */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/**\n * The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n * filter fails, then the row will be excluded from the final set. The method is provided a\n * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n * (the data object that you provided to the grid for that row). */",
      "getModel()": "/**\n * Gets the filter state for storing */",
      "setModel(model: any)": "/**\n * Restores the filter state. */",
      "onNewRowsLoaded?()": "/**\n * Gets called when new rows are inserted into the grid. If the filter needs to change it's state\n * after rows are loaded, it can do it here. */",
      "onAnyFilterChanged?()": "/**\n * Called whenever any filter is changed. */",
      "getFrameworkComponentInstance?()": "/**\n * If using React or Angular 2, returns the underlying component instance, so you can call methods\n * on it if you want. */",
      "getModelAsString?(model: any)": "/**\n * Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\n * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n * filter. */"
    }
  },
  "ProvidedFilterModel": { "meta": {}, "type": { "filterType?": "string" } },
  "IFilterComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IFilterParams)": "AgPromise<void> | void",
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IFilterParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */",
      "isFilterActive()": "/**\n * This is used to let the grid know if the filter is active or not */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/**\n * The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n * filter fails, then the row will be excluded from the final set. The method is provided a\n * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n * (the data object that you provided to the grid for that row). */",
      "getModel()": "/**\n * Gets the filter state for storing */",
      "setModel(model: any)": "/**\n * Restores the filter state. */",
      "onNewRowsLoaded?()": "/**\n * Gets called when new rows are inserted into the grid. If the filter needs to change it's state\n * after rows are loaded, it can do it here. */",
      "onAnyFilterChanged?()": "/**\n * Called whenever any filter is changed. */",
      "getFrameworkComponentInstance?()": "/**\n * If using React or Angular 2, returns the underlying component instance, so you can call methods\n * on it if you want. */",
      "getModelAsString?(model: any)": "/**\n * Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\n * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n * filter. */"
    }
  },
  "IDoesFilterPassParams": {
    "meta": {},
    "type": { "node": "RowNode", "data": "any" }
  },
  "IFilterOptionDef": {
    "meta": {},
    "type": {
      "displayKey": "string",
      "displayName": "string",
      "test": "(filterValue: any, cellValue: any) => boolean",
      "hideFilterInput?": "boolean"
    }
  },
  "IFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any"
    }
  },
  "Filter": {
    "meta": { "doc": "/**\n * @deprecated , use iFilter\n */" },
    "type": {
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "isFilterActive()": "/**\n * This is used to let the grid know if the filter is active or not */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/**\n * The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n * filter fails, then the row will be excluded from the final set. The method is provided a\n * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n * (the data object that you provided to the grid for that row). */",
      "getModel()": "/**\n * Gets the filter state for storing */",
      "setModel(model: any)": "/**\n * Restores the filter state. */",
      "onNewRowsLoaded?()": "/**\n * Gets called when new rows are inserted into the grid. If the filter needs to change it's state\n * after rows are loaded, it can do it here. */",
      "onAnyFilterChanged?()": "/**\n * Called whenever any filter is changed. */",
      "getFrameworkComponentInstance?()": "/**\n * If using React or Angular 2, returns the underlying component instance, so you can call methods\n * on it if you want. */",
      "getModelAsString?(model: any)": "/**\n * Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\n * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n * filter. */"
    }
  },
  "IFiltersToolPanel": {
    "meta": {},
    "type": {
      "setFilterLayout(colDefs: ColDef[])": "void",
      "expandFilterGroups(groupIds?: string[])": "void",
      "collapseFilterGroups(groupIds?: string[])": "void",
      "expandFilters(colIds?: string[])": "void",
      "collapseFilters(colIds?: string[])": "void",
      "syncLayoutWithGrid()": "void"
    }
  },
  "IFrameworkOverrides": {
    "meta": {},
    "type": {
      "setTimeout(action: any, timeout?: any)": "void",
      "setInterval(action: any, interval?: any)": "AgPromise<number>",
      "addEventListener(element: HTMLElement, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions)": "void",
      "dispatchEvent(eventType: string, listener: () => {}, global: boolean)": "void",
      "frameworkComponent(name: string)": "any"
    },
    "docs": {
      "setTimeout(action: any, timeout?: any)": "/**\n * Because Angular 2+ uses Zones, you should not use setTimeout or setInterval (as it'll keep angular constantly doing dirty checks etc\n * So to get around this, we allow the framework to specify how to execute setTimeout. The default is to just call the browser setTimeout(). */",
      "addEventListener(element: HTMLElement, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions)": "/**\n * Again because Angular uses Zones, we allow adding some events outside of Zone JS so that we do not kick off\n * the Angular change detection. We do this for some events ONLY, and not all events, just events that get fired\n * a lot (eg mouse move), but we need to make sure in AG Grid that we do NOT call any grid callbacks while processing\n * these events, as we will be outside of ZoneJS and hence Angular2 Change Detection won't work. However it's fine\n * for our code to result in AG Grid events (and Angular application action on these) as these go through\n * Event Emitter's.\n * \n * This was done by Niall and Sean. The problematic events are mouseover, mouseout, mouseenter and mouseleave. */"
    }
  },
  "IImmutableService": {
    "meta": {},
    "type": {
      "createTransactionForRowData(data: any[])": "([RowDataTransaction, {\n    [id: string]: number;\n} | null]) | undefined"
    }
  },
  "IInfiniteRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void",
      "setDatasource(datasource: IDatasource | undefined)": "void",
      "refreshCache()": "void",
      "purgeCache()": "void",
      "setRowCount(rowCount: number, maxRowFound?: boolean)": "void"
    },
    "docs": {
      "getRow(index: number)": "/**\n * Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/**\n * Returns the rowNode for given id. */",
      "getRowCount()": "/**\n * This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/**\n * Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/**\n * Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/**\n * Returns row top and bottom for a given row */",
      "isEmpty()": "/**\n * Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/**\n * Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/**\n * Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/**\n * Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/**\n * The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/**\n * It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/**\n * Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/**\n * Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IMenu": { "meta": {}, "type": {} },
  "IMenuFactory": {
    "meta": {},
    "type": {
      "showMenuAfterButtonClick(column: Column | null, eventSource: HTMLElement, containerType: ContainerType, defaultTab?: string, restrictToTabs?: string[])": "void",
      "showMenuAfterMouseEvent(column: Column, mouseEvent: MouseEvent | Touch, defaultTab?: string, restrictToTabs?: string[])": "void",
      "isMenuEnabled(column: Column)": "boolean",
      "hideActiveMenu()": "void"
    }
  },
  "Module": {
    "meta": {},
    "type": {
      "moduleName": "string",
      "beans?": "any[]",
      "agStackComponents?": "ComponentMeta[]",
      "userComponents?": "{\n    componentName: string;\n    componentClass: any;\n}[]",
      "rowModels?": "{\n    [name: string]: {\n        new (): IRowModel;\n    };\n}",
      "dependantModules?": "Module[]"
    }
  },
  "IPopupComponent": {
    "meta": { "typeParams": ["T"] },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "isPopup?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: T)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */",
      "isPopup?()": "/**\n * Gets called once after initialised. If you return true, the component will appear in a popup, and it will be\n * constrained to the boundaries of the popupParent. This is great if you want to, for example, provide you own\n * custom dropdown list for selection. Default is false (ie if you don't provide the method). */",
      "focusIn?()": "/**\n * Called when focus is within the component */",
      "focusOut?()": "/**\n * Called when focus is leaving the component */"
    }
  },
  "IRangeService": {
    "meta": {},
    "type": {
      "isEmpty()": "boolean",
      "removeAllCellRanges()": "void",
      "getCellRangeCount(cell: CellPosition)": "number",
      "isCellInAnyRange(cell: CellPosition)": "boolean",
      "isCellInSpecificRange(cell: CellPosition, range: CellRange)": "boolean",
      "isBottomRightCell(cellRange: CellRange, cell: CellPosition)": "boolean",
      "isContiguousRange(cellRange: CellRange)": "boolean",
      "isMoreThanOneCell()": "boolean",
      "onDragStart(mouseEvent: MouseEvent)": "void",
      "onDragStop()": "void",
      "onDragging(mouseEvent: MouseEvent)": "void",
      "getCellRanges()": "CellRange[]",
      "setRangeToCell(cell: CellPosition, appendRange?: boolean)": "void",
      "setCellRange(params: CellRangeParams)": "void",
      "addCellRange(params: CellRangeParams)": "void",
      "extendLatestRangeInDirection(key: number)": "CellPosition | undefined",
      "extendLatestRangeToCell(cell: CellPosition)": "void",
      "updateRangeEnd(cellRange: CellRange, cellPosition: CellPosition, silent?: boolean)": "void",
      "getRangeStartRow(cellRange: CellRange)": "RowPosition",
      "getRangeEndRow(cellRange: CellRange)": "RowPosition",
      "createCellRangeFromCellRangeParams(params: CellRangeParams)": "CellRange | undefined",
      "setCellRanges(cellRanges: CellRange[])": "void"
    }
  },
  "ISelectionHandle": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "getType()": "SelectionHandleType",
      "refresh(cellCtrl: CellCtrl)": "void"
    }
  },
  "ISelectionHandleFactory": {
    "meta": {},
    "type": {
      "createSelectionHandle(type: SelectionHandleType)": "ISelectionHandle"
    }
  },
  "SelectionHandleType": {
    "meta": { "isEnum": true },
    "type": ["FILL", "RANGE"]
  },
  "CellRangeType": {
    "meta": { "isEnum": true },
    "type": ["VALUE", "DIMENSION"]
  },
  "CellRange": {
    "meta": {},
    "type": {
      "id?": "string",
      "type?": "CellRangeType",
      "startRow?": "RowPosition",
      "endRow?": "RowPosition",
      "columns": "Column[]",
      "startColumn": "Column"
    }
  },
  "CellRangeParams": {
    "meta": {},
    "type": {
      "rowStartIndex": "number | null",
      "rowStartPinned?": "string | null",
      "rowEndIndex": "number | null",
      "rowEndPinned?": "string | null",
      "columnStart?": "string | Column",
      "columnEnd?": "string | Column",
      "columns?": "(string | Column)[]"
    }
  },
  "RangeSelection": {
    "meta": { "doc": "/**\n * @deprecated\n */" },
    "type": {
      "start": "CellPosition",
      "end": "CellPosition",
      "columns": "Column[] | null"
    }
  },
  "AddRangeSelectionParams": {
    "meta": { "doc": "/**\n * @deprecated\n */" },
    "type": {
      "rowStart": "number",
      "floatingStart": "string",
      "rowEnd": "number",
      "floatingEnd": "string",
      "columnStart": "string | Column",
      "columnEnd": "string | Column"
    }
  },
  "CellValue": {
    "meta": { "isTypeAlias": true },
    "type": "object | string | number"
  },
  "IRichCellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "values": "CellValue[]",
      "cellHeight": "number",
      "cellRenderer": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "searchDebounceDelay?": "number"
    }
  },
  "RowBounds": {
    "meta": {},
    "type": { "rowTop": "number", "rowHeight": "number", "rowIndex?": "number" }
  },
  "IRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/**\n * Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/**\n * Returns the rowNode for given id. */",
      "getRowCount()": "/**\n * This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/**\n * Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/**\n * Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/**\n * Returns row top and bottom for a given row */",
      "isEmpty()": "/**\n * Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/**\n * Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/**\n * Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/**\n * Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/**\n * The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/**\n * It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/**\n * Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/**\n * Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IRowNodeBlock": {
    "meta": {},
    "type": {
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "getDisplayIndexStart()": "number",
      "getDisplayIndexEnd()": "number",
      "getLastAccessed()": "number",
      "getState()": "string",
      "isAnyNodeOpen(rowCount: number)": "boolean",
      "getBlockNumber()": "number",
      "forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number)": "void",
      "forEachNodeShallow(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number)": "void",
      "load()": "void"
    }
  },
  "StageExecuteParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowNodeTransaction?": "RowNodeTransaction | null",
      "rowNodeTransactions?": "RowNodeTransaction[] | null",
      "rowNodeOrder?": "{\n    [id: string]: number;\n}",
      "changedPath?": "ChangedPath",
      "afterColumnsChanged?": "boolean"
    }
  },
  "IRowNodeStage": {
    "meta": {},
    "type": { "execute(params: StageExecuteParams)": "any" }
  },
  "IServerSideGetRowsRequest": {
    "meta": {},
    "type": {
      "startRow": "number",
      "endRow": "number",
      "rowGroupCols": "ColumnVO[]",
      "valueCols": "ColumnVO[]",
      "pivotCols": "ColumnVO[]",
      "pivotMode": "boolean",
      "groupKeys": "string[]",
      "filterModel": "any",
      "sortModel": "any"
    }
  },
  "IServerSideGetRowsParams": {
    "meta": {},
    "type": {
      "request": "IServerSideGetRowsRequest",
      "parentNode": "RowNode",
      "successCallback(rowsThisPage: any[], lastRow: number)": "void",
      "success(params: LoadSuccessParams)": "void",
      "failCallback()": "void",
      "fail()": "void",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "IServerSideDatasource": {
    "meta": {},
    "type": {
      "getRows(params: IServerSideGetRowsParams)": "void",
      "destroy?()": "void"
    }
  },
  "IServerSideRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void",
      "refreshStore(params: RefreshStoreParams)": "void",
      "onRowHeightChanged()": "void",
      "getStoreState()": "ServerSideStoreState[]",
      "retryLoads()": "void",
      "expandAll(value: boolean)": "void",
      "setDatasource(datasource: IServerSideDatasource)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void)": "void"
    },
    "docs": {
      "getRow(index: number)": "/**\n * Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/**\n * Returns the rowNode for given id. */",
      "getRowCount()": "/**\n * This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/**\n * Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/**\n * Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/**\n * Returns row top and bottom for a given row */",
      "isEmpty()": "/**\n * Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/**\n * Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/**\n * Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/**\n * Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/**\n * The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/**\n * It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/**\n * Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/**\n * Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IServerSideTransactionManager": {
    "meta": {},
    "type": {
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult | undefined",
      "applyTransactionAsync(transaction: ServerSideTransaction, callback?: (res: ServerSideTransactionResult) => void)": "void",
      "flushAsyncTransactions()": "void"
    }
  },
  "RefreshStoreParams": {
    "meta": {},
    "type": { "route?": "string[]", "purge?": "boolean" }
  },
  "IServerSideStore": {
    "meta": {},
    "type": {
      "clearDisplayIndexes()": "void",
      "getDisplayIndexEnd()": "number | undefined",
      "isDisplayIndexInStore(displayIndex: number)": "boolean",
      "setDisplayIndexes(displayIndexSeq: NumberSequence, nextRowTop: {\n    value: number;\n})": "void",
      "forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence?: NumberSequence)": "void",
      "forEachNodeDeepAfterFilterAndSort(callback: (rowNode: RowNode, index: number) => void, sequence?: NumberSequence)": "void",
      "retryLoads()": "void",
      "getRowUsingDisplayIndex(displayRowIndex: number, dontCreateBlock?: boolean)": "RowNode | null",
      "getRowBounds(index: number)": "RowBounds | null",
      "isPixelInRange(pixel: number)": "boolean",
      "getRowIndexAtPixel(pixel: number)": "number | null",
      "getChildStore(keys: string[])": "IServerSideStore | null",
      "refreshAfterSort(params: StoreRefreshAfterParams)": "void",
      "refreshAfterFilter(params: StoreRefreshAfterParams)": "void",
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult",
      "refreshStore(purge: boolean)": "void",
      "getRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "isLastRowIndexKnown()": "boolean",
      "getRowNodesInRange(firstInRange: RowNode, lastInRange: RowNode)": "RowNode[]",
      "addStoreStates(result: ServerSideStoreState[])": "void"
    }
  },
  "StoreRefreshAfterParams": {
    "meta": {},
    "type": {
      "valueColChanged": "boolean",
      "secondaryColChanged": "boolean",
      "alwaysReset": "boolean",
      "changedColumns": "string[]"
    }
  },
  "ServerSideStoreState": {
    "meta": {},
    "type": {
      "type": "ServerSideStoreType",
      "route": "string[]",
      "rowCount": "number",
      "lastRowIndexKnown?": "boolean",
      "info?": "any",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    }
  },
  "SetFilterValuesFuncParams": {
    "meta": {},
    "type": { "success": "(values: string[]) => void", "colDef": "ColDef" }
  },
  "SetFilterValuesFunc": { "meta": {}, "type": {} },
  "SetFilterValues": {
    "meta": { "isTypeAlias": true },
    "type": "SetFilterValuesFunc | any[]"
  },
  "ISetFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "suppressRemoveEntries?": "boolean",
      "values?": "SetFilterValues",
      "refreshValuesOnOpen?": "boolean",
      "cellHeight?": "number",
      "suppressSorting?": "boolean",
      "cellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "suppressMiniFilter?": "boolean",
      "applyMiniFilterWhileTyping?": "boolean",
      "suppressSelectAll?": "boolean",
      "defaultToNothingSelected?": "boolean",
      "suppressSyncValuesAfterDataChange?": "boolean",
      "comparator?": "(a: any, b: any) => number",
      "textFormatter?": "(from: string) => string",
      "valueFormatter?": "(params: ValueFormatterParams) => string",
      "selectAllOnMiniFilter?": "boolean",
      "syncValuesLikeExcel?": "boolean",
      "showTooltips?": "boolean",
      "excelMode?": "'mac' | 'windows'"
    },
    "docs": {
      "clearButton?": "/**\n * @deprecated\n */",
      "resetButton?": "/**\n * @deprecated\n */",
      "applyButton?": "/**\n * @deprecated\n */",
      "newRowsAction?": "/**\n * @deprecated\n */",
      "suppressRemoveEntries?": "/**\n * @deprecated\n */",
      "suppressSyncValuesAfterDataChange?": "/**\n * @deprecated\n */",
      "selectAllOnMiniFilter?": "/**\n * @deprecated\n */",
      "syncValuesLikeExcel?": "/**\n * @deprecated\n */"
    }
  },
  "ISideBar": {
    "meta": {},
    "type": {
      "refresh()": "void",
      "setDisplayed(show: boolean)": "void",
      "setSideBarPosition(position?: 'left' | 'right')": "void",
      "isToolPanelShowing()": "boolean",
      "openToolPanel(key: string)": "void",
      "getToolPanelInstance(key: string)": "IToolPanel | undefined",
      "close()": "void",
      "openedItem()": "string | null",
      "isDisplayed()": "boolean"
    }
  },
  "IStatusBarService": {
    "meta": {},
    "type": {
      "registerStatusPanel(key: string, component: IStatusPanelComp)": "void",
      "getStatusPanel(key: string)": "IStatusPanelComp"
    }
  },
  "StatusPanelDef": {
    "meta": {},
    "type": {
      "statusPanel?": "{\n    new (): IStatusPanelComp;\n} | string",
      "statusPanelFramework?": "any",
      "align?": "string",
      "key?": "string",
      "statusPanelParams?": "any"
    }
  },
  "IStatusPanelParams": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "context": "any" }
  },
  "IStatusPanel": { "meta": {}, "type": {} },
  "IStatusPanelComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IStatusPanelParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IStatusPanelParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "IToolPanelParams": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi" }
  },
  "IToolPanel": { "meta": {}, "type": { "refresh()": "void" } },
  "IToolPanelComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IToolPanelParams)": "AgPromise<void> | void",
      "refresh()": "void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IToolPanelParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "ToolPanelColumnCompParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "suppressRowGroups": "boolean",
      "suppressValues": "boolean",
      "suppressPivots": "boolean",
      "suppressPivotMode": "boolean",
      "suppressColumnFilter": "boolean",
      "suppressColumnSelectAll": "boolean",
      "suppressColumnExpandAll": "boolean",
      "contractColumnSelection": "boolean",
      "suppressSyncLayoutWithGrid": "boolean"
    }
  },
  "IPrimaryColsPanel": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "init(allowDragging: boolean, params: ToolPanelColumnCompParams, eventType: ColumnEventType)": "void",
      "onExpandAll()": "void",
      "onCollapseAll()": "void",
      "expandGroups(groupIds?: string[])": "void",
      "collapseGroups(groupIds?: string[])": "void",
      "setColumnLayout(colDefs: (ColDef | ColGroupDef)[])": "void",
      "syncLayoutWithGrid()": "void"
    }
  },
  "IViewportDatasource": {
    "meta": {},
    "type": {
      "init(params: IViewportDatasourceParams)": "void",
      "setViewportRange(firstRow: number, lastRow: number)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "init(params: IViewportDatasourceParams)": "/**\n * Gets called exactly once before viewPort is used. Passes methods to be used to tell viewPort of data loads / changes. */",
      "setViewportRange(firstRow: number, lastRow: number)": "/**\n * Tell the viewport what the scroll position of the grid is, so it knows what rows it has to get */",
      "destroy?()": "/**\n * Gets called once when viewPort is no longer used. If you need to do any cleanup, do it here. */"
    }
  },
  "IViewportDatasourceParams": {
    "meta": {},
    "type": {
      "setRowCount": "(count: number, keepRenderedRows: boolean) => void",
      "setRowData": "(rowData: {\n    [key: number]: any;\n}) => void",
      "getRow": "(rowIndex: number) => RowNode"
    },
    "docs": {
      "setRowCount": "/**\n * datasource calls this method when the total row count changes. This in turn sets the height of the grids vertical scroll. */",
      "setRowData": "/**\n * datasource calls this when new data arrives. The grid then updates the provided rows. The rows are mapped [rowIndex]=>rowData]. */",
      "getRow": "/**\n * datasource calls this when it wants a row node - typically used when it wants to update the row node */"
    }
  },
  "XmlElement": {
    "meta": {},
    "type": {
      "name": "string",
      "properties?": "XmlAttributes",
      "children?": "XmlElement[]",
      "textNode?": "string | null"
    }
  },
  "HeaderElement": {
    "meta": {},
    "type": {
      "[key: string]": "string | undefined",
      "version?": "string",
      "standalone?": "string",
      "encoding?": "string"
    }
  },
  "XmlAttributes": {
    "meta": {},
    "type": {
      "prefixedAttributes?": "PrefixedXmlAttributes[]",
      "rawMap?": "any"
    }
  },
  "PrefixedXmlAttributes": {
    "meta": {},
    "type": { "prefix": "string", "map": "any" }
  },
  "RowDataTransaction": {
    "meta": {},
    "type": {
      "addIndex?": "number | null",
      "add?": "any[] | null",
      "remove?": "any[] | null",
      "update?": "any[] | null"
    }
  },
  "RowNodeTransaction": {
    "meta": {},
    "type": { "add": "RowNode[]", "remove": "RowNode[]", "update": "RowNode[]" }
  },
  "ServerSideTransaction": {
    "meta": {},
    "type": {
      "route?": "string[]",
      "addIndex?": "number",
      "add?": "any[]",
      "remove?": "any[]",
      "update?": "any[]"
    }
  },
  "ServerSideTransactionResult": {
    "meta": {},
    "type": {
      "status": "ServerSideTransactionResultStatus",
      "add?": "RowNode[]",
      "remove?": "RowNode[]",
      "update?": "RowNode[]"
    }
  },
  "ServerSideTransactionResultStatus": {
    "meta": { "isEnum": true },
    "type": [
      "StoreNotFound = 'StoreNotFound'",
      "StoreLoading = 'StoreLoading'",
      "StoreWaitingToLoad = 'StoreWaitingToLoad'",
      "StoreLoadingFailed = 'StoreLoadingFailed'",
      "StoreWrongType = 'StoreWrongType'",
      "Applied = 'Applied'",
      "Cancelled = 'Cancelled'"
    ]
  },
  "TabbedLayoutParams": {
    "meta": {},
    "type": {
      "items": "TabbedItem[]",
      "cssClass?": "string",
      "onItemClicked?": "Function",
      "onActiveItemClicked?": "Function"
    }
  },
  "TabbedItem": {
    "meta": {},
    "type": {
      "title": "Element",
      "titleLabel": "string",
      "bodyPromise": "AgPromise<HTMLElement>",
      "name": "string",
      "afterAttachedCallback?": "(params: IAfterGuiAttachedParams) => void"
    }
  },
  "TabbedItemWrapper": {
    "meta": {},
    "type": { "tabbedItem": "TabbedItem", "eHeaderButton": "HTMLElement" }
  },
  "TaskItem": {
    "meta": {},
    "type": { "task": "() => void", "index": "number", "createOrder": "number" }
  },
  "TaskList": {
    "meta": {},
    "type": { "list": "TaskItem[]", "sorted": "boolean" }
  },
  "SimpleHttpRequestParams": { "meta": {}, "type": { "url": "string" } },
  "ModuleNames": {
    "meta": { "isEnum": true },
    "type": [
      "CommunityCoreModule = \"@ag-grid-community/core\"",
      "CommunityAllModules = \"@ag-grid-community/all\"",
      "InfiniteRowModelModule = \"@ag-grid-community/infinite-row-model\"",
      "ClientSideRowModelModule = \"@ag-grid-community/client-side-row-model\"",
      "CsvExportModule = \"@ag-grid-community/csv-export\"",
      "EnterpriseCoreModule = \"@ag-grid-enterprise/core\"",
      "EnterpriseAllModules = \"@ag-grid-enterprise/all\"",
      "RowGroupingModule = \"@ag-grid-enterprise/row-grouping\"",
      "ColumnToolPanelModule = \"@ag-grid-enterprise/column-tool-panel\"",
      "FiltersToolPanelModule = \"@ag-grid-enterprise/filter-tool-panel\"",
      "MenuModule = \"@ag-grid-enterprise/menu\"",
      "SetFilterModule = \"@ag-grid-enterprise/set-filter\"",
      "MultiFilterModule = \"@ag-grid-enterprise/multi-filter\"",
      "StatusBarModule = \"@ag-grid-enterprise/status-bar\"",
      "SideBarModule = \"@ag-grid-enterprise/side-bar\"",
      "RangeSelectionModule = \"@ag-grid-enterprise/range-selection\"",
      "MasterDetailModule = \"@ag-grid-enterprise/master-detail\"",
      "RichSelectModule = \"@ag-grid-enterprise/rich-select\"",
      "GridChartsModule = \"@ag-grid-enterprise/charts\"",
      "ViewportRowModelModule = \"@ag-grid-enterprise/viewport-row-model\"",
      "ServerSideRowModelModule = \"@ag-grid-enterprise/server-side-row-model\"",
      "ExcelExportModule = \"@ag-grid-enterprise/excel-export\"",
      "ClipboardModule = \"@ag-grid-enterprise/clipboard\"",
      "AngularModule = \"@ag-grid-community/angular\"",
      "ReactModule = \"@ag-grid-community/react\"",
      "VueModule = \"@ag-grid-community/vue\"",
      "PolymerModule = \"@ag-grid-community/polymer\""
    ]
  },
  "ICellComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setUserStyles(styles: any)": "void",
      "setAriaSelected(selected: boolean | undefined)": "void",
      "setAriaExpanded(expanded: boolean)": "void",
      "getFocusableElement()": "HTMLElement",
      "setLeft(left: string)": "void",
      "setWidth(width: string)": "void",
      "setAriaColIndex(index: number)": "void",
      "setHeight(height: string)": "void",
      "setZIndex(zIndex: string)": "void",
      "setTabIndex(tabIndex: number)": "void",
      "setRole(role: string)": "void",
      "setColId(colId: string)": "void",
      "setTitle(title: string | undefined)": "void",
      "setUnselectable(value: 'on' | null)": "void",
      "setTransition(value: string | undefined)": "void",
      "setIncludeSelection(include: boolean)": "void",
      "setIncludeRowDrag(include: boolean)": "void",
      "setIncludeDndSource(include: boolean)": "void",
      "setForceWrapper(force: boolean)": "void",
      "getCellEditor()": "ICellEditor | null",
      "getCellRenderer()": "ICellRenderer | null",
      "getParentOfValue()": "HTMLElement | null",
      "setRenderDetails(compDetails: UserCompDetails | undefined, valueToDisplay: any, forceNewCellRendererInstance: boolean)": "void",
      "setEditDetails(compDetails?: UserCompDetails, popup?: boolean, position?: string)": "void"
    }
  },
  "ILargeTextEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "maxLength": "number",
      "rows": "number",
      "cols": "number"
    }
  },
  "ISelectCellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "values": "any[]"
    }
  },
  "ITextCellEditorParams": {
    "meta": {
      "doc": "/**\n * useFormatter: used when the cell value needs formatting prior to editing, such as when using reference data and you\n *                want to display text rather than code. */"
    },
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "useFormatter": "boolean"
    }
  },
  "IGroupCellRenderer": {
    "meta": {},
    "type": {
      "setInnerRenderer(compDetails: UserCompDetails | undefined, valueToDisplay: any)": "void",
      "setChildCount(count: string)": "void",
      "setCheckboxVisible(value: boolean)": "void",
      "setExpandedDisplayed(value: boolean)": "void",
      "setContractedDisplayed(value: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "GroupCellRendererParams": {
    "meta": {},
    "type": {
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "value": "any",
      "valueFormatted": "any",
      "data": "any",
      "node": "RowNode",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string) => void",
      "pinned": "string",
      "fullWidth": "boolean",
      "suppressPadding": "boolean",
      "suppressDoubleClickExpand": "boolean",
      "suppressEnterExpand": "boolean",
      "footerValueGetter": "any",
      "suppressCount": "boolean",
      "checkbox": "any",
      "rowDrag?": "boolean",
      "innerRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "innerRendererFramework?": "any",
      "innerRendererParams?": "any",
      "scope": "any",
      "padding": "number"
    },
    "docs": {
      "registerRowDragger": "/**\n * registerRowDragger: Function\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n */",
      "padding": "/**\n * @deprecated\n */"
    }
  },
  "ICellRendererParams": {
    "meta": {},
    "type": {
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "value": "any",
      "valueFormatted": "any",
      "data": "any",
      "node": "RowNode",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string) => void"
    },
    "docs": {
      "registerRowDragger": "/**\n * registerRowDragger: Function\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n */"
    }
  },
  "ISetFilterCellRendererParams": {
    "meta": {},
    "type": {
      "value": "any",
      "valueFormatted": "any",
      "api": "GridApi",
      "context": "any"
    }
  },
  "ICellRenderer": {
    "meta": {},
    "type": { "refresh(params: ICellRendererParams)": "boolean" },
    "docs": {
      "refresh(params: ICellRendererParams)": "/**\n * Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n * then the grid will refresh the cell for you. */"
    }
  },
  "ICellRendererComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: ICellRendererParams)": "AgPromise<void> | void",
      "refresh(params: ICellRendererParams)": "boolean"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: ICellRendererParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */",
      "refresh(params: ICellRendererParams)": "/**\n * Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n * then the grid will refresh the cell for you. */"
    }
  },
  "ICellRendererFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "any" },
      "returnType": "HTMLElement | string"
    }
  },
  "ILoadingCellRendererParams": {
    "meta": {},
    "type": {
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "value": "any",
      "valueFormatted": "any",
      "data": "any",
      "node": "RowNode",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string) => void"
    },
    "docs": {
      "registerRowDragger": "/**\n * registerRowDragger: Function\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n */"
    }
  },
  "ILoadingCellRenderer": {
    "meta": {},
    "type": { "refresh(params: ICellRendererParams)": "boolean" },
    "docs": {
      "refresh(params: ICellRendererParams)": "/**\n * Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n * then the grid will refresh the cell for you. */"
    }
  },
  "IDate": {
    "meta": {},
    "type": {
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void"
    },
    "docs": {
      "getDate()": "/**\n * Returns the current date represented by this editor */",
      "setDate(date: Date | null)": "/**\n * Sets the date represented by this component */"
    }
  },
  "IDateParams": {
    "meta": {},
    "type": {
      "onDateChanged": "() => void",
      "filterParams": "IDateFilterParams"
    },
    "docs": {
      "onDateChanged": "/**\n * Method for component to tell AG Grid that the date has changed. */"
    }
  },
  "IDateComp": {
    "meta": {},
    "type": {
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IDateParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getDate()": "/**\n * Returns the current date represented by this editor */",
      "setDate(date: Date | null)": "/**\n * Sets the date represented by this component */",
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IDateParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "PositionableOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "/**\n * Used for when a popup needs to be resized by an element within itself\n * In that case, the feature will configured as `popup=false` but the offsetParent\n * needs to be the popupParent. */"
    }
  },
  "ResizableSides": {
    "meta": { "isTypeAlias": true },
    "type": "'topLeft' | 'top' | 'topRight' | 'right' | 'bottomRight' | 'bottom' | 'bottomLeft' | 'left'"
  },
  "ResizableStructure": { "meta": {}, "type": {} },
  "MappedResizer": {
    "meta": {},
    "type": { "element": "HTMLElement", "dragSource?": "DragListenerParams" }
  },
  "ILoadingOverlayParams": { "meta": {}, "type": { "api": "GridApi" } },
  "ILoadingOverlayComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: ILoadingOverlayParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: ILoadingOverlayParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "INoRowsOverlayParams": { "meta": {}, "type": { "api": "GridApi" } },
  "INoRowsOverlayComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: INoRowsOverlayParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: INoRowsOverlayParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "LoadingType": { "meta": { "isEnum": true }, "type": ["Loading", "NoRows"] },
  "RowCssClassCalculatorParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowIsEven": "boolean",
      "rowLevel": "number",
      "fullWidthRow?": "boolean",
      "firstRowOnPage": "boolean",
      "lastRowOnPage": "boolean",
      "printLayout": "boolean",
      "expandable": "boolean",
      "pinned?": "string | null",
      "extraCssClass?": "string",
      "rowFocused?": "boolean",
      "fadeRowIn?": "boolean",
      "scope?": "any"
    }
  },
  "RowType": {
    "meta": { "isEnum": true },
    "type": [
      "Normal = 'Normal'",
      "FullWidth = 'FullWidth'",
      "FullWidthLoading = 'FullWidthLoading'",
      "FullWidthGroup = 'FullWidthGroup'",
      "FullWidthDetail = 'FullWidthDetail'"
    ]
  },
  "IRowComp": {
    "meta": {},
    "type": {
      "setDisplay(value?: string)": "void",
      "setDomOrder(domOrder: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setCellCtrls(cellCtrls: CellCtrl[])": "void",
      "showFullWidth(compDetails: UserCompDetails)": "void",
      "getFullWidthRowComp()": "ICellRendererComp | null | undefined",
      "setAriaExpanded(on: boolean)": "void",
      "destroyCells(cellComps: CellComp[])": "void",
      "setAriaSelected(selected: boolean | undefined)": "void",
      "setHeight(height: string)": "void",
      "destroy()": "void",
      "setTop(top: string)": "void",
      "setTransform(transform: string)": "void",
      "setRowIndex(rowIndex: string)": "void",
      "setAriaRowIndex(rowIndex: number)": "void",
      "setRowId(rowId: string)": "void",
      "setRowBusinessKey(businessKey: string)": "void",
      "setTabIndex(tabIndex: number)": "void",
      "setAriaLabel(label: string | undefined)": "void",
      "setUserStyles(styles: any)": "void",
      "setRole(role: string)": "void"
    }
  },
  "RowGui": {
    "meta": {},
    "type": {
      "rowComp": "IRowComp",
      "element": "HTMLElement",
      "pinned": "string | null"
    }
  },
  "CellCtrlListAndMap": {
    "meta": {},
    "type": {
      "list": "CellCtrl[]",
      "map": "{\n    [key: string]: CellCtrl;\n}"
    }
  },
  "IRowDragItem": {
    "meta": {},
    "type": {
      "rowNode?": "RowNode",
      "rowNodes?": "RowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{\n    [key: string]: boolean;\n}",
      "defaultTextValue": "string"
    },
    "docs": {
      "rowNode?": "/**\n * When dragging a row, this contains the row node being dragged\n * When dragging multiple rows, this contains the row that started the drag. */",
      "rowNodes?": "/**\n * When dragging multiple rows, this contains all rows being dragged */",
      "columns?": "/**\n * When dragging columns, this contains the columns being dragged */",
      "visibleState?": "/**\n * When dragging columns, this contains the visible state of the columns */"
    }
  },
  "RowCtrlMap": { "meta": {}, "type": { "[key: string]": "RowCtrl" } },
  "RefreshViewParams": {
    "meta": {},
    "type": {
      "recycleRows?": "boolean",
      "animate?": "boolean",
      "suppressKeepFocus?": "boolean",
      "onlyBody?": "boolean",
      "newData?": "boolean",
      "newPage?": "boolean"
    }
  },
  "ITooltipParams": {
    "meta": {},
    "type": {
      "location": "string",
      "api?": "GridApi",
      "columnApi?": "ColumnApi",
      "context?": "any",
      "colDef?": "ColDef | ColGroupDef | null",
      "column?": "Column | ColumnGroup",
      "value?": "any",
      "valueFormatted?": "any",
      "rowIndex?": "number",
      "node?": "RowNode",
      "data?": "any"
    }
  },
  "ITooltipComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: ITooltipParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/**\n * Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/**\n * Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/**\n * A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: ITooltipParams)": "/**\n * The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "LoadCompleteEvent": {
    "meta": {},
    "type": { "type": "string", "success": "boolean", "block": "RowNodeBlock" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "LoadSuccessParams": {
    "meta": {},
    "type": { "rowData": "any[]", "rowCount?": "number", "storeInfo?": "any" }
  },
  "SortOption": {
    "meta": {},
    "type": { "sort": "string", "column": "Column" }
  },
  "SortedRowNode": {
    "meta": {},
    "type": { "currentPos": "number", "rowNode": "RowNode" }
  },
  "SortModelItem": {
    "meta": {},
    "type": { "colId": "string", "sort": "string" }
  },
  "LayoutView": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "LayoutCssClasses": {
    "meta": { "isEnum": true },
    "type": [
      "AUTO_HEIGHT = 'ag-layout-auto-height'",
      "NORMAL = 'ag-layout-normal'",
      "PRINT = 'ag-layout-print'"
    ]
  },
  "UpdateLayoutClassesParams": {
    "meta": {},
    "type": { "autoHeight": "boolean", "normal": "boolean", "print": "boolean" }
  },
  "GenericFunction": { "meta": {}, "type": {} },
  "PickByTypeKeyFilter": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "KeysByType": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "ValuesByType": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "PickByType": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "MethodsOf": { "meta": { "typeParams": ["T"] }, "type": {} },
  "InterfaceOf": { "meta": { "typeParams": ["T"] }, "type": {} },
  "PartiallyMockedInterfaceOf": { "meta": { "typeParams": ["T"] }, "type": {} },
  "CellValueChange": {
    "meta": {},
    "type": {
      "rowPinned": "string | null",
      "rowIndex": "number",
      "columnId": "string",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "LastFocusedCell": {
    "meta": {},
    "type": {
      "rowPinned?": "string | null",
      "rowIndex": "number",
      "columnId": "string"
    }
  },
  "ColumnSortState": {
    "meta": { "isTypeAlias": true },
    "type": "'ascending' | 'descending' | 'none'"
  },
  "PathItem": {
    "meta": {},
    "type": { "rowNode": "RowNode", "children": "PathItem[] | null" }
  },
  "ResolveAndRejectCallback": { "meta": { "typeParams": ["T"] }, "type": {} },
  "AgPromiseStatus": {
    "meta": { "isEnum": true },
    "type": ["IN_PROGRESS", "RESOLVED"]
  },
  "FieldElement": {
    "meta": { "isTypeAlias": true },
    "type": "HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement"
  },
  "IInputField": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "value?": "any",
      "width?": "number"
    }
  },
  "LabelAlignment": {
    "meta": { "isTypeAlias": true },
    "type": "'left' | 'right' | 'top'"
  },
  "IAgLabel": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment"
    }
  },
  "ChangeEvent": {
    "meta": {},
    "type": { "type": "string", "selected": "boolean" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ColorPickerConfig": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "color": "string"
    }
  },
  "DialogOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null",
      "component?": "Component",
      "hideTitleBar?": "boolean | null",
      "closable?": "boolean | null",
      "resizable?": "boolean | ResizableStructure",
      "title?": "string | null",
      "cssIdentifier?": "string | null",
      "eWrapper?": "HTMLElement",
      "modal?": "boolean",
      "movable?": "boolean",
      "alwaysOnTop?": "boolean",
      "maximizable?": "boolean"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "/**\n * Used for when a popup needs to be resized by an element within itself\n * In that case, the feature will configured as `popup=false` but the offsetParent\n * needs to be the popupParent. */"
    }
  },
  "GroupItem": {
    "meta": { "isTypeAlias": true },
    "type": "Component | HTMLElement"
  },
  "Align": {
    "meta": { "isTypeAlias": true },
    "type": "'start' | 'end' | 'center' | 'stretch'"
  },
  "Direction": {
    "meta": { "isTypeAlias": true },
    "type": "'horizontal' | 'vertical'"
  },
  "AgGroupComponentParams": {
    "meta": {},
    "type": {
      "title?": "string",
      "enabled?": "boolean",
      "suppressEnabledCheckbox?": "boolean",
      "suppressOpenCloseIcons?": "boolean",
      "cssIdentifier?": "string",
      "items?": "GroupItem[]",
      "alignItems?": "Align",
      "direction?": "Direction"
    }
  },
  "IInputRange": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "value?": "any",
      "width?": "number",
      "min?": "number",
      "max?": "number",
      "step?": "number"
    }
  },
  "ITextInputField": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "value?": "any",
      "width?": "number",
      "allowedCharPattern?": "string"
    }
  },
  "ListOption": {
    "meta": {},
    "type": { "value": "string", "text?": "string" }
  },
  "PanelOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null",
      "component?": "Component",
      "hideTitleBar?": "boolean | null",
      "closable?": "boolean | null",
      "resizable?": "boolean | ResizableStructure",
      "title?": "string | null",
      "cssIdentifier?": "string | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "/**\n * Used for when a popup needs to be resized by an element within itself\n * In that case, the feature will configured as `popup=false` but the offsetParent\n * needs to be the popupParent. */"
    }
  },
  "VisibleChangedEvent": {
    "meta": {},
    "type": { "type": "string", "visible": "boolean" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "ManagedFocusCallbacks": {
    "meta": {},
    "type": {
      "shouldStopEventPropagation?": "(e: KeyboardEvent) => boolean",
      "onTabKeyDown?": "(e: KeyboardEvent) => void",
      "handleKeyDown?": "(e: KeyboardEvent) => void",
      "onFocusIn?": "(e: FocusEvent) => void",
      "onFocusOut?": "(e: FocusEvent) => void"
    }
  },
  "PopupEventParams": {
    "meta": {},
    "type": {
      "originalMouseEvent?": "MouseEvent | Touch | null",
      "mouseEvent?": "MouseEvent",
      "touchEvent?": "TouchEvent",
      "keyboardEvent?": "KeyboardEvent"
    }
  },
  "AgPopup": {
    "meta": {},
    "type": {
      "element": "HTMLElement",
      "wrapper": "HTMLElement",
      "hideFunc": "() => void",
      "stopAnchoringPromise": "AgPromise<Function>",
      "instanceId": "number"
    }
  },
  "Rect": {
    "meta": {},
    "type": {
      "top": "number",
      "left": "number",
      "right": "number",
      "bottom": "number"
    }
  },
  "DIRECTION": {
    "meta": { "isEnum": true },
    "type": ["vertical", "horizontal"]
  },
  "AddPopupParams": {
    "meta": {},
    "type": {
      "modal?": "boolean",
      "eChild": "any",
      "closeOnEsc?": "boolean",
      "closedCallback?": "(e?: MouseEvent | TouchEvent | KeyboardEvent) => void",
      "click?": "MouseEvent | Touch | null",
      "alwaysOnTop?": "boolean",
      "afterGuiAttached?": "(params: IAfterGuiAttachedParams) => void",
      "positionCallback?": "() => void",
      "anchorToElement?": "HTMLElement"
    }
  },
  "AddPopupResult": {
    "meta": {},
    "type": {
      "hideFunc": "() => void",
      "stopAnchoringPromise": "AgPromise<Function>"
    }
  },
  "ITabGuard": {
    "meta": {},
    "type": { "setTabIndex(tabIndex?: string)": "void" }
  },
  "TooltipParentComp": {
    "meta": {},
    "type": {
      "getTooltipParams()": "ITooltipParams",
      "getGui()": "HTMLElement"
    }
  },
  "TooltipStates": {
    "meta": { "isEnum": true },
    "type": ["NOTHING", "WAITING_TO_SHOW", "SHOWING"]
  },
  "TapEvent": {
    "meta": {},
    "type": { "type": "string", "touchStart": "Touch" },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "LongTapEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "touchStart": "Touch",
      "touchEvent": "TouchEvent"
    },
    "docs": { "type": "/**\n * Event identifier */" }
  },
  "VirtualListModel": {
    "meta": {},
    "type": {
      "getRowCount()": "number",
      "getRow(index: number)": "any",
      "isRowSelected?(index: number)": "boolean | undefined"
    }
  }
}
