{
  "ApplyColumnStateParams": {
    "meta": {},
    "type": {
      "state?": "ColumnState[]",
      "applyOrder?": "boolean",
      "defaultState?": "ColumnState"
    }
  },
  "ColumnResizeSet": {
    "meta": {},
    "type": { "columns": "Column[]", "ratios": "number[]", "width": "number" }
  },
  "ColumnState": {
    "meta": {},
    "type": {
      "colId?": "string",
      "hide?": "boolean | null",
      "aggFunc?": "string | IAggFunc | null",
      "width?": "number",
      "pivot?": "boolean | null",
      "pivotIndex?": "number | null",
      "pinned?": "boolean | string | 'left' | 'right' | null",
      "rowGroup?": "boolean | null",
      "rowGroupIndex?": "number | null",
      "flex?": "number | null",
      "sort?": "string | null",
      "sortIndex?": "number | null"
    }
  },
  "ComponentMetadata": {
    "meta": {},
    "type": {
      "mandatoryMethodList": "string[]",
      "optionalMethodList": "string[]",
      "functionAdapter?": "(callback: any) => {\n    new (): IComponent<any>;\n}"
    }
  },
  "ComponentType": {
    "meta": {},
    "type": { "propertyName": "string", "isCellRenderer()": "boolean" }
  },
  "FrameworkComponentWrapper": {
    "meta": {},
    "type": {
      "wrap(frameworkComponent: {\n    new (): any;\n} | null, methodList: string[], optionalMethodList: string[], componentType: ComponentType, componentName?: string | null)": "A"
    }
  },
  "WrappableInterface": {
    "meta": {},
    "type": {
      "hasMethod(name: string)": "boolean",
      "callMethod(name: string, args: IArguments)": "void",
      "addMethod(name: string, callback: Function)": "void"
    }
  },
  "DefinitionObject": {
    "meta": { "isTypeAlias": true },
    "type": "GridOptions | ColDef | ColGroupDef | IFilterDef | ISetFilterParams | IRichCellEditorParams | ToolPanelDef | StatusPanelDef"
  },
  "UserCompDetails": {
    "meta": {},
    "type": {
      "componentClass": "any",
      "componentFromFramework": "boolean",
      "params": "any"
    }
  },
  "RegisteredComponent": {
    "meta": {},
    "type": { "component": "any", "componentFromFramework": "boolean" }
  },
  "DeprecatedComponentName": {
    "meta": {},
    "type": { "propertyHolder": "string", "newComponentName": "string" }
  },
  "ContextParams": {
    "meta": {},
    "type": {
      "providedBeanInstances": "any",
      "beanClasses": "any[]",
      "debug": "boolean"
    }
  },
  "ComponentMeta": {
    "meta": {},
    "type": { "componentClass": "new () => Object", "componentName": "string" }
  },
  "BeanWrapper": {
    "meta": {},
    "type": { "bean": "any", "beanInstance": "any", "beanName": "any" }
  },
  "ReadyParams": {
    "meta": {},
    "type": {
      "gridCtrl": "GridCtrl",
      "gridBodyCtrl": "GridBodyCtrl",
      "centerRowContainerCtrl": "RowContainerCtrl",
      "leftRowContainerCtrl": "RowContainerCtrl",
      "rightRowContainerCtrl": "RowContainerCtrl",
      "bottomCenterRowContainerCtrl": "RowContainerCtrl",
      "bottomLeftRowContainerCtrl": "RowContainerCtrl",
      "bottomRightRowContainerCtrl": "RowContainerCtrl",
      "topCenterRowContainerCtrl": "RowContainerCtrl",
      "topLeftRowContainerCtrl": "RowContainerCtrl",
      "topRightRowContainerCtrl": "RowContainerCtrl",
      "fakeHScrollCtrl": "FakeHScrollCtrl",
      "headerRootComp": "HeaderRootComp"
    }
  },
  "DragItem": {
    "meta": {},
    "type": {
      "rowNode?": "RowNode",
      "rowNodes?": "RowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{\n    [key: string]: boolean;\n}"
    },
    "docs": {
      "rowNode?": "When dragging a row, this contains the row node being dragged\nWhen dragging multiple rows, this contains the row that started the drag.",
      "rowNodes?": "When dragging multiple rows, this contains all rows being dragged",
      "columns?": "When dragging columns, this contains the columns being dragged",
      "visibleState?": "When dragging columns, this contains the visible state of the columns"
    }
  },
  "DragSourceType": {
    "meta": { "isEnum": true },
    "type": ["ToolPanel", "HeaderCell", "RowDrag", "ChartPanel"]
  },
  "DragSource": {
    "meta": {},
    "type": {
      "type": "DragSourceType",
      "eElement": "HTMLElement",
      "getDragItem": "() => DragItem",
      "dragItemName": "string | (() => string) | null",
      "defaultIconName?": "string",
      "dragSourceDropTarget?": "DropTarget",
      "dragSourceDomDataKey?": "string",
      "dragStartPixels?": "number",
      "onDragStarted?": "() => void",
      "onDragStopped?": "() => void"
    },
    "docs": {
      "type": "The type of the drag source, used by the drop target to know where the\ndrag originated from.",
      "eElement": "Element which, when dragged, will kick off the DnD process",
      "getDragItem": "If eElement is dragged, then the dragItem is the object that gets passed around.",
      "dragItemName": "This name appears in the ghost icon when dragging.",
      "defaultIconName?": "Icon to show when not over a drop zone",
      "dragSourceDropTarget?": "The drop target associated with this dragSource. When dragging starts, this\ntarget does not get an onDragEnter event.",
      "dragSourceDomDataKey?": "The drag source DOM Data Key, this is useful to detect if the origin grid is the same\nas the target grid.",
      "dragStartPixels?": "After how many pixels of dragging should the drag operation start. Default is 4.",
      "onDragStarted?": "Callback for drag started",
      "onDragStopped?": "Callback for drag stopped"
    }
  },
  "DropTarget": {
    "meta": {},
    "type": {
      "getContainer()": "HTMLElement",
      "getSecondaryContainers?()": "HTMLElement[][]",
      "getIconName?()": "string | null",
      "isInterestedIn(type: DragSourceType)": "boolean",
      "onDragEnter?(params: DraggingEvent)": "void",
      "onDragLeave?(params: DraggingEvent)": "void",
      "onDragging?(params: DraggingEvent)": "void",
      "onDragStop?(params: DraggingEvent)": "void",
      "external?": "boolean"
    },
    "docs": {
      "getContainer()": "The main container that will get the drop.",
      "getSecondaryContainers?()": "If any secondary containers. For example when moving columns in AG Grid, we listen for drops\nin the header as well as the body (main rows and pinned rows) of the grid.",
      "getIconName?()": "Icon to show when drag is over",
      "onDragEnter?(params: DraggingEvent)": "Callback for when drag enters",
      "onDragLeave?(params: DraggingEvent)": "Callback for when drag leaves",
      "onDragging?(params: DraggingEvent)": "Callback for when dragging",
      "onDragStop?(params: DraggingEvent)": "Callback for when drag stops"
    }
  },
  "VerticalDirection": { "meta": { "isEnum": true }, "type": ["Up", "Down"] },
  "HorizontalDirection": {
    "meta": { "isEnum": true },
    "type": ["Left", "Right"]
  },
  "DraggingEvent": {
    "meta": {},
    "type": {
      "event": "MouseEvent",
      "x": "number",
      "y": "number",
      "vDirection": "VerticalDirection | null",
      "hDirection": "HorizontalDirection | null",
      "dragSource": "DragSource",
      "dragItem": "DragItem",
      "fromNudge": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "dropZoneTarget": "HTMLElement"
    }
  },
  "DragSourceAndListener": {
    "meta": {},
    "type": {
      "dragSource": "DragListenerParams",
      "mouseDownListener": "(mouseEvent: MouseEvent) => void",
      "touchEnabled": "boolean",
      "touchStartListener": "((touchEvent: TouchEvent) => void) | null"
    }
  },
  "DragListenerParams": {
    "meta": {},
    "type": {
      "dragStartPixels?": "number",
      "eElement": "HTMLElement",
      "skipMouseEvent?": "(mouseEvent: MouseEvent) => boolean",
      "onDragStart": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragStop": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragging": "(mouseEvent: MouseEvent | Touch) => void"
    },
    "docs": {
      "dragStartPixels?": "After how many pixels of dragging should the drag operation start. Default is 4px.",
      "eElement": "Dom element to add the drag handling to",
      "skipMouseEvent?": "Some places may wish to ignore certain events, eg range selection ignores shift clicks",
      "onDragStart": "Callback for drag starting",
      "onDragStop": "Callback for drag stopping",
      "onDragging": "Callback for mouse move while dragging"
    }
  },
  "CellPosition": {
    "meta": {},
    "type": {
      "rowIndex": "number",
      "rowPinned?": "string | null",
      "column": "Column"
    }
  },
  "AbstractColDef": {
    "meta": {},
    "type": {
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "string | string[] | ((params: HeaderClassParams) => string | string[])",
      "toolPanelClass?": "string | string[] | ((params: ToolPanelClassParams) => string | string[])",
      "headerValueGetter?": "string | Function",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{\n    new (): ITooltipComp;\n} | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean"
    },
    "docs": {
      "headerName?": "The name to render in the column header",
      "columnGroupShow?": "Whether to show the column when the group is open / closed.",
      "headerClass?": "CSS class for the header",
      "toolPanelClass?": "CSS class for the toolPanel",
      "headerValueGetter?": "Expression or function to get the cells value.",
      "pivotKeys?": "Never set this, it is used internally by grid when doing in-grid pivoting",
      "suppressColumnsToolPanel?": "Set to true to not include this column in the Columns Tool Panel",
      "suppressFiltersToolPanel?": "Set to true to not include this column / filter in the Filters Tool Panel",
      "headerTooltip?": "Tooltip for the column header",
      "suppressHeaderKeyboardEvent?": "Allows the user to suppress certain keyboard events in the grid header"
    }
  },
  "ColGroupDef": {
    "meta": {},
    "type": {
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "string | string[] | ((params: HeaderClassParams) => string | string[])",
      "toolPanelClass?": "string | string[] | ((params: ToolPanelClassParams) => string | string[])",
      "headerValueGetter?": "string | Function",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{\n    new (): ITooltipComp;\n} | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean",
      "children": "(ColDef | ColGroupDef)[]",
      "groupId?": "string",
      "openByDefault?": "boolean",
      "marryChildren?": "boolean",
      "headerGroupComponent?": "string | {\n    new (): IHeaderGroupComp;\n}",
      "headerGroupComponentFramework?": "any",
      "headerGroupComponentParams?": "any"
    },
    "docs": {
      "headerName?": "The name to render in the column header",
      "columnGroupShow?": "Whether to show the column when the group is open / closed.",
      "headerClass?": "CSS class for the header",
      "toolPanelClass?": "CSS class for the toolPanel",
      "headerValueGetter?": "Expression or function to get the cells value.",
      "pivotKeys?": "Never set this, it is used internally by grid when doing in-grid pivoting",
      "suppressColumnsToolPanel?": "Set to true to not include this column in the Columns Tool Panel",
      "suppressFiltersToolPanel?": "Set to true to not include this column / filter in the Filters Tool Panel",
      "headerTooltip?": "Tooltip for the column header",
      "suppressHeaderKeyboardEvent?": "Allows the user to suppress certain keyboard events in the grid header",
      "children": "Columns in this group",
      "groupId?": "Group ID",
      "openByDefault?": "Open by Default",
      "marryChildren?": "If true, group cannot be broken up by column moving, child columns will always appear side by side, however you can rearrange child columns within the group",
      "headerGroupComponent?": "The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used*",
      "headerGroupComponentFramework?": "The custom header group component to be used for rendering the component header in the hosting framework (ie: React/Angular). If none specified the default AG Grid is used*",
      "headerGroupComponentParams?": "The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used*"
    }
  },
  "IAggFunc": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "params": "IAggFuncParams" }, "returnType": "any" }
  },
  "IAggFuncParams": {
    "meta": {},
    "type": {
      "values": "any[]",
      "column": "Column",
      "colDef": "ColDef",
      "rowNode": "RowNode",
      "data": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "HeaderClassParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "colDef": "AbstractColDef",
      "column?": "Column | null",
      "columnGroup?": "ColumnGroup | OriginalColumnGroup | null",
      "context?": "any"
    }
  },
  "ToolPanelClassParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "colDef": "AbstractColDef",
      "column?": "Column | null",
      "columnGroup?": "ColumnGroup | OriginalColumnGroup | null",
      "context?": "any"
    }
  },
  "ColDef": {
    "meta": {},
    "type": {
      "filter?": "IFilterType",
      "filterFramework?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "string | {\n    new (): IFloatingFilterComp;\n}",
      "floatingFilterComponentParams?": "any",
      "floatingFilterComponentFramework?": "any",
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "string | string[] | ((params: HeaderClassParams) => string | string[])",
      "toolPanelClass?": "string | string[] | ((params: ToolPanelClassParams) => string | string[])",
      "headerValueGetter?": "string | Function",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{\n    new (): ITooltipComp;\n} | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean",
      "colId?": "string",
      "sort?": "string | null",
      "initialSort?": "string",
      "sortIndex?": "number | null",
      "initialSortIndex?": "number",
      "sortedAt?": "number",
      "sortingOrder?": "(string | null)[]",
      "field?": "string",
      "type?": "string | string[]",
      "hide?": "boolean",
      "initialHide?": "boolean",
      "pinned?": "boolean | string | null",
      "initialPinned?": "boolean | string",
      "tooltipField?": "string",
      "tooltipValueGetter?": "(params: ITooltipParams) => string",
      "valueGetter?": "((params: ValueGetterParams) => any) | string",
      "filterValueGetter?": "((params: ValueGetterParams) => any) | string",
      "valueSetter?": "((params: ValueSetterParams) => boolean) | string",
      "keyCreator?": "(value: any) => string",
      "width?": "number",
      "initialWidth?": "number",
      "minWidth?": "number",
      "maxWidth?": "number",
      "flex?": "number",
      "initialFlex?": "number",
      "autoHeight?": "boolean",
      "wrapText?": "boolean",
      "cellClass?": "string | string[] | ((cellClassParams: CellClassParams) => string | string[])",
      "cellStyle?": "{} | ((params: CellClassParams) => {})",
      "cellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "cellRendererFramework?": "any",
      "cellRendererParams?": "any",
      "cellRendererSelector?": "CellRendererSelectorFunc",
      "cellEditor?": "{\n    new (): ICellEditorComp;\n} | string",
      "cellEditorFramework?": "any",
      "cellEditorParams?": "any",
      "cellEditorSelector?": "CellEditorSelectorFunc",
      "cellEditorPopup?": "boolean",
      "cellEditorPopupPosition?": "string",
      "pinnedRowCellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "pinnedRowCellRendererFramework?": "any",
      "pinnedRowCellRendererParams?": "any",
      "valueFormatter?": "((params: ValueFormatterParams) => string) | string",
      "pinnedRowValueFormatter?": "((params: ValueFormatterParams) => string) | string",
      "valueParser?": "((params: ValueParserParams) => any) | string",
      "aggFunc?": "string | IAggFunc | null",
      "initialAggFunc?": "string | IAggFunc",
      "allowedAggFuncs?": "string[]",
      "rowGroupIndex?": "number | null",
      "rowGroup?": "boolean",
      "initialRowGroupIndex?": "number",
      "initialRowGroup?": "boolean",
      "showRowGroup?": "string | boolean",
      "pivotIndex?": "number | null",
      "pivot?": "boolean",
      "initialPivotIndex?": "number",
      "initialPivot?": "boolean",
      "comparator?": "(valueA: any, valueB: any, nodeA: RowNode, nodeB: RowNode, isInverted: boolean) => number",
      "equals?": "(valueA: any, valueB: any) => boolean",
      "pivotComparator?": "(valueA: string, valueB: string) => number",
      "checkboxSelection?": "boolean | ((params: CheckboxSelectionCallbackParams) => boolean)",
      "headerCheckboxSelection?": "boolean | ((params: HeaderCheckboxSelectionCallbackParams) => boolean)",
      "headerCheckboxSelectionFilteredOnly?": "boolean",
      "rowDrag?": "boolean | ((params: RowDragCallbackParams) => boolean)",
      "rowDragText?": "((params: IRowDragItem, dragItemCount: number) => string)",
      "dndSource?": "boolean | ((params: DndSourceCallbackParams) => boolean)",
      "dndSourceOnRowDrag?": "((params: {\n    rowNode: RowNode;\n    dragEvent: DragEvent;\n}) => void)",
      "suppressMenu?": "boolean",
      "menuTabs?": "string[]",
      "sortable?": "boolean",
      "suppressMovable?": "boolean",
      "suppressCellFlash?": "boolean",
      "lockPosition?": "boolean",
      "lockVisible?": "boolean",
      "lockPinned?": "boolean",
      "unSortIcon?": "boolean",
      "suppressSizeToFit?": "boolean",
      "resizable?": "boolean",
      "suppressAutoSize?": "boolean",
      "suppressKeyboardEvent?": "(params: SuppressKeyboardEventParams) => boolean",
      "enableRowGroup?": "boolean",
      "enablePivot?": "boolean",
      "enableValue?": "boolean",
      "editable?": "boolean | ((params: EditableCallbackParams) => boolean)",
      "colSpan?": "(params: ColSpanParams) => number",
      "rowSpan?": "(params: RowSpanParams) => number",
      "suppressPaste?": "boolean | ((params: SuppressPasteCallbackParams) => boolean)",
      "suppressNavigable?": "boolean | ((params: SuppressNavigableCallbackParams) => boolean)",
      "getQuickFilterText?": "(params: GetQuickFilterTextParams) => string",
      "newValueHandler?": "(params: NewValueParams) => boolean",
      "singleClickEdit?": "boolean",
      "template?": "string",
      "templateUrl?": "string",
      "cellClassRules?": "{\n    [cssClassName: string]: (Function | string);\n}",
      "onCellValueChanged?": "Function",
      "onCellClicked?": "(event: CellClickedEvent) => void",
      "onCellDoubleClicked?": "(event: CellDoubleClickedEvent) => void",
      "onCellContextMenu?": "(event: CellContextMenuEvent) => void",
      "icons?": "{\n    [key: string]: Function | string;\n}",
      "enableCellChangeFlash?": "boolean",
      "pivotValueColumn?": "Column | null",
      "pivotTotalColumnIds?": "string[]",
      "headerComponent?": "string | {\n    new (): any;\n}",
      "headerComponentFramework?": "any",
      "headerComponentParams?": "any",
      "floatingFilter?": "boolean",
      "refData?": "{\n    [key: string]: string;\n}",
      "chartDataType?": "'category' | 'series' | 'time' | 'excluded'",
      "columnsMenuParams?": "ColumnsMenuParams"
    },
    "docs": {
      "filter?": "One of the built in filter names: [set, number, text], or a filter function",
      "filterParams?": "The filter params are specific to each filter!",
      "floatingFilterComponent?": "The custom component to be used for rendering the floating filter. If none is specified the default AG Grid is used. *",
      "headerName?": "The name to render in the column header",
      "columnGroupShow?": "Whether to show the column when the group is open / closed.",
      "headerClass?": "CSS class for the header",
      "toolPanelClass?": "CSS class for the toolPanel",
      "headerValueGetter?": "Expression or function to get the cells value.",
      "pivotKeys?": "Never set this, it is used internally by grid when doing in-grid pivoting",
      "suppressColumnsToolPanel?": "Set to true to not include this column in the Columns Tool Panel",
      "suppressFiltersToolPanel?": "Set to true to not include this column / filter in the Filters Tool Panel",
      "headerTooltip?": "Tooltip for the column header",
      "suppressHeaderKeyboardEvent?": "Allows the user to suppress certain keyboard events in the grid header",
      "colId?": "The unique ID to give the column. This is optional. If missing, the ID will default to the field.\nIf both field and colId are missing, a unique ID will be generated.\nThis ID is used to identify the column in the API for sorting, filtering etc.",
      "sort?": "If sorting by default, set it here. Set to 'asc' or 'desc'",
      "sortIndex?": "If sorting more than one column by default, specifies order in which the sorting should be applied.",
      "sortingOrder?": "The sort order, provide an array with any of the following in any order ['asc','desc',null]",
      "field?": "The field of the row to get the cells data from",
      "type?": "A comma separated string or array of strings containing ColumnType keys which can be used as a template for a column.\nThis helps to reduce duplication of properties when you have a lot of common column properties.",
      "hide?": "Set to true for this column to be hidden. Naturally you might think, it would make more sense to call this field 'visible' and mark it false to hide,\nhowever we want all default values to be false and we want columns to be visible by default.",
      "pinned?": "Whether this column is pinned or not.",
      "tooltipField?": "The field where we get the tooltip on the object",
      "tooltipValueGetter?": "The function used to calculate the tooltip of the object, tooltipField takes precedence",
      "valueGetter?": "Expression or function to get the cells value.",
      "filterValueGetter?": "Expression or function to get the cells value for filtering.",
      "valueSetter?": "If not using a field, then this puts the value into the cell",
      "keyCreator?": "Function to return the key for a value - use this if the value is an object (not a primitive type) and you\nwant to a) group by this field or b) use set filter on this field.",
      "width?": "Actual width, in pixels, of the cell",
      "initialWidth?": "Default width, in pixels, of the cell",
      "minWidth?": "Min width, in pixels, of the cell",
      "maxWidth?": "Max width, in pixels, of the cell",
      "flex?": "Sets the grow factor of a column. It specifies how much of the remaining\nspace should be assigned to the column.",
      "autoHeight?": "True if this column should stretch rows height to fit contents",
      "wrapText?": "True if this column should wrap cell contents - typically used with autoHeight",
      "cellClass?": "Class to use for the cell. Can be string, array of strings, or function.",
      "cellStyle?": "An object of css values. Or a function returning an object of css values.",
      "cellRenderer?": "A function for rendering a cell.",
      "cellEditor?": "Cell editor",
      "valueFormatter?": "A function to format a value, should return a string. Not used for CSV export or copy to clipboard, only for UI cell rendering.",
      "valueParser?": "Gets called after editing, converts the value in the cell.",
      "aggFunc?": "Name of function to use for aggregation. One of [sum,min,max,first,last] or a function.",
      "allowedAggFuncs?": "Agg funcs allowed on this column. If missing, all installed agg funcs are allowed.\nCan be eg ['sum','avg']. This will restrict what the GUI allows to select only.",
      "rowGroupIndex?": "To group by this column by default, either provide an index (eg rowGroupIndex=1), or set rowGroup=true.",
      "showRowGroup?": "Set to true to have the grid place the values for the group into the cell, or put the name of a grouped column to just show that group.",
      "pivotIndex?": "To pivot by this column by default, either provide an index (eg pivotIndex=1), or set pivot=true.",
      "comparator?": "Comparator function for custom sorting.",
      "equals?": "Comparator for values, used by renderer to know if values have changed. Cells who's values have not changed don't get refreshed.",
      "pivotComparator?": "Comparator for ordering the pivot columns",
      "checkboxSelection?": "Set to true to render a selection checkbox in the column.",
      "headerCheckboxSelection?": "If true, a 'select all' checkbox will be put into the header",
      "headerCheckboxSelectionFilteredOnly?": "If true, the header checkbox selection will work on filtered items",
      "rowDrag?": "For grid row dragging, set to true to enable row dragging within the grid",
      "rowDragText?": "To configure the text to be displayed in the floating div while dragging a row when rowDrag is true",
      "dndSource?": "For native drag and drop, set to true to enable drag source",
      "dndSourceOnRowDrag?": "For native drag and drop, set to true to allow custom onRowDrag processing",
      "suppressMenu?": "Set to true if no menu should be shown for this column header.",
      "menuTabs?": "The menu tabs to show, and in which order, the valid values for this property are:\nfilterMenuTab, generalMenuTab, columnsMenuTab *",
      "sortable?": "Set to true if sorting allowed for this column.",
      "suppressMovable?": "Set to true to not allow moving this column via dragging it's header",
      "suppressCellFlash?": "Set to true to not flash this column for value changes",
      "lockPosition?": "Set to true to make sure this column is always first. Other columns, if movable, cannot move before this column.",
      "lockVisible?": "Set to true to block the user showing / hiding the column, the column can only be shown / hidden via definitions or API",
      "lockPinned?": "Set to true to block the user pinning the column, the column can only be pinned via definitions or API",
      "unSortIcon?": "Set to true if you want the unsorted icon to be shown when no sort is applied to this column.",
      "suppressSizeToFit?": "Set to true if you want this columns width to be fixed during 'size to fit' operation.",
      "resizable?": "Set to true if this column should be resizable",
      "suppressAutoSize?": "Set to true if you do not want this column to be auto-resizable by double clicking it's edge.",
      "suppressKeyboardEvent?": "Allows the user to suppress certain keyboard events in the grid cell",
      "enableRowGroup?": "If true, GUI will allow adding this columns as a row group",
      "enablePivot?": "If true, GUI will allow adding this columns as a pivot",
      "enableValue?": "If true, GUI will allow adding this columns as a value",
      "editable?": "Set to true if this col is editable, otherwise false. Can also be a function to have different rows editable.",
      "suppressPaste?": "Set to true if this col should not be allowed take new values from the clipboard .",
      "suppressNavigable?": "Set to true if this col should not be navigable with the tab key. Can also be a function to have different rows editable.",
      "getQuickFilterText?": "To create the quick filter text for this column, if toString is not good enough on the value.",
      "newValueHandler?": "Callbacks for editing. See editing section for further details.\nReturn true if the update was successful, or false if not.\nIf false, then skips the UI refresh and no events are emitted.\nReturn false if the values are the same (ie no update).",
      "singleClickEdit?": "If true, this cell will be in editing mode after first click.",
      "template?": "Cell template to use for cell. Useful for AngularJS cells.",
      "templateUrl?": "Cell template URL to load template from to use for cell. Useful for AngularJS cells.",
      "cellClassRules?": "Rules for applying css classes",
      "onCellValueChanged?": "Callbacks for editing.See editing section for further details.",
      "onCellClicked?": "Function callback, gets called when a cell is clicked.",
      "onCellDoubleClicked?": "Function callback, gets called when a cell is double clicked.",
      "onCellContextMenu?": "Function callback, gets called when a cell is right clicked.",
      "icons?": "Icons for this column. Leave blank to use default.",
      "enableCellChangeFlash?": "If true, grid will flash cell after cell is refreshed",
      "pivotValueColumn?": "Never set this, it is used internally by grid when doing in-grid pivoting",
      "pivotTotalColumnIds?": "Never set this, it is used internally by grid when doing in-grid pivoting",
      "headerComponent?": "The custom header component to be used for rendering the component header. If none specified the default AG Grid is used*",
      "headerComponentFramework?": "The custom header component to be used for rendering the component header in the hosting framework (ie: React/Angular). If none specified the default AG Grid is used*",
      "headerComponentParams?": "The custom header component parameters*",
      "floatingFilter?": "Whether to display a floating filter for this column.",
      "chartDataType?": "Defines the column data type used when charting",
      "columnsMenuParams?": "Params to customise the columns menu behaviour and appearance"
    }
  },
  "ColumnFunctionCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "CheckboxSelectionCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "RowDragCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "DndSourceCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "EditableCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "SuppressPasteCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "SuppressNavigableCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "HeaderCheckboxSelectionCallbackParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "IsColumnFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "IsColumnFuncParams" },
      "returnType": "boolean"
    }
  },
  "IsColumnFuncParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "GetQuickFilterTextParams": {
    "meta": {},
    "type": {
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any"
    }
  },
  "ColumnsMenuParams": {
    "meta": {},
    "type": {
      "suppressSyncLayoutWithGrid?": "boolean",
      "suppressColumnFilter?": "boolean",
      "suppressColumnSelectAll?": "boolean",
      "suppressColumnExpandAll?": "boolean",
      "contractColumnSelection?": "boolean"
    }
  },
  "BaseColDefParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "BaseWithValueColDefParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "value": "any"
    }
  },
  "ValueGetterParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "getValue": "(field: string) => any"
    }
  },
  "NewValueParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "ValueSetterParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "ValueParserParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "ValueFormatterParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "value": "any"
    }
  },
  "ColSpanParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "RowSpanParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "colDef": "ColDef",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "SuppressKeyboardEventParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "event": "KeyboardEvent",
      "editing": "boolean"
    }
  },
  "SuppressHeaderKeyboardEventParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | ColumnGroup",
      "colDef": "ColDef | ColGroupDef | null",
      "context": "any",
      "headerRowIndex": "number",
      "event": "KeyboardEvent"
    }
  },
  "CellClassParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "colDef": "ColDef",
      "value": "any"
    }
  },
  "SelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellRendererParams | ICellEditorParams" },
      "returnType": "CellRendererSelectorResult | CellEditorSelectorResult"
    }
  },
  "CellRendererSelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellRendererParams" },
      "returnType": "CellRendererSelectorResult"
    }
  },
  "CellEditorSelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellEditorParams" },
      "returnType": "CellEditorSelectorResult"
    }
  },
  "CellRendererSelectorResult": {
    "meta": {},
    "type": {
      "component?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "frameworkComponent?": "any",
      "params?": "any"
    }
  },
  "CellEditorSelectorResult": {
    "meta": {},
    "type": {
      "component?": "{\n    new (): ICellEditorComp;\n} | string",
      "frameworkComponent?": "any",
      "params?": "any"
    }
  },
  "ColumnGroupChild": {
    "meta": {},
    "type": {
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "getUniqueId()": "string",
      "getActualWidth()": "number",
      "getMinWidth()": "number | null | undefined",
      "getLeft()": "number | null",
      "getOldLeft()": "number | null",
      "getDefinition()": "AbstractColDef | null",
      "getColumnGroupShow()": "string | undefined",
      "getParent()": "ColumnGroupChild",
      "isResizable()": "boolean",
      "setParent(parent: ColumnGroup | null)": "void",
      "isEmptyGroup()": "boolean",
      "isMoving()": "boolean",
      "getPinned()": "string | null | undefined"
    }
  },
  "GridOptions": {
    "meta": {},
    "type": {
      "suppressBrowserResizeObserver?": "boolean",
      "rowDragManaged?": "boolean",
      "suppressRowDrag?": "boolean",
      "suppressMoveWhenRowDragging?": "boolean",
      "enableMultiRowDragging?": "boolean",
      "ensureDomOrder?": "boolean",
      "suppressAggFilteredOnly?": "boolean",
      "showOpenedGroup?": "boolean",
      "deltaRowDataMode?": "boolean",
      "deltaColumnMode?": "boolean",
      "applyColumnDefOrder?": "boolean",
      "maintainColumnOrder?": "boolean",
      "immutableData?": "boolean",
      "immutableColumns?": "boolean",
      "scrollbarWidth?": "number",
      "suppressRowClickSelection?": "boolean",
      "suppressRowHoverHighlight?": "boolean",
      "suppressCellSelection?": "boolean",
      "suppressClearOnFillReduction?": "boolean",
      "suppressMaintainUnsortedOrder?": "boolean",
      "sortingOrder?": "(string | null)[]",
      "suppressMultiSort?": "boolean",
      "multiSortKey?": "string",
      "accentedSort?": "boolean",
      "deltaSort?": "boolean",
      "suppressHorizontalScroll?": "boolean",
      "alwaysShowHorizontalScroll?": "boolean",
      "alwaysShowVerticalScroll?": "boolean",
      "debounceVerticalScrollbar?": "boolean",
      "unSortIcon?": "boolean",
      "rowBuffer?": "number",
      "tooltipShowDelay?": "number",
      "tooltipMouseTrack?": "boolean",
      "enableRtl?": "boolean",
      "enableBrowserTooltips?": "boolean",
      "colResizeDefault?": "string",
      "enableCellExpressions?": "boolean",
      "enableCellTextSelection?": "boolean",
      "enableGroupEdit?": "boolean",
      "enterMovesDownAfterEdit?": "boolean",
      "enterMovesDown?": "boolean",
      "suppressMiddleClickScrolls?": "boolean",
      "preventDefaultOnContextMenu?": "boolean",
      "suppressPreventDefaultOnMouseWheel?": "boolean",
      "suppressScrollOnNewData?": "boolean",
      "suppressMenuHide?": "boolean",
      "singleClickEdit?": "boolean",
      "suppressClickEdit?": "boolean",
      "tabIndex?": "number",
      "suppressKeyboardEvent?": "(params: SuppressKeyboardEventParams) => boolean",
      "stopEditingWhenGridLosesFocus?": "boolean",
      "stopEditingWhenCellsLoseFocus?": "boolean",
      "debug?": "boolean",
      "icons?": "{\n    [key: string]: Function | string;\n}",
      "angularCompileRows?": "boolean",
      "angularCompileFilters?": "boolean",
      "suppressLoadingOverlay?": "boolean",
      "suppressNoRowsOverlay?": "boolean",
      "suppressAutoSize?": "boolean",
      "autoSizePadding?": "number",
      "skipHeaderOnAutoSize?": "boolean",
      "animateRows?": "boolean",
      "suppressColumnMoveAnimation?": "boolean",
      "suppressMovableColumns?": "boolean",
      "suppressDragLeaveHidesColumns?": "boolean",
      "suppressMakeColumnVisibleAfterUnGroup?": "boolean",
      "suppressParentsInRowNodes?": "boolean",
      "suppressFieldDotNotation?": "boolean",
      "suppressCopyRowsToClipboard?": "boolean",
      "copyHeadersToClipboard?": "boolean",
      "clipboardDeliminator?": "string",
      "suppressClipboardPaste?": "boolean",
      "suppressClipboardApi?": "boolean",
      "suppressLastEmptyLineOnPaste?": "boolean",
      "suppressAggFuncInHeader?": "boolean",
      "suppressAggAtRootLevel?": "boolean",
      "suppressFocusAfterRefresh?": "boolean",
      "rowModelType?": "string",
      "pivotMode?": "boolean",
      "pivotColumnGroupTotals?": "string",
      "pivotRowTotals?": "string",
      "suppressExpandablePivotGroups?": "boolean",
      "suppressEnterpriseResetOnNewColumns?": "boolean",
      "enableRangeSelection?": "boolean",
      "enableRangeHandle?": "boolean",
      "enableFillHandle?": "boolean",
      "fillHandleDirection?": "string",
      "suppressMultiRangeSelection?": "boolean",
      "rowGroupPanelShow?": "string",
      "pivotPanelShow?": "string",
      "suppressContextMenu?": "boolean",
      "allowContextMenuWithControlKey?": "boolean",
      "rememberGroupStateWhenNewData?": "boolean",
      "suppressModelUpdateAfterUpdateTransaction?": "boolean",
      "viewportRowModelPageSize?": "number",
      "viewportRowModelBufferSize?": "number",
      "enableCellChangeFlash?": "boolean",
      "cellFlashDelay?": "number",
      "cellFadeDelay?": "number",
      "allowShowChangeAfterFilter?": "boolean",
      "quickFilterText?": "string",
      "cacheQuickFilter?": "boolean",
      "aggFuncs?": "{\n    [key: string]: IAggFunc;\n}",
      "suppressColumnVirtualisation?": "boolean",
      "functionsReadOnly?": "boolean",
      "functionsPassive?": "boolean",
      "maxConcurrentDatasourceRequests?": "number",
      "maxBlocksInCache?": "number",
      "purgeClosedRowNodes?": "boolean",
      "domLayout?": "string",
      "suppressChangeDetection?": "boolean",
      "aggregateOnlyChangedColumns?": "boolean",
      "valueCache?": "boolean",
      "valueCacheNeverExpires?": "boolean",
      "batchUpdateWaitMillis?": "number",
      "asyncTransactionWaitMillis?": "number",
      "suppressRowTransform?": "boolean",
      "suppressSetColumnStateEvents?": "boolean",
      "suppressColumnStateEvents?": "boolean",
      "allowDragFromColumnsToolPanel?": "boolean",
      "suppressMaxRenderedRowRestriction?": "boolean",
      "excludeChildrenWhenTreeDataFiltering?": "boolean",
      "undoRedoCellEditing?": "boolean",
      "undoRedoCellEditingLimit?": "number",
      "cacheOverflowSize?": "number",
      "infiniteInitialRowCount?": "number",
      "paginationPageSize?": "number",
      "cacheBlockSize?": "number",
      "blockLoadDebounceMillis?": "number",
      "paginationAutoPageSize?": "boolean",
      "suppressPaginationPanel?": "boolean",
      "pagination?": "boolean",
      "paginateChildRows?": "boolean",
      "editType?": "string",
      "suppressTouch?": "boolean",
      "suppressAsyncEvents?": "boolean",
      "embedFullWidthRows?": "boolean",
      "deprecatedEmbedFullWidthRows?": "boolean",
      "excelStyles?": "ExcelStyle[]",
      "floatingFilter?": "boolean",
      "suppressExcelExport?": "boolean",
      "suppressCsvExport?": "boolean",
      "colWidth?": "number",
      "minColWidth?": "number",
      "maxColWidth?": "number",
      "suppressPropertyNamesCheck?": "boolean",
      "serverSideSortingAlwaysResets?": "boolean",
      "serverSideFilteringAlwaysResets?": "boolean",
      "serverSideStoreType?": "ServerSideStoreType",
      "getServerSideStoreParams?": "(params: GetServerSideStoreParamsParams) => ServerSideStoreParams",
      "isServerSideGroupOpenByDefault?": "(params: IsServerSideGroupOpenByDefaultParams) => boolean",
      "isGroupOpenByDefault?": "(params: IsGroupOpenByDefaultParams) => boolean",
      "statusBar?": "{\n    statusPanels: StatusPanelDef[];\n}",
      "localeText?": "{\n    [key: string]: string;\n}",
      "localeTextFunc?": "(key: string, defaultValue: string) => string",
      "suppressAnimationFrame?": "boolean",
      "defaultColGroupDef?": "Partial<ColGroupDef>",
      "defaultColDef?": "ColDef",
      "defaultExportParams?": "CsvExportParams | ExcelExportParams",
      "defaultCsvExportParams?": "CsvExportParams",
      "defaultExcelExportParams?": "ExcelExportParams",
      "pivotSuppressAutoColumn?": "boolean",
      "groupSelectsChildren?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "groupIncludeFooter?": "boolean",
      "groupIncludeTotalFooter?": "boolean",
      "groupRemoveSingleChildren?": "boolean",
      "groupRemoveLowestSingleChildren?": "boolean",
      "groupHideOpenParents?": "boolean",
      "groupSuppressBlankHeader?": "boolean",
      "autoGroupColumnDef?": "ColDef",
      "enableOldSetFilterModel?": "boolean",
      "enableCharts?": "boolean",
      "groupDisplayType?": "RowGroupingDisplayType",
      "groupMultiAutoColumn?": "boolean",
      "groupUseEntireRow?": "boolean",
      "groupSuppressAutoColumn?": "boolean",
      "context?": "any",
      "rowStyle?": "{\n    [cssProperty: string]: string;\n}",
      "rowClass?": "string | string[]",
      "groupDefaultExpanded?": "number",
      "alignedGrids?": "GridOptions[]",
      "rowSelection?": "string",
      "suppressRowDeselection?": "boolean",
      "rowDeselection?": "boolean",
      "rowMultiSelectWithClick?": "boolean",
      "isRowSelectable?": "IsRowSelectable",
      "overlayLoadingTemplate?": "string",
      "overlayNoRowsTemplate?": "string",
      "rowHeight?": "number",
      "detailRowHeight?": "number",
      "popupParent?": "HTMLElement",
      "masterDetail?": "boolean",
      "keepDetailRows?": "boolean",
      "keepDetailRowsCount?": "number",
      "isRowMaster?": "IsRowMaster",
      "detailCellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "detailCellRendererFramework?": "any",
      "detailCellRendererParams?": "any",
      "detailRowAutoHeight?": "boolean",
      "rowData?": "any[]",
      "pinnedTopRowData?": "any[]",
      "pinnedBottomRowData?": "any[]",
      "sideBar?": "SideBarDef | string | boolean | null",
      "columnDefs?": "(ColDef | ColGroupDef)[]",
      "columnTypes?": "{\n    [key: string]: ColDef;\n}",
      "datasource?": "IDatasource",
      "viewportDatasource?": "IViewportDatasource",
      "serverSideDatasource?": "IServerSideDatasource",
      "headerHeight?": "number",
      "pivotHeaderHeight?": "number",
      "groupHeaderHeight?": "number",
      "pivotGroupHeaderHeight?": "number",
      "floatingFiltersHeight?": "number",
      "paginationNumberFormatter?": "(params: PaginationNumberFormatterParams) => string",
      "postProcessPopup?": "(params: PostProcessPopupParams) => void",
      "frameworkComponents?": "{\n    [p: string]: {\n        new (): any;\n    };\n} | any",
      "components?": "{\n    [p: string]: any;\n}",
      "groupRowRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "groupRowRendererFramework?": "any",
      "groupRowRendererParams?": "any",
      "groupRowInnerRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "groupRowInnerRendererFramework?": "any",
      "createChartContainer?": "(params: ChartRef) => void",
      "fillOperation?": "(params: FillOperationParams) => any",
      "isExternalFilterPresent?()": "boolean",
      "doesExternalFilterPass?(node: RowNode)": "boolean",
      "getRowStyle?": "(params: RowClassParams) => {\n    [cssProperty: string]: string;\n}",
      "getRowClass?": "(params: RowClassParams) => string | string[] | undefined",
      "rowClassRules?": "{\n    [cssClassName: string]: (((params: RowClassParams) => boolean) | string);\n}",
      "getRowHeight?": "(params: RowHeightParams) => number | undefined | null",
      "sendToClipboard?": "(params: SendToClipboardParams) => void",
      "processDataFromClipboard?": "(params: ProcessDataFromClipboardParams) => string[][] | null",
      "navigateToNextHeader?": "(params: NavigateToNextHeaderParams) => HeaderPosition",
      "tabToNextHeader?": "(params: TabToNextHeaderParams) => HeaderPosition",
      "navigateToNextCell?": "(params: NavigateToNextCellParams) => CellPosition",
      "tabToNextCell?": "(params: TabToNextCellParams) => CellPosition",
      "getDocument?": "() => Document",
      "defaultGroupSortComparator?": "(nodeA: RowNode, nodeB: RowNode) => number",
      "defaultGroupOrderComparator?": "(nodeA: RowNode, nodeB: RowNode) => number",
      "loadingCellRenderer?": "{\n    new (): ICellRenderer;\n} | string",
      "loadingCellRendererFramework?": "any",
      "loadingCellRendererParams?": "any",
      "loadingOverlayComponent?": "{\n    new (): ILoadingOverlayComp;\n} | string",
      "loadingOverlayComponentFramework?": "any",
      "loadingOverlayComponentParams?": "any",
      "noRowsOverlayComponent?": "{\n    new (): INoRowsOverlayComp;\n} | string",
      "noRowsOverlayComponentFramework?": "any",
      "noRowsOverlayComponentParams?": "any",
      "fullWidthCellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "fullWidthCellRendererFramework?": "any",
      "fullWidthCellRendererParams?": "any",
      "isFullWidthCell?(rowNode: RowNode)": "boolean",
      "groupRowAggNodes?(nodes: RowNode[])": "any",
      "getBusinessKeyForNode?(node: RowNode)": "string",
      "getDataPath?": "GetDataPath",
      "treeData?": "boolean",
      "treeDataDisplayType?": "TreeDataDisplayType",
      "isServerSideGroup?": "IsServerSideGroup",
      "isApplyServerSideTransaction?": "IsApplyServerSideTransaction",
      "getServerSideGroupKey?": "GetServerSideGroupKey",
      "getContextMenuItems?": "GetContextMenuItems",
      "getMainMenuItems?": "GetMainMenuItems",
      "getChartToolbarItems?": "GetChartToolbarItems",
      "getRowNodeId?": "GetRowNodeIdFunc",
      "getChildCount?(dataItem: any)": "number",
      "processRowPostCreate?(params: ProcessRowParams)": "void",
      "processCellForClipboard?(params: ProcessCellForExportParams)": "any",
      "processHeaderForClipboard?(params: ProcessHeaderForExportParams)": "any",
      "processCellFromClipboard?(params: ProcessCellForExportParams)": "any",
      "processSecondaryColDef?(colDef: ColDef)": "void",
      "processSecondaryColGroupDef?(colGroupDef: ColGroupDef)": "void",
      "postSort?(nodes: RowNode[])": "void",
      "chartThemes?": "string[]",
      "customChartThemes?": "{\n    [name: string]: AgChartTheme;\n}",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "processChartOptions?(params: ProcessChartOptionsParams)": "ChartOptions<any>",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent)": "void",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent)": "void",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent)": "void",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent)": "void",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent)": "void",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent)": "void",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent)": "void",
      "onColumnValueChanged?(event: ColumnValueChangedEvent)": "void",
      "onColumnMoved?(event: ColumnMovedEvent)": "void",
      "onColumnVisible?(event: ColumnVisibleEvent)": "void",
      "onColumnPinned?(event: ColumnPinnedEvent)": "void",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent)": "void",
      "onColumnResized?(event: ColumnResizedEvent)": "void",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent)": "void",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent)": "void",
      "onRowGroupOpened?(event: RowGroupOpenedEvent)": "void",
      "onRowDataChanged?(event: RowDataChangedEvent)": "void",
      "onRowDataUpdated?(event: RowDataUpdatedEvent)": "void",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent)": "void",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent)": "void",
      "onColumnRowGroupChangeRequest?(event: ColumnRowGroupChangeRequestEvent)": "void",
      "onColumnPivotChangeRequest?(event: ColumnPivotChangeRequestEvent)": "void",
      "onColumnValueChangeRequest?(event: ColumnValueChangeRequestEvent)": "void",
      "onColumnAggFuncChangeRequest?(event: ColumnAggFuncChangeRequestEvent)": "void",
      "onModelUpdated?(event: ModelUpdatedEvent)": "void",
      "onCellKeyDown?(event: CellKeyDownEvent | FullWidthCellKeyDownEvent)": "void",
      "onCellKeyPress?(event: CellKeyPressEvent | FullWidthCellKeyPressEvent)": "void",
      "onCellClicked?(event: CellClickedEvent)": "void",
      "onCellMouseDown?(event: CellMouseDownEvent)": "void",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent)": "void",
      "onCellContextMenu?(event: CellContextMenuEvent)": "void",
      "onCellValueChanged?(event: CellValueChangedEvent)": "void",
      "onCellMouseOver?(event: CellMouseOverEvent)": "void",
      "onCellMouseOut?(event: CellMouseOutEvent)": "void",
      "onRowValueChanged?(event: RowValueChangedEvent)": "void",
      "onRowEditingStarted?(event: RowEditingStartedEvent)": "void",
      "onRowEditingStopped?(event: RowEditingStoppedEvent)": "void",
      "onCellEditingStarted?(event: CellEditingStartedEvent)": "void",
      "onCellEditingStopped?(event: CellEditingStoppedEvent)": "void",
      "onCellFocused?(event: CellFocusedEvent)": "void",
      "onRowSelected?(event: RowSelectedEvent)": "void",
      "onSelectionChanged?(event: SelectionChangedEvent)": "void",
      "onFilterOpened?(event: FilterOpenedEvent)": "void",
      "onFilterChanged?(event: FilterChangedEvent)": "void",
      "onFilterModified?(event: FilterModifiedEvent)": "void",
      "onSortChanged?(event: SortChangedEvent)": "void",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent)": "void",
      "onRowClicked?(event: RowClickedEvent)": "void",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent)": "void",
      "onGridReady?(event: GridReadyEvent)": "void",
      "onViewportChanged?(event: ViewportChangedEvent)": "void",
      "onDragStarted?(event: DragStartedEvent)": "void",
      "onDragStopped?(event: DragStoppedEvent)": "void",
      "onPaginationChanged?(event: PaginationChangedEvent)": "void",
      "onRowDragEnter?(event: RowDragEvent)": "void",
      "onRowDragMove?(event: RowDragEvent)": "void",
      "onRowDragLeave?(event: RowDragEvent)": "void",
      "onRowDragEnd?(event: RowDragEvent)": "void",
      "onPasteStart?(event: PasteStartEvent)": "void",
      "onPasteEnd?(event: PasteEndEvent)": "void",
      "onFillStart?(event: FillStartEvent)": "void",
      "onFillEnd?(event: FillEndEvent)": "void",
      "onBodyScroll?(event: BodyScrollEvent)": "void",
      "onFirstDataRendered?(event: FirstDataRenderedEvent)": "void",
      "onExpandOrCollapseAll?(event: ExpandCollapseAllEvent)": "void",
      "onChartCreated?(event: ChartCreated)": "void",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChanged)": "void",
      "onChartOptionsChanged?(event: ChartOptionsChanged)": "void",
      "onChartDestroyed?(event: ChartDestroyed)": "void",
      "onComponentStateChanged?(event: ComponentStateChangedEvent)": "void",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed)": "void",
      "onGridSizeChanged?(event: GridSizeChangedEvent)": "void",
      "api?": "GridApi | null",
      "columnApi?": "ColumnApi | null"
    },
    "docs": {
      "suppressBrowserResizeObserver?": "Set once in init, can never change",
      "suppressKeyboardEvent?": "Allows user to suppress certain keyboard events",
      "paginationNumberFormatter?": "****************************************************************************************************\nIf you change the callbacks on this interface, you must also update PropertyKeys to be consistent. *\n****************************************************************************************************"
    }
  },
  "RowGroupingDisplayType": {
    "meta": { "isEnum": true },
    "type": [
      "SINGLE_COLUMN = 'singleColumn'",
      "MULTIPLE_COLUMNS = 'multipleColumns'",
      "GROUP_ROWS = 'groupRows'",
      "CUSTOM = 'custom'"
    ]
  },
  "TreeDataDisplayType": {
    "meta": { "isEnum": true },
    "type": ["AUTO = 'auto'", "CUSTOM = 'custom'"]
  },
  "FillOperationParams": {
    "meta": {},
    "type": {
      "event": "MouseEvent",
      "values": "any[]",
      "initialValues": "any[]",
      "currentIndex": "number",
      "currentCellValue": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "direction": "string",
      "column?": "Column",
      "rowNode?": "RowNode"
    }
  },
  "GetDataPath": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "data": "any" }, "returnType": "string[]" }
  },
  "IsServerSideGroup": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "boolean" }
  },
  "IsApplyServerSideTransaction": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "IsApplyServerSideTransactionParams" },
      "returnType": "boolean"
    }
  },
  "IsApplyServerSideTransactionParams": {
    "meta": {},
    "type": {
      "transaction": "ServerSideTransaction",
      "parentNode": "RowNode",
      "storeInfo": "any"
    }
  },
  "GetServerSideGroupKey": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "string" }
  },
  "IsRowMaster": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "boolean" }
  },
  "IsRowSelectable": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "node": "RowNode" }, "returnType": "boolean" }
  },
  "RowClassParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "RowHeightParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "api": "GridApi",
      "context": "any"
    }
  },
  "SendToClipboardParams": { "meta": {}, "type": { "data": "string" } },
  "ProcessChartOptionsParams": {
    "meta": {},
    "type": { "type": "ChartType", "options": "ChartOptions<any>" }
  },
  "ProcessChartParams": {
    "meta": {},
    "type": { "type": "ChartType", "options": "AgChartOptions", "chart": "any" }
  },
  "GetContextMenuItemsParams": {
    "meta": {},
    "type": {
      "defaultItems": "string[] | undefined",
      "column": "Column",
      "node": "RowNode",
      "value": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "GetContextMenuItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetContextMenuItemsParams" },
      "returnType": "(string | MenuItemDef)[]"
    }
  },
  "GetChartToolbarItemsParams": {
    "meta": {},
    "type": {
      "defaultItems?": "ChartMenuOptions[]",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "GetChartToolbarItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetChartToolbarItemsParams" },
      "returnType": "ChartMenuOptions[]"
    }
  },
  "MenuItemDef": {
    "meta": {},
    "type": {
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "() => void",
      "checked?": "boolean",
      "icon?": "HTMLElement | string",
      "subMenu?": "(MenuItemDef | string)[] | IComponent<any>",
      "cssClasses?": "string[]",
      "tooltip?": "string"
    }
  },
  "GetMainMenuItemsParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "defaultItems": "string[]"
    }
  },
  "GetMainMenuItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetMainMenuItemsParams" },
      "returnType": "(string | MenuItemDef)[]"
    }
  },
  "GetRowNodeIdFunc": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "data": "any" }, "returnType": "string" }
  },
  "ProcessRowParams": {
    "meta": {},
    "type": {
      "eRow": "HTMLElement",
      "ePinnedLeftRow": "HTMLElement",
      "ePinnedRightRow": "HTMLElement",
      "rowIndex": "number",
      "node": "RowNode",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "addRenderedRowListener": "(eventType: string, listener: Function) => void",
      "context": "any"
    }
  },
  "NavigateToNextHeaderParams": {
    "meta": {},
    "type": {
      "key": "string",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "event": "KeyboardEvent",
      "headerRowCount": "number"
    }
  },
  "TabToNextHeaderParams": {
    "meta": {},
    "type": {
      "backwards": "boolean",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "headerRowCount": "number"
    }
  },
  "NavigateToNextCellParams": {
    "meta": {},
    "type": {
      "key": "number",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition | null",
      "event": "KeyboardEvent | null"
    }
  },
  "TabToNextCellParams": {
    "meta": {},
    "type": {
      "backwards": "boolean",
      "editing": "boolean",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition"
    }
  },
  "PostProcessPopupParams": {
    "meta": {},
    "type": {
      "column?": "Column | null",
      "rowNode?": "RowNode",
      "ePopup": "HTMLElement",
      "type": "string",
      "eventSource?": "HTMLElement | null",
      "mouseEvent?": "MouseEvent | Touch | null"
    }
  },
  "PaginationNumberFormatterParams": {
    "meta": {},
    "type": { "value": "number" }
  },
  "ProcessDataFromClipboardParams": {
    "meta": {},
    "type": { "data": "string[][]" }
  },
  "ChartRef": {
    "meta": {},
    "type": {
      "chartId": "string",
      "chart": "any",
      "chartElement": "HTMLElement",
      "destroyChart": "() => void"
    }
  },
  "ServerSideStoreType": {
    "meta": { "isEnum": true },
    "type": ["Full = 'full'", "Partial = 'partial'"]
  },
  "ServerSideStoreParams": {
    "meta": {},
    "type": {
      "storeType?": "ServerSideStoreType",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    }
  },
  "GetServerSideStoreParamsParams": {
    "meta": {},
    "type": {
      "level": "number",
      "parentRowNode?": "RowNode",
      "rowGroupColumns": "Column[]",
      "pivotColumns": "Column[]",
      "pivotMode": "boolean"
    }
  },
  "IsServerSideGroupOpenByDefaultParams": {
    "meta": {},
    "type": { "data": "any", "rowNode": "RowNode" }
  },
  "IsGroupOpenByDefaultParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowGroupColumn": "Column",
      "level": "number",
      "field": "string",
      "key": "string"
    }
  },
  "OriginalColumnGroupChild": {
    "meta": {},
    "type": {
      "isVisible()": "boolean",
      "getColumnGroupShow()": "string | undefined",
      "getId()": "string",
      "setOriginalParent(originalParent: OriginalColumnGroup | null)": "void"
    }
  },
  "SetSelectedParams": {
    "meta": {},
    "type": {
      "newValue": "boolean",
      "clearSelection?": "boolean",
      "suppressFinishActions?": "boolean",
      "rangeSelect?": "boolean",
      "groupSelectsFiltered?": "boolean"
    }
  },
  "RowNodeEvent": {
    "meta": {},
    "type": { "type": "string", "node": "RowNode" },
    "docs": { "type": "Event identifier" }
  },
  "DataChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "oldData": "any",
      "newData": "any",
      "update": "boolean"
    },
    "docs": { "type": "Event identifier" }
  },
  "CellChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "column": "Column",
      "newValue": "any",
      "oldValue": "any"
    },
    "docs": { "type": "Event identifier" }
  },
  "RowHighlightPosition": {
    "meta": { "isEnum": true },
    "type": ["Above", "Below"]
  },
  "RowPosition": {
    "meta": {},
    "type": { "rowIndex": "number", "rowPinned?": "string | null" }
  },
  "ToolPanelDef": {
    "meta": {},
    "type": {
      "id": "string",
      "labelDefault": "string",
      "labelKey": "string",
      "minWidth?": "number",
      "maxWidth?": "number",
      "width?": "number",
      "iconKey": "string",
      "toolPanel?": "{\n    new (): IToolPanelComp;\n} | string",
      "toolPanelFramework?": "any",
      "toolPanelParams?": "any"
    }
  },
  "SideBarDef": {
    "meta": {},
    "type": {
      "toolPanels?": "(ToolPanelDef | string)[]",
      "defaultToolPanel?": "string",
      "hiddenByDefault?": "boolean",
      "position?": "'left' | 'right'"
    }
  },
  "SASS_PROPERTIES": {
    "meta": { "isTypeAlias": true },
    "type": "'headerHeight' | 'headerCellMinWidth' | 'listItemHeight' | 'rowHeight' | 'chartMenuPanelWidth'"
  },
  "HardCodedSize": {
    "meta": {},
    "type": { "[key: string]": "{[key in SASS_PROPERTIES]?: number}" }
  },
  "ModelUpdatedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "animate": "boolean | undefined",
      "keepRenderedRows": "boolean | undefined",
      "newData": "boolean | undefined",
      "newPage": "boolean"
    },
    "docs": {
      "type": "Event identifier",
      "animate": "If true, the grid will try and animate the rows to the new positions",
      "keepRenderedRows": "If true, the grid has new data loaded, eg user called setRowData(), otherwise\nit's the same data but sorted or filtered, in which case this is true, and rows\ncan animate around (eg rowNode id 24 is the same row node as last time).",
      "newData": "If true, then this update was a result of setRowData() getting called. This\ngets the grid to scroll to the top again.",
      "newPage": "True when pagination and a new page is navigated to."
    }
  },
  "PaginationChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "animate?": "boolean",
      "keepRenderedRows?": "boolean",
      "newData?": "boolean",
      "newPage": "boolean"
    },
    "docs": {
      "type": "Event identifier",
      "animate?": "True if rows were animated to new position",
      "keepRenderedRows?": "True if rows were kept (otherwise complete redraw)",
      "newData?": "True if data was new (i.e user set new data)",
      "newPage": "True if user went to a new page"
    }
  },
  "AgEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "Event identifier" }
  },
  "AgGridEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "ToolPanelVisibleChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string | undefined"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnPivotModeChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "VirtualColumnsChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "ColumnEverythingChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "Event identifier" }
  },
  "NewColumnsLoadedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "GridColumnsChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "DisplayedColumnsChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "RowDataChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "RowDataUpdatedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "PinnedRowDataChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "SelectionChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "FilterChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "afterDataChange?": "boolean",
      "afterFloatingFilter?": "boolean"
    },
    "docs": {
      "type": "Event identifier",
      "afterDataChange?": "True if the filter was changed as a result of data changing",
      "afterFloatingFilter?": "True if filter was changed via floating filter"
    }
  },
  "FilterModifiedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "filterInstance": "IFilterComp",
      "column": "Column"
    },
    "docs": { "type": "Event identifier" }
  },
  "FilterOpenedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | OriginalColumnGroup",
      "source": "FilterRequestSource",
      "eGui": "HTMLElement"
    },
    "docs": {
      "type": "Event identifier",
      "column": "Column / OriginalColumnGroup that contains the filter",
      "source": "Source of the open request",
      "eGui": "Parent element of the filter"
    }
  },
  "SortChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "GridReadyEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "DisplayedColumnsWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "ColumnHoverChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "BodyHeightChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "ComponentStateChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "DragEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "target": "HTMLElement"
    },
    "docs": {
      "type": "One of {'cell','row','headerCell','toolPanel'}",
      "target": "The DOM element that started the event."
    }
  },
  "DragStartedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "target": "HTMLElement"
    },
    "docs": {
      "type": "One of {'cell','row','headerCell','toolPanel'}",
      "target": "The DOM element that started the event."
    }
  },
  "DragStoppedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "target": "HTMLElement"
    },
    "docs": {
      "type": "One of {'cell','row','headerCell','toolPanel'}",
      "target": "The DOM element that started the event."
    }
  },
  "CheckboxChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "id": "string",
      "name": "string",
      "selected?": "boolean",
      "previousValue": "boolean | undefined"
    },
    "docs": { "type": "Event identifier" }
  },
  "GridSizeChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "clientWidth": "number",
      "clientHeight": "number"
    },
    "docs": {
      "type": "Event identifier",
      "clientWidth": "The grid's DIV's clientWidth",
      "clientHeight": "The grid's DIV's clientHeight"
    }
  },
  "RowDragEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "Event identifier",
      "node": "The row node getting dragged. Also the node that started the drag when multi-row dragging.",
      "nodes": "The list of nodes being dragged.",
      "y": "The vertical pixel location the mouse is over.",
      "vDirection": "Direction of the drag, either 'up', 'down' or null.",
      "event": "The underlying mouse move event associated with the drag.",
      "overIndex": "The row index the mouse is dragging over.",
      "overNode": "The row node the mouse is dragging over."
    }
  },
  "RowDragEnterEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "Event identifier",
      "node": "The row node getting dragged. Also the node that started the drag when multi-row dragging.",
      "nodes": "The list of nodes being dragged.",
      "y": "The vertical pixel location the mouse is over.",
      "vDirection": "Direction of the drag, either 'up', 'down' or null.",
      "event": "The underlying mouse move event associated with the drag.",
      "overIndex": "The row index the mouse is dragging over.",
      "overNode": "The row node the mouse is dragging over."
    }
  },
  "RowDragEndEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "Event identifier",
      "node": "The row node getting dragged. Also the node that started the drag when multi-row dragging.",
      "nodes": "The list of nodes being dragged.",
      "y": "The vertical pixel location the mouse is over.",
      "vDirection": "Direction of the drag, either 'up', 'down' or null.",
      "event": "The underlying mouse move event associated with the drag.",
      "overIndex": "The row index the mouse is dragging over.",
      "overNode": "The row node the mouse is dragging over."
    }
  },
  "RowDragMoveEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "Event identifier",
      "node": "The row node getting dragged. Also the node that started the drag when multi-row dragging.",
      "nodes": "The list of nodes being dragged.",
      "y": "The vertical pixel location the mouse is over.",
      "vDirection": "Direction of the drag, either 'up', 'down' or null.",
      "event": "The underlying mouse move event associated with the drag.",
      "overIndex": "The row index the mouse is dragging over.",
      "overNode": "The row node the mouse is dragging over."
    }
  },
  "RowDragLeaveEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "y": "number",
      "vDirection": "string",
      "event": "MouseEvent",
      "overIndex": "number",
      "overNode": "RowNode"
    },
    "docs": {
      "type": "Event identifier",
      "node": "The row node getting dragged. Also the node that started the drag when multi-row dragging.",
      "nodes": "The list of nodes being dragged.",
      "y": "The vertical pixel location the mouse is over.",
      "vDirection": "Direction of the drag, either 'up', 'down' or null.",
      "event": "The underlying mouse move event associated with the drag.",
      "overIndex": "The row index the mouse is dragging over.",
      "overNode": "The row node the mouse is dragging over."
    }
  },
  "PasteStartEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "Event identifier" }
  },
  "PasteEndEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "Event identifier" }
  },
  "FillStartEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "FillEndEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "initialRange": "CellRange",
      "finalRange": "CellRange"
    },
    "docs": { "type": "Event identifier" }
  },
  "ViewportChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "firstRow": "number",
      "lastRow": "number"
    },
    "docs": {
      "type": "Event identifier",
      "firstRow": "Index of the first rendered row",
      "lastRow": "Index of the last rendered row"
    }
  },
  "FirstDataRenderedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "firstRow": "number",
      "lastRow": "number"
    },
    "docs": {
      "type": "Event identifier",
      "firstRow": "Index of the first rendered row",
      "lastRow": "Index of the last rendered row"
    }
  },
  "RangeSelectionChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "id?": "string",
      "finished": "boolean",
      "started": "boolean"
    },
    "docs": { "type": "Event identifier" }
  },
  "ChartCreated": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "chartId": "string"
    },
    "docs": { "type": "Event identifier" }
  },
  "ChartRangeSelectionChanged": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "id": "string",
      "chartId": "string",
      "cellRange": "CellRangeParams"
    },
    "docs": { "type": "Event identifier" }
  },
  "ChartOptionsChanged": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "chartId": "string",
      "chartType": "ChartType",
      "chartThemeName": "string",
      "chartOptions": "ChartOptions<any>"
    },
    "docs": { "type": "Event identifier" }
  },
  "ChartDestroyed": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "chartId": "string"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnGroupOpenedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columnGroup": "OriginalColumnGroup"
    },
    "docs": { "type": "Event identifier" }
  },
  "ItemsAddedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "items": "RowNode[]"
    },
    "docs": { "type": "Event identifier" }
  },
  "ScrollDirection": {
    "meta": { "isTypeAlias": true },
    "type": "'horizontal' | 'vertical'"
  },
  "BodyScrollEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "direction": "ScrollDirection",
      "left": "number",
      "top": "number"
    },
    "docs": { "type": "Event identifier" }
  },
  "FlashCellsEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cells": "any"
    },
    "docs": { "type": "Event identifier" }
  },
  "PaginationPixelOffsetChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "CellFocusedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "rowIndex": "number | null",
      "column": "Column | null",
      "rowPinned?": "string | null",
      "isFullWidthCell": "boolean",
      "forceBrowserFocus?": "boolean",
      "floating": "string | null"
    },
    "docs": {
      "type": "Event identifier",
      "rowIndex": "Row index of the focused cell",
      "column": "Column of the focused cell",
      "rowPinned?": "either 'top', 'bottom' or null / undefined (if not pinned)",
      "isFullWidthCell": "Whether the cell a full width cell or a regular cell",
      "forceBrowserFocus?": "Whether browser focus is also set (false when editing)"
    }
  },
  "ExpandCollapseAllEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "source": "string"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnEventType": {
    "meta": { "isTypeAlias": true },
    "type": "\"sizeColumnsToFit\" | \"autosizeColumns\" | \"alignedGridChanged\" | \"filterChanged\" | \"filterDestroyed\" | \"gridOptionsChanged\" | \"gridInitializing\" | \"toolPanelDragAndDrop\" | \"toolPanelUi\" | \"uiColumnMoved\" | \"uiColumnResized\" | \"uiColumnDragged\" | \"uiColumnExpanded\" | \"uiColumnSorted\" | \"contextMenu\" | \"columnMenu\" | \"rowModelUpdated\" | \"api\" | \"flex\" | \"pivotChart\""
  },
  "ColumnEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from"
    }
  },
  "ColumnResizedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "finished": "boolean",
      "flexColumns": "Column[] | null"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from",
      "finished": "Set to true for last event in a sequence of move events",
      "flexColumns": "Any columns resized due to flex"
    }
  },
  "ColumnPivotChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from"
    }
  },
  "ColumnRowGroupChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from"
    }
  },
  "ColumnValueChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from"
    }
  },
  "ColumnMovedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "toIndex?": "number"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from",
      "toIndex?": "The position the column was moved to"
    }
  },
  "ColumnVisibleEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "visible?": "boolean"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from",
      "visible?": "True if column was set to visible, false if set to hide"
    }
  },
  "ColumnPinnedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "pinned": "string | null"
    },
    "docs": {
      "type": "Event identifier",
      "column": "The impacted column, only set if action was on one column",
      "columns": "List of all impacted columns",
      "source": "String describing where the event is coming from",
      "pinned": "Either 'left', 'right', or null (it not pinned)"
    }
  },
  "RowEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "RowGroupOpenedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "expanded": "boolean"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "expanded": "True if the group is expanded."
    }
  },
  "RowValueChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "RowSelectedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "VirtualRowRemovedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "RowClickedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "RowDoubleClickedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "RowEditingStartedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "RowEditingStoppedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "FullWidthCellKeyDownEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "FullWidthCellKeyPressEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event"
    }
  },
  "CellEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellKeyDownEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellKeyPressEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellClickedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellMouseDownEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellDoubleClickedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellMouseOverEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellMouseOutEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellContextMenuEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellEditingStartedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "CellEditingStoppedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "oldValue": "any",
      "newValue": "any"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell",
      "oldValue": "The old value before editing",
      "newValue": "The new value after editing"
    }
  },
  "CellValueChangedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned?": "string | null",
      "context": "any",
      "event?": "Event | null",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "oldValue": "any",
      "newValue": "any",
      "source": "string | undefined"
    },
    "docs": {
      "type": "Event identifier",
      "data": "The user provided data for the row",
      "rowIndex": "The visible row index for the row",
      "rowPinned?": "Either 'top', 'bottom' or null / undefined (if not set)",
      "context": "Bag of attributes, provided by user",
      "event?": "If event was due to browser event (eg click), this is the browser event",
      "value": "The value for the cell"
    }
  },
  "AsyncTransactionsFlushed": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "results": "(RowNodeTransaction | ServerSideTransactionResult)[]"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnRowGroupChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnPivotChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnValueChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]"
    },
    "docs": { "type": "Event identifier" }
  },
  "ColumnAggFuncChangeRequestEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "columns": "Column[]",
      "aggFunc": "any"
    },
    "docs": { "type": "Event identifier" }
  },
  "ScrollVisibilityChangedEvent": {
    "meta": {},
    "type": { "type": "string", "api": "GridApi", "columnApi": "ColumnApi" },
    "docs": { "type": "Event identifier" }
  },
  "StoreUpdatedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "Event identifier" }
  },
  "LeftPinnedWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "Event identifier" }
  },
  "RightPinnedWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "Event identifier" }
  },
  "RowContainerHeightChanged": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "Event identifier" }
  },
  "DisplayedRowsChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "Event identifier" }
  },
  "IFilterLocaleText": {
    "meta": {},
    "type": {
      "applyFilter": "string",
      "clearFilter": "string",
      "resetFilter": "string",
      "cancelFilter": "string",
      "filterOoo": "string",
      "empty": "string",
      "equals": "string",
      "notEqual": "string",
      "lessThan": "string",
      "greaterThan": "string",
      "inRange": "string",
      "inRangeStart": "string",
      "inRangeEnd": "string",
      "lessThanOrEqual": "string",
      "greaterThanOrEqual": "string",
      "contains": "string",
      "notContains": "string",
      "startsWith": "string",
      "endsWith": "string",
      "andCondition": "string",
      "orCondition": "string",
      "dateFormatOoo": "string"
    }
  },
  "IFilterTitleLocaleText": {
    "meta": {},
    "type": {
      "textFilter": "string",
      "numberFilter": "string",
      "dateFilter": "string",
      "setFilter": "string"
    }
  },
  "FilterRequestSource": {
    "meta": { "isTypeAlias": true },
    "type": "'COLUMN_MENU' | 'TOOLBAR' | 'NO_UI'"
  },
  "FilterWrapper": {
    "meta": {},
    "type": {
      "compiledElement": "any",
      "column": "Column",
      "filterPromise": "AgPromise<IFilterComp> | null",
      "scope": "any",
      "guiPromise": "AgPromise<HTMLElement | null>"
    }
  },
  "IFloatingFilterParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "filterParams": "IFilterParams",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: (filterInstance: IFilterComp) => void) => void",
      "showParentFilter": "() => void",
      "suppressFilterButton": "boolean",
      "api": "GridApi",
      "onFloatingFilterChanged": "(change: any) => boolean"
    }
  },
  "IFloatingFilter": {
    "meta": {},
    "type": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void"
    }
  },
  "IFloatingFilterComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "BaseFloatingFilterChange": {
    "meta": {},
    "type": { "model": "ProvidedFilterModel", "apply": "boolean" }
  },
  "DateFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "string",
      "type?": "string | null",
      "dateFrom": "string | null",
      "dateTo": "string | null"
    }
  },
  "IDateFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator",
      "comparator?": "IDateComparatorFunc",
      "browserDatePicker?": "boolean",
      "minValidYear?": "number"
    }
  },
  "IDateComparatorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "filterLocalDateAtMidnight": "Date", "cellValue": "any" },
      "returnType": "number"
    }
  },
  "NumberFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "string",
      "type?": "string | null",
      "filter?": "number | null",
      "filterTo?": "number | null"
    }
  },
  "INumberFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator",
      "allowedCharPattern?": "string",
      "numberParser?": "(text: string | null) => number"
    }
  },
  "FilterButtonType": {
    "meta": { "isTypeAlias": true },
    "type": "'apply' | 'clear' | 'reset' | 'cancel'"
  },
  "IProvidedFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number"
    }
  },
  "NullComparator": {
    "meta": {},
    "type": {
      "equals?": "boolean",
      "lessThan?": "boolean",
      "greaterThan?": "boolean"
    }
  },
  "IScalarFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator"
    }
  },
  "Comparator": {
    "meta": { "isCallSignature": true, "typeParams": ["T"] },
    "type": {
      "arguments": { "left": "T", "right": "T" },
      "returnType": "number"
    }
  },
  "JoinOperator": { "meta": { "isTypeAlias": true }, "type": "'AND' | 'OR'" },
  "ISimpleFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean"
    }
  },
  "ISimpleFilterModel": {
    "meta": {},
    "type": { "filterType?": "string", "type?": "string | null" }
  },
  "ICombinedSimpleModel": {
    "meta": { "typeParams": ["M extends ISimpleFilterModel"] },
    "type": {
      "filterType?": "string",
      "operator": "JoinOperator",
      "condition1": "M",
      "condition2": "M"
    }
  },
  "ConditionPosition": { "meta": { "isEnum": true }, "type": ["One", "Two"] },
  "TextFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "string",
      "type?": "string | null",
      "filter?": "string | null"
    }
  },
  "TextComparator": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": {
        "filter": "string | null | undefined",
        "gridValue": "any",
        "filterText": "string | null"
      },
      "returnType": "boolean"
    }
  },
  "TextFormatter": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "from": "string | null" },
      "returnType": "string | null"
    }
  },
  "ITextFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "textCustomComparator?": "TextComparator",
      "caseSensitive?": "boolean",
      "textFormatter?": "(from: string) => string",
      "trimInput?": "boolean"
    }
  },
  "GridParams": {
    "meta": {},
    "type": {
      "globalEventListener?": "Function",
      "$scope?": "any",
      "$compile?": "any",
      "frameworkOverrides?": "IFrameworkOverrides",
      "providedBeanInstances?": "{\n    [key: string]: any;\n}",
      "modules?": "Module[]"
    }
  },
  "StartEditingCellParams": {
    "meta": {},
    "type": {
      "rowIndex": "number",
      "colKey": "string | Column",
      "rowPinned?": "string",
      "keyPress?": "number",
      "charPress?": "string"
    }
  },
  "GetCellsParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" }
  },
  "RefreshCellsParams": {
    "meta": {},
    "type": {
      "rowNodes?": "RowNode[]",
      "columns?": "(string | Column)[]",
      "force?": "boolean",
      "suppressFlash?": "boolean"
    }
  },
  "FlashCellsParams": {
    "meta": {},
    "type": {
      "rowNodes?": "RowNode[]",
      "columns?": "(string | Column)[]",
      "flashDelay?": "number",
      "fadeDelay?": "number"
    }
  },
  "GetCellRendererInstancesParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" }
  },
  "GetCellEditorInstancesParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" }
  },
  "RedrawRowsParams": { "meta": {}, "type": { "rowNodes?": "RowNode[]" } },
  "CreateRangeChartParams": {
    "meta": {},
    "type": {
      "cellRange": "CellRangeParams",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean",
      "processChartOptions?": "(params: ProcessChartOptionsParams) => ChartOptions<any>"
    }
  },
  "CreatePivotChartParams": {
    "meta": {},
    "type": {
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean",
      "processChartOptions?": "(params: ProcessChartOptionsParams) => ChartOptions<any>"
    }
  },
  "CreateCrossFilterChartParams": {
    "meta": {},
    "type": {
      "cellRange": "CellRangeParams",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    }
  },
  "DetailGridInfo": {
    "meta": {},
    "type": { "api?": "GridApi", "columnApi?": "ColumnApi", "id": "string" }
  },
  "IFakeHScrollComp": {
    "meta": {},
    "type": {
      "setHeight(height: number)": "void",
      "setViewportHeight(height: number)": "void",
      "setContainerHeight(height: number)": "void",
      "setRightSpacerFixedWidth(width: number)": "void",
      "setLeftSpacerFixedWidth(width: number)": "void",
      "setInvisibleStyles(isInvisible: boolean)": "void",
      "includeLeftSpacerScrollerCss(cssClass: string, include: boolean)": "void",
      "includeRightSpacerScrollerCss(cssClass: string, include: boolean)": "void"
    }
  },
  "RowAnimationCssClasses": {
    "meta": { "isEnum": true },
    "type": [
      "ANIMATION_ON = 'ag-row-animation'",
      "ANIMATION_OFF = 'ag-row-no-animation'"
    ]
  },
  "IGridBodyComp": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void",
      "setColumnMovingCss(cssClass: string | null, on: boolean)": "void",
      "setCellSelectableCss(cssClass: string | null, on: boolean)": "void",
      "setTopHeight(height: number)": "void",
      "setTopDisplay(display: string)": "void",
      "setBottomHeight(height: number)": "void",
      "setBottomDisplay(display: string)": "void",
      "setColumnCount(count: number)": "void",
      "setRowCount(count: number)": "void",
      "setRowAnimationCssOnBodyViewport(cssClass: string, animate: boolean)": "void",
      "setAlwaysVerticalScrollClass(cssClass: string | null, on: boolean)": "void",
      "setPinnedTopBottomOverflowY(overflow: string)": "void",
      "registerBodyViewportResizeListener(listener: (() => void))": "void"
    }
  },
  "NavigateParams": {
    "meta": {},
    "type": {
      "scrollIndex": "number",
      "scrollType": "'top' | 'bottom' | null",
      "scrollColumn": "Column | null",
      "focusIndex": "number",
      "focusColumn": "Column"
    }
  },
  "RenderParams": { "meta": {}, "type": { "rows": "RowNode" } },
  "RenderRowsFeature": {
    "meta": {},
    "type": { "render(rows: RowNode[])": "void" }
  },
  "RowContainerName": {
    "meta": { "isEnum": true },
    "type": [
      "LEFT = 'left'",
      "RIGHT = 'right'",
      "CENTER = 'center'",
      "FULL_WIDTH = 'fullWidth'",
      "TOP_LEFT = 'topLeft'",
      "TOP_RIGHT = 'topRight'",
      "TOP_CENTER = 'topCenter'",
      "TOP_FULL_WITH = 'topFullWidth'",
      "BOTTOM_LEFT = 'bottomLeft'",
      "BOTTOM_RIGHT = 'bottomRight'",
      "BOTTOM_CENTER = 'bottomCenter'",
      "BOTTOM_FULL_WITH = 'bottomFullWidth'"
    ]
  },
  "IRowContainerComp": {
    "meta": {},
    "type": {
      "setViewportHeight(height: string)": "void",
      "setRowCtrls(rowCtrls: RowCtrl[])": "void",
      "setDomOrder(domOrder: boolean)": "void",
      "setContainerWidth(width: string)": "void"
    }
  },
  "RowDropZoneEvents": {
    "meta": {},
    "type": {
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void"
    }
  },
  "RowDropZoneParams": {
    "meta": {},
    "type": {
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void",
      "getContainer": "() => HTMLElement"
    }
  },
  "SetScrollsVisibleParams": {
    "meta": {},
    "type": {
      "horizontalScrollShowing": "boolean",
      "verticalScrollShowing": "boolean"
    }
  },
  "IGridComp": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void",
      "setRtlClass(cssClass: string)": "void",
      "destroyGridUi()": "void",
      "forceFocusOutOfContainer(up: boolean)": "void",
      "addOrRemoveKeyboardFocusClass(value: boolean)": "void",
      "getFocusableContainers()": "HTMLElement[]",
      "setCursor(value: string | null)": "void",
      "setUserSelect(value: string | null)": "void"
    }
  },
  "PropertyChangedEvent": {
    "meta": {},
    "type": { "type": "string", "currentValue": "any", "previousValue": "any" },
    "docs": { "type": "Event identifier" }
  },
  "DropListener": {
    "meta": {},
    "type": {
      "getIconName()": "string | null",
      "onDragEnter(params: DraggingEvent)": "void",
      "onDragLeave(params: DraggingEvent)": "void",
      "onDragging(params: DraggingEvent)": "void",
      "onDragStop(params: DraggingEvent)": "void"
    }
  },
  "IHeaderParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "displayName": "string",
      "enableSorting": "boolean",
      "enableMenu": "boolean",
      "showColumnMenu": "(source: HTMLElement) => void",
      "progressSort": "(multiSort?: boolean) => void",
      "setSort": "(sort: string, multiSort?: boolean) => void",
      "columnApi": "ColumnApi",
      "eGridHeader": "HTMLElement",
      "api": "GridApi",
      "context": "any",
      "template": "string"
    }
  },
  "IHeader": {
    "meta": {},
    "type": { "refresh(params: IHeaderParams)": "boolean" },
    "docs": {
      "refresh(params: IHeaderParams)": "Get the header to refresh. Gets called whenever Column Defs are updated."
    }
  },
  "IHeaderComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "refresh(params: IHeaderParams)": "boolean"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters.",
      "refresh(params: IHeaderParams)": "Get the header to refresh. Gets called whenever Column Defs are updated."
    }
  },
  "HeaderNavigationDirection": {
    "meta": { "isEnum": true },
    "type": ["UP", "DOWN", "LEFT", "RIGHT"]
  },
  "HeaderPosition": {
    "meta": {},
    "type": { "headerRowIndex": "number", "column": "Column | ColumnGroup" }
  },
  "SelectionCount": {
    "meta": {},
    "type": { "selected": "number", "notSelected": "number" }
  },
  "IHeaderGroupParams": {
    "meta": {},
    "type": {
      "columnGroup": "ColumnGroup",
      "displayName": "string",
      "setExpanded": "(expanded: boolean) => void",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "IHeaderGroup": { "meta": {}, "type": {} },
  "IHeaderGroupComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "HeaderContainerPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'left' | 'right' | 'center'"
  },
  "HeaderRowType": {
    "meta": { "isEnum": true },
    "type": ["COLUMN_GROUP", "COLUMN", "FLOATING_FILTER"]
  },
  "HorizontalResizeParams": {
    "meta": {},
    "type": {
      "eResizeBar": "HTMLElement",
      "dragStartPixels?": "number",
      "onResizeStart": "(shiftKey: boolean) => void",
      "onResizing": "(delta: number) => void",
      "onResizeEnd": "(delta: number) => void"
    }
  },
  "ILogger": { "meta": {}, "type": { "log(message: string)": "void" } },
  "BaseExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean"
    }
  },
  "ExportParams": {
    "meta": { "typeParams": ["T"] },
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean",
      "prependContent?": "T",
      "appendContent?": "T",
      "customHeader?": "T",
      "customFooter?": "T",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => T | undefined"
    }
  },
  "PackageFileParams": { "meta": { "typeParams": ["T"] }, "type": {} },
  "CsvCell": {
    "meta": {},
    "type": { "data": "CsvCellData", "mergeAcross?": "number" }
  },
  "CsvCellData": { "meta": {}, "type": { "value": "string | null" } },
  "CsvCustomContent": {
    "meta": { "isTypeAlias": true },
    "type": "CsvCell[][] | string"
  },
  "CsvExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean",
      "prependContent?": "T",
      "appendContent?": "T",
      "customHeader?": "T",
      "customFooter?": "T",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => T | undefined",
      "columnSeparator?": "string",
      "suppressQuotes?": "boolean"
    }
  },
  "ShouldRowBeSkippedParams": {
    "meta": {},
    "type": { "node": "RowNode", "api": "GridApi", "context": "any" }
  },
  "ProcessCellForExportParams": {
    "meta": {},
    "type": {
      "value": "any",
      "accumulatedRowIndex?": "number",
      "node?": "RowNode | null",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "type": "string"
    }
  },
  "ProcessHeaderForExportParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "ProcessGroupHeaderForExportParams": {
    "meta": {},
    "type": {
      "columnGroup": "ColumnGroup",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "ProcessRowGroupForExportParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    }
  },
  "ContainerType": {
    "meta": { "isTypeAlias": true },
    "type": "'columnMenu' | 'contextMenu' | 'toolPanel' | 'floatingFilter'"
  },
  "IAfterGuiAttachedParams": {
    "meta": {},
    "type": {
      "container?": "ContainerType",
      "hidePopup?": "() => void",
      "suppressFocus?": "boolean"
    }
  },
  "FontStyle": {
    "meta": { "isTypeAlias": true },
    "type": "'normal' | 'italic' | 'oblique'"
  },
  "FontWeight": {
    "meta": { "isTypeAlias": true },
    "type": "'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'"
  },
  "AgChartThemeName": {
    "meta": { "isTypeAlias": true },
    "type": "'ag-default' | 'ag-default-dark' | 'ag-material' | 'ag-material-dark' | 'ag-pastel' | 'ag-pastel-dark' | 'ag-solar' | 'ag-solar-dark' | 'ag-vivid' | 'ag-vivid-dark'"
  },
  "AgChartThemePalette": {
    "meta": {},
    "type": { "fills": "string[]", "strokes": "string[]" }
  },
  "AgChartThemeOptions": {
    "meta": {},
    "type": {
      "palette?": "AgChartThemePalette",
      "overrides?": "AgChartThemeOverrides"
    }
  },
  "AgChartTheme": {
    "meta": {},
    "type": {
      "palette?": "AgChartThemePalette",
      "overrides?": "AgChartThemeOverrides",
      "baseTheme?": "AgChartThemeName"
    }
  },
  "AgChartThemeOverrides": {
    "meta": {},
    "type": {
      "cartesian?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgCartesianSeriesTheme>",
      "column?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgBarSeriesOptions>",
      "bar?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgBarSeriesOptions>",
      "line?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgLineSeriesOptions>",
      "area?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgAreaSeriesOptions>",
      "scatter?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgScatterSeriesOptions>",
      "histogram?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgHistogramSeriesOptions>",
      "polar?": "AgPolarChartOptions<AgPolarAxesTheme, AgPolarSeriesTheme>",
      "pie?": "AgPolarChartOptions<AgPolarAxesTheme, AgPieSeriesOptions>",
      "common?": "any"
    }
  },
  "AgCartesianAxesTheme": {
    "meta": {},
    "type": {
      "number?": "Omit<AgNumberAxisOptions, 'type'>",
      "category?": "Omit<AgCategoryAxisOptions, 'type'>",
      "groupedCategory?": "Omit<AgGroupedCategoryAxisOptions, 'type'>",
      "time?": "Omit<AgTimeAxisOptions, 'type'>"
    }
  },
  "AgCartesianSeriesTheme": {
    "meta": {},
    "type": {
      "line?": "AgLineSeriesOptions",
      "scatter?": "AgScatterSeriesOptions",
      "area?": "AgAreaSeriesOptions",
      "bar?": "AgBarSeriesOptions",
      "histogram?": "AgHistogramSeriesOptions"
    }
  },
  "AgPolarAxesTheme": { "meta": {}, "type": {} },
  "AgPolarSeriesTheme": {
    "meta": {},
    "type": { "pie?": "AgPieSeriesOptions" }
  },
  "AgChartPaddingOptions": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number"
    }
  },
  "AgChartLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgDropShadowOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "color?": "string",
      "xOffset?": "number",
      "yOffset?": "number",
      "blue?": "number"
    }
  },
  "AgChartCaptionOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "text?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgNavigatorMaskOptions": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "fillOpacity?": "number"
    }
  },
  "AgNavigatorHandleOptions": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "width?": "number",
      "height?": "number",
      "gripLineGap?": "number",
      "gripLineLength?": "number"
    }
  },
  "AgNavigatorOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "height?": "number",
      "margin?": "number",
      "min?": "number",
      "max?": "number",
      "mask?": "AgNavigatorMaskOptions",
      "minHandle?": "AgNavigatorHandleOptions",
      "maxHandle?": "AgNavigatorHandleOptions"
    }
  },
  "AgChartLegendPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'top' | 'right' | 'bottom' | 'left'"
  },
  "AgChartLegendMarkerOptions": {
    "meta": {},
    "type": {
      "size?": "number",
      "shape?": "string | (new () => any)",
      "padding?": "number",
      "strokeWidth?": "number"
    }
  },
  "AgChartLegendLabelOptions": {
    "meta": {},
    "type": {
      "color?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string"
    }
  },
  "AgChartLegendItemOptions": {
    "meta": {},
    "type": {
      "marker?": "AgChartLegendMarkerOptions",
      "label?": "AgChartLegendLabelOptions",
      "paddingX?": "number",
      "paddingY?": "number"
    }
  },
  "AgChartLegendOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "position?": "AgChartLegendPosition",
      "spacing?": "number",
      "item?": "AgChartLegendItemOptions",
      "layoutHorizontalSpacing?": "number",
      "layoutVerticalSpacing?": "number",
      "itemSpacing?": "number",
      "markerShape?": "string | (new () => any)",
      "markerSize?": "number",
      "strokeWidth?": "number",
      "color?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string"
    }
  },
  "AgBaseChartOptions": {
    "meta": {},
    "type": {
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{\n    visible?: boolean;\n    fill?: string;\n}",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme"
    }
  },
  "AgBaseAxisOptions": { "meta": {}, "type": { "keys?": "string[]" } },
  "AgCartesianAxisPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'top' | 'right' | 'bottom' | 'left'"
  },
  "AgAxisLineOptions": {
    "meta": {},
    "type": { "width?": "number", "color?": "string" }
  },
  "AgAxisTickOptions": {
    "meta": {},
    "type": {
      "width?": "number",
      "size?": "number",
      "color?": "string",
      "count?": "any"
    }
  },
  "AgAxisLabelFormatterParams": {
    "meta": {},
    "type": {
      "value": "any",
      "index": "number",
      "fractionDigits?": "number",
      "formatter?": "(x: any) => string"
    }
  },
  "AgAxisLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "padding?": "number",
      "color?": "string",
      "rotation?": "number",
      "format?": "string",
      "formatter?": "(params: AgAxisLabelFormatterParams) => string"
    }
  },
  "AgAxisGridStyle": {
    "meta": {},
    "type": { "stroke?": "string", "lineDash?": "number[]" }
  },
  "AgBaseCartesianAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]"
    }
  },
  "AgNumberAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'number'",
      "nice?": "boolean",
      "min?": "number",
      "max?": "number"
    }
  },
  "AgCategoryAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'category'",
      "paddingInner?": "number",
      "paddingOuter?": "number"
    }
  },
  "AgGroupedCategoryAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'groupedCategory'"
    }
  },
  "AgTimeAxisOptions": {
    "meta": {},
    "type": {
      "keys?": "string[]",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "type": "'time'",
      "nice?": "boolean"
    }
  },
  "AgCartesianAxisOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgNumberAxisOptions | AgCategoryAxisOptions | AgGroupedCategoryAxisOptions | AgTimeAxisOptions"
  },
  "AgPolarAxisOptions": { "meta": {}, "type": {} },
  "AgBaseSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "AgTooltipRendererResult": {
    "meta": {},
    "type": { "title?": "string", "content?": "string" }
  },
  "AgSeriesTooltipRendererParams": {
    "meta": {},
    "type": { "datum": "any", "title?": "string", "color?": "string" }
  },
  "AgCartesianSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "xKey": "string",
      "xValue?": "any",
      "xName?": "string",
      "yKey": "string",
      "yValue?": "any",
      "yName?": "string"
    }
  },
  "AgPolarSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "angleKey": "string",
      "angleValue?": "any",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusValue?": "any",
      "radiusName?": "string"
    }
  },
  "AgScatterSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "xKey": "string",
      "xValue?": "any",
      "xName?": "string",
      "yKey": "string",
      "yValue?": "any",
      "yName?": "string",
      "sizeKey?": "string",
      "sizeName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "AgSeriesMarker": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "maxSize?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    }
  },
  "AgCartesianSeriesMarkerFormatterParams": {
    "meta": {},
    "type": { "xKey": "string", "yKey": "string" }
  },
  "AgCartesianSeriesMarkerFormat": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "size?": "number"
    }
  },
  "AgCartesianSeriesMarker": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "maxSize?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "formatter?": "(params: AgCartesianSeriesMarkerFormatterParams) => AgCartesianSeriesMarkerFormat"
    }
  },
  "AgSeriesTooltip": { "meta": {}, "type": { "enabled?": "boolean" } },
  "AgLineSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgLineSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "AgLineSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'line'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgLineSeriesLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "xName?": "string",
      "yName?": "string",
      "title?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgLineSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgScatterSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgScatterSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgScatterSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgScatterSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'scatter'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgScatterSeriesLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "xName?": "string",
      "yName?": "string",
      "title?": "string",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgScatterSeriesTooltip",
      "tooltipRenderer?": "(params: AgScatterSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgAreaSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "format?": "string"
    }
  },
  "AgAreaSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "AgAreaSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'area'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgAreaSeriesLabelOptions",
      "xKey?": "string",
      "yKeys?": "string[]",
      "xName?": "string",
      "yNames?": "string[]",
      "fills?": "string[]",
      "strokes?": "string[]",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgAreaSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgBarSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: number;\n}) => string"
    }
  },
  "AgBarSeriesFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean",
      "xKey": "string",
      "yKey": "string"
    }
  },
  "AgBarSeriesFormat": {
    "meta": {},
    "type": { "fill?": "string", "stroke?": "string", "strokeWidth?": "number" }
  },
  "AgBarSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgBarSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'bar' | 'column'",
      "grouped?": "boolean",
      "normalizedTo?": "number",
      "xKey?": "string",
      "yKeys?": "string[] | string[][]",
      "xName?": "string",
      "yNames?": "string[] | {\n    [key in string]: string;\n}",
      "fills?": "string[]",
      "strokes?": "string[]",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "label?": "AgBarSeriesLabelOptions",
      "tooltip?": "AgBarSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "formatter?": "(params: AgBarSeriesFormatterParams) => AgBarSeriesFormat"
    }
  },
  "AgHistogramSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "formatter?": "(params: {\n    value: number;\n}) => string"
    }
  },
  "AgHistogramSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgHistogramSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'histogram'",
      "fill?": "string",
      "stroke?": "string",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "strokeWidth?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "xKey?": "string",
      "xName?": "string",
      "yKey?": "string",
      "yName?": "string",
      "areaPlot?": "boolean",
      "bins?": "[number, number][]",
      "binCount?": "number",
      "aggregation?": "'count' | 'sum' | 'mean'",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "label?": "AgHistogramSeriesLabelOptions",
      "tooltip?": "AgHistogramSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgPieSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string",
      "offset?": "number",
      "minAngle?": "number"
    }
  },
  "AgPieSeriesFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean",
      "angleKey": "string",
      "radiusKey?": "string"
    }
  },
  "AgPieSeriesFormat": {
    "meta": {},
    "type": { "fill?": "string", "stroke?": "string", "strokeWidth?": "number" }
  },
  "AgPieSeriesTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "renderer?": "(params: AgPieSeriesTooltipRendererParams) => string | AgTooltipRendererResult"
    }
  },
  "AgPieSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "type?": "'pie'",
      "title?": "AgChartCaptionOptions",
      "label?": "AgPieSeriesLabelOptions",
      "callout?": "{\n    colors?: string[];\n    length?: number;\n    strokeWidth?: number;\n}",
      "angleKey?": "string",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusName?": "string",
      "labelKey?": "string",
      "labelName?": "string",
      "fills?": "string[]",
      "strokes?": "string[]",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "strokeWidth?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "rotation?": "number",
      "outerRadiusOffset?": "number",
      "innerRadiusOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "highlightStyle?": "{\n    fill?: string;\n    stroke?: string;\n}",
      "tooltip?": "AgPieSeriesTooltip",
      "tooltipRenderer?": "(params: AgPieSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "formatter?": "(params: AgPieSeriesFormatterParams) => AgPieSeriesFormat"
    }
  },
  "AgPieSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color?": "string",
      "angleKey": "string",
      "angleValue?": "any",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusValue?": "any",
      "radiusName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "AgCartesianSeriesOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgLineSeriesOptions | AgScatterSeriesOptions | AgAreaSeriesOptions | AgBarSeriesOptions | AgHistogramSeriesOptions"
  },
  "AgPolarSeriesOptions": { "meta": {}, "type": {} },
  "AgCartesianChartOptions": {
    "meta": { "typeParams": ["TAxisOptions", "TSeriesOptions"] },
    "type": {
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{\n    visible?: boolean;\n    fill?: string;\n}",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme",
      "type?": "'cartesian' | 'groupedCategory' | 'line' | 'bar' | 'column' | 'area' | 'scatter'",
      "axes?": "TAxisOptions",
      "series?": "TSeriesOptions"
    }
  },
  "AgPolarChartOptions": {
    "meta": { "typeParams": ["TAxisOptions", "TSeriesOptions"] },
    "type": {
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{\n    visible?: boolean;\n    fill?: string;\n}",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme",
      "type?": "'polar' | 'pie'",
      "axes?": "TAxisOptions",
      "series?": "TSeriesOptions"
    }
  },
  "AgChartOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgCartesianChartOptions | AgPolarChartOptions"
  },
  "IAggFuncService": {
    "meta": {},
    "type": {
      "addAggFuncs(aggFuncs: {\n    [key: string]: IAggFunc;\n})": "void",
      "addAggFunc(key: string, aggFunc: IAggFunc)": "void",
      "clear()": "void",
      "getDefaultAggFunc(column: Column)": "string | null",
      "getFuncNames(column: Column)": "string[]"
    }
  },
  "IAggregationStage": {
    "meta": {},
    "type": {
      "aggregateValues(values: any[], aggFuncOrString: string | IAggFunc)": "any"
    }
  },
  "ICellEditor": {
    "meta": {},
    "type": {
      "getValue()": "any",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "string | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getFrameworkComponentInstance?()": "any"
    },
    "docs": {
      "getValue()": "Return the final value - called by the grid once after editing is complete",
      "isPopup?()": "Gets called once after initialised. If you return true, the editor will\nappear in a popup, so is not constrained to the boundaries of the cell.\nThis is great if you want to, for example, provide you own custom dropdown list\nfor selection. Default is false (ie if you don't provide the method).",
      "getPopupPosition?()": "Gets called once, only if isPopup() returns true. Return \"over\" if the popup\nshould cover the cell, or \"under\" if it should be positioned below leaving the\ncell value visible. If this method is not present, the default is \"over\".",
      "isCancelBeforeStart?()": "Gets called once after initialised. If you return true, the editor will not be\nused and the grid will continue editing. Use this to make a decision on editing\ninside the init() function, eg maybe you want to only start editing if the user\nhits a numeric key, but not a letter, if the editor is for numbers.",
      "isCancelAfterEnd?()": "Gets called once after editing is complete. If your return true, then the new\nvalue will not be used. The editing will have no impact on the record. Use this\nif you do not want a new value from your gui, i.e. you want to cancel the editing.",
      "focusIn?()": "If doing full line edit, then gets called when focus should be put into the editor",
      "focusOut?()": "If doing full line edit, then gets called when focus is leaving the editor",
      "getFrameworkComponentInstance?()": "If using a framework this returns the underlying component instance, so you can call\nmethods on it if you want."
    }
  },
  "ICellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any"
    }
  },
  "ICellEditorComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "isPopup?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getValue()": "any",
      "getPopupPosition?()": "string | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "getFrameworkComponentInstance?()": "any"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters.",
      "isPopup?()": "Gets called once after initialised. If you return true, the editor will\nappear in a popup, so is not constrained to the boundaries of the cell.\nThis is great if you want to, for example, provide you own custom dropdown list\nfor selection. Default is false (ie if you don't provide the method).",
      "focusIn?()": "If doing full line edit, then gets called when focus should be put into the editor",
      "focusOut?()": "If doing full line edit, then gets called when focus is leaving the editor",
      "getValue()": "Return the final value - called by the grid once after editing is complete",
      "getPopupPosition?()": "Gets called once, only if isPopup() returns true. Return \"over\" if the popup\nshould cover the cell, or \"under\" if it should be positioned below leaving the\ncell value visible. If this method is not present, the default is \"over\".",
      "isCancelBeforeStart?()": "Gets called once after initialised. If you return true, the editor will not be\nused and the grid will continue editing. Use this to make a decision on editing\ninside the init() function, eg maybe you want to only start editing if the user\nhits a numeric key, but not a letter, if the editor is for numbers.",
      "isCancelAfterEnd?()": "Gets called once after editing is complete. If your return true, then the new\nvalue will not be used. The editing will have no impact on the record. Use this\nif you do not want a new value from your gui, i.e. you want to cancel the editing.",
      "getFrameworkComponentInstance?()": "If using a framework this returns the underlying component instance, so you can call\nmethods on it if you want."
    }
  },
  "ChartType": {
    "meta": { "isEnum": true },
    "type": [
      "Column = 'column'",
      "GroupedColumn = 'groupedColumn'",
      "StackedColumn = 'stackedColumn'",
      "NormalizedColumn = 'normalizedColumn'",
      "Bar = 'bar'",
      "GroupedBar = 'groupedBar'",
      "StackedBar = 'stackedBar'",
      "NormalizedBar = 'normalizedBar'",
      "Line = 'line'",
      "Scatter = 'scatter'",
      "Bubble = 'bubble'",
      "Pie = 'pie'",
      "Doughnut = 'doughnut'",
      "Area = 'area'",
      "StackedArea = 'stackedArea'",
      "NormalizedArea = 'normalizedArea'",
      "Histogram = 'histogram'"
    ]
  },
  "ChartMenuOptions": {
    "meta": { "isTypeAlias": true },
    "type": "'chartSettings' | 'chartData' | 'chartFormat' | 'chartLink' | 'chartUnlink' | 'chartDownload'"
  },
  "SeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "ChartTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "class?": "string",
      "tracking?": "boolean",
      "delay?": "number"
    }
  },
  "ChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "PaddingOptions": {
    "meta": {},
    "type": {
      "top": "number",
      "right": "number",
      "bottom": "number",
      "left": "number"
    }
  },
  "BackgroundOptions": {
    "meta": {},
    "type": { "fill": "string", "visible": "boolean" }
  },
  "FontOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "CaptionOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "text?": "string"
    }
  },
  "LegendOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "position": "LegendPosition",
      "spacing": "number",
      "item": "LegendItemOptions"
    }
  },
  "LegendPosition": {
    "meta": { "isEnum": true },
    "type": [
      "Top = 'top'",
      "Right = 'right'",
      "Bottom = 'bottom'",
      "Left = 'left'"
    ]
  },
  "LegendItemOptions": {
    "meta": {},
    "type": {
      "label": "LegendLabelOptions",
      "marker": "LegendMarkerOptions",
      "paddingX": "number",
      "paddingY": "number"
    }
  },
  "LegendLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "NavigatorOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "height": "number",
      "min": "number",
      "max": "number",
      "mask": "NavigatorMaskOptions",
      "minHandle": "NavigatorHandleOptions",
      "maxHandle": "NavigatorHandleOptions"
    }
  },
  "NavigatorMaskOptions": {
    "meta": {},
    "type": {
      "fill": "string",
      "stroke": "string",
      "strokeWidth": "number",
      "fillOpacity": "number"
    }
  },
  "NavigatorHandleOptions": {
    "meta": {},
    "type": {
      "fill": "string",
      "stroke": "string",
      "strokeWidth": "number",
      "width": "number",
      "height": "number",
      "gripLineGap": "number",
      "gripLineLength": "number"
    }
  },
  "MarkerShape": {
    "meta": { "isTypeAlias": true },
    "type": "'circle' | 'cross' | 'diamond' | 'plus' | 'square' | 'triangle'"
  },
  "LegendMarkerOptions": {
    "meta": {},
    "type": {
      "shape": "MarkerShape",
      "size": "number",
      "padding": "number",
      "strokeWidth": "number"
    }
  },
  "CartesianChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}",
      "xAxis": "AxisOptions",
      "yAxis": "AxisOptions"
    }
  },
  "PolarChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "AxisOptions": {
    "meta": {},
    "type": {
      "type?": "AxisType",
      "title": "CaptionOptions",
      "line": "AxisLineOptions",
      "tick": "AxisTickOptions",
      "label": "AxisLabelOptions",
      "gridStyle": "GridStyle[]"
    }
  },
  "AxisType": {
    "meta": { "isTypeAlias": true },
    "type": "'category' | 'number' | 'time'"
  },
  "AxisLineOptions": {
    "meta": {},
    "type": { "width": "number", "color": "string" }
  },
  "AxisTickOptions": {
    "meta": {},
    "type": { "width": "number", "size": "number", "color": "string" }
  },
  "AxisLabelFormatterParams": {
    "meta": {},
    "type": {
      "value": "any",
      "index": "number",
      "fractionDigits?": "number",
      "formatter?": "(x: any) => string"
    }
  },
  "AxisLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "padding": "number",
      "rotation": "number",
      "format?": "string",
      "formatter?": "(params: AxisLabelFormatterParams) => string"
    }
  },
  "GridStyle": {
    "meta": {},
    "type": { "stroke": "string", "lineDash?": "number[]" }
  },
  "HighlightOptions": {
    "meta": {},
    "type": { "fill": "string", "stroke?": "string", "dimOpacity?": "number" }
  },
  "FillOptions": {
    "meta": {},
    "type": { "colors": "string[]", "opacity": "number" }
  },
  "StrokeOptions": {
    "meta": {},
    "type": { "colors": "string[]", "opacity": "number", "width": "number" }
  },
  "DropShadowOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "color": "string",
      "xOffset": "number",
      "yOffset": "number",
      "blur": "number"
    }
  },
  "SeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean"
    }
  },
  "TooltipRendererResult": {
    "meta": {},
    "type": { "content": "string", "title?": "string" }
  },
  "TooltipOptions": {
    "meta": { "typeParams": ["TParams"] },
    "type": {
      "enabled": "boolean",
      "renderer?": "(params: TParams) => string | TooltipRendererResult"
    }
  },
  "TooltipRendererParams": {
    "meta": {},
    "type": { "datum": "any", "title?": "string", "color": "string" }
  },
  "CartesianTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "BarSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "shadow": "DropShadowOptions",
      "label": "BarSeriesLabelOptions",
      "tooltip": "TooltipOptions<BarTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "HistogramSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "shadow": "DropShadowOptions",
      "label": "BarSeriesLabelOptions",
      "tooltip": "TooltipOptions<BarTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number",
      "binCount?": "number"
    }
  },
  "BarSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "formatter?": "(params: {\n    value: number;\n}) => string"
    }
  },
  "BarTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "LineSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "marker": "MarkerOptions",
      "label": "LineSeriesLabelOptions",
      "tooltip": "TooltipOptions<LineTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "LineSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "MarkerOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "shape": "MarkerShape",
      "size": "number",
      "strokeWidth": "number",
      "formatter?": "Function"
    }
  },
  "LineTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "ScatterSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean"
    }
  },
  "ScatterSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "marker": "ScatterMarkerOptions",
      "label": "ScatterSeriesLabelOptions",
      "tooltip": "TooltipOptions<ScatterTooltipRendererParams>",
      "paired": "boolean"
    }
  },
  "ScatterMarkerOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "shape": "MarkerShape",
      "size": "number",
      "strokeWidth": "number",
      "formatter?": "Function",
      "maxSize?": "number"
    }
  },
  "ScatterTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string",
      "sizeKey?": "string",
      "sizeName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "AreaSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "formatter?": "(params: {\n    value: any;\n}) => string"
    }
  },
  "AreaSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "marker": "MarkerOptions",
      "label": "AreaSeriesLabelOptions",
      "shadow": "DropShadowOptions",
      "tooltip": "TooltipOptions<AreaTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "AreaTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string"
    }
  },
  "PieSeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}",
      "title": "CaptionOptions",
      "label": "PieSeriesLabelOptions",
      "callout": "PieSeriesCalloutOptions",
      "shadow": "DropShadowOptions",
      "tooltip": "TooltipOptions<PieTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number"
    }
  },
  "PieSeriesLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string",
      "enabled": "boolean",
      "minAngle": "number",
      "offset": "number"
    }
  },
  "PieSeriesCalloutOptions": {
    "meta": {},
    "type": {
      "length": "number",
      "strokeWidth": "number",
      "colors": "string[]"
    }
  },
  "PieTooltipRendererParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "title?": "string",
      "color": "string",
      "angleKey": "string",
      "angleValue": "any",
      "angleName?": "string",
      "labelKey?": "string",
      "labelName?": "string"
    }
  },
  "GetChartImageDataUrlParams": {
    "meta": {},
    "type": { "chartId": "string", "fileFormat?": "string" }
  },
  "ChartModelType": {
    "meta": { "isTypeAlias": true },
    "type": "'range' | 'pivot'"
  },
  "ChartModel": {
    "meta": {},
    "type": {
      "modelType": "ChartModelType",
      "chartId": "string",
      "chartType": "ChartType",
      "cellRange": "CellRangeParams",
      "chartThemeName?": "string",
      "chartOptions": "ChartOptions<any>",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "unlinkChart?": "boolean"
    }
  },
  "IChartService": {
    "meta": {},
    "type": {
      "getChartModels()": "ChartModel[]",
      "getChartRef(chartId: string)": "ChartRef | undefined",
      "createRangeChart(params: CreateRangeChartParams)": "ChartRef | undefined",
      "createCrossFilterChart(params: CreateCrossFilterChartParams)": "ChartRef | undefined",
      "createChartFromCurrentRange(chartType: ChartType)": "ChartRef | undefined",
      "createPivotChart(params: CreatePivotChartParams)": "ChartRef | undefined",
      "restoreChart(model: ChartModel, chartContainer?: HTMLElement)": "ChartRef | undefined",
      "getChartImageDataURL(params: GetChartImageDataUrlParams)": "string | undefined"
    }
  },
  "ClientSideRowModelSteps": {
    "meta": { "isEnum": true },
    "type": [
      "EVERYTHING = 'group'",
      "FILTER = 'filter'",
      "SORT = 'sort'",
      "MAP = 'map'",
      "AGGREGATE = 'aggregate'",
      "PIVOT = 'pivot'",
      "NOTHING = 'nothing'"
    ]
  },
  "IClientSideRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void",
      "updateRowData(rowDataTran: RowDataTransaction, rowNodeOrder?: {\n    [id: string]: number;\n} | null)": "RowNodeTransaction | null",
      "setRowData(rowData: any[])": "void",
      "refreshModel(params: RefreshModelParams)": "void",
      "expandOrCollapseAll(expand: boolean)": "void",
      "forEachLeafNode(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNode(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNodeAfterFilter(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void)": "void",
      "resetRowHeights()": "void",
      "onRowHeightChanged()": "void",
      "batchUpdateRowData(rowDataTransaction: RowDataTransaction, callback?: (res: RowNodeTransaction) => void)": "void",
      "flushAsyncTransactions()": "void",
      "getRootNode()": "RowNode",
      "doAggregate(changedPath?: ChangedPath)": "void",
      "getTopLevelNodes()": "RowNode[] | null",
      "forEachPivotNode(callback: (node: RowNode, index: number) => void)": "void",
      "ensureRowsAtPixel(rowNode: RowNode[], pixel: number, increment: number)": "boolean",
      "highlightRowAtPixel(rowNode: RowNode | null, pixel?: number)": "void",
      "getHighlightPosition(pixel: number, rowNode?: RowNode)": "RowHighlightPosition",
      "getLastHighlightedRowNode()": "RowNode | null"
    },
    "docs": {
      "getRow(index: number)": "Returns the rowNode at the given index.",
      "getRowNode(id: string)": "Returns the rowNode for given id.",
      "getRowCount()": "This is legacy, not used by AG Grid, but keeping for backward compatibility",
      "getRowIndexAtPixel(pixel: number)": "Returns the row index at the given pixel",
      "isRowPresent(rowNode: RowNode)": "Returns true if the provided rowNode is in the list of rows to render",
      "getRowBounds(index: number)": "Returns row top and bottom for a given row",
      "isEmpty()": "Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\nout, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\ndon't show that overlay if the rows are just filtered out.",
      "isRowsToRender()": "Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\nuses to know if there are rows to render or not.",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\nthen no rows should be returned",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "Iterate through each node. What this does depends on the model type. For clientSide, goes through\nall nodes. For serverSide, goes through what's loaded in memory.",
      "getType()": "The base class returns the type. We use this instead of 'instanceof' as the client might provide\ntheir own implementation of the models in the future.",
      "isLastRowIndexKnown()": "It tells us if this row model knows about the last row that it can produce. This is used by the\nPaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\nnot shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "Used by CSRM only - is makes sure there are now estimated row heights within the range.",
      "start()": "Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\nfrom gridOptions, the other row models will start calling their datasources."
    }
  },
  "RefreshModelParams": {
    "meta": {},
    "type": {
      "step": "ClientSideRowModelSteps",
      "groupState?": "any",
      "keepRenderedRows?": "boolean",
      "animate?": "boolean",
      "keepEditingRows?": "boolean",
      "rowNodeTransactions?": "RowNodeTransaction[]",
      "rowNodeOrder?": "{\n    [id: string]: number;\n}",
      "newData?": "boolean",
      "afterColumnsChanged?": "boolean"
    }
  },
  "IClipboardService": {
    "meta": {},
    "type": {
      "pasteFromClipboard()": "void",
      "copyToClipboard(includeHeader?: boolean)": "void",
      "copySelectedRowsToClipboard(includeHeader?: boolean, columnKeys?: (string | Column)[])": "void",
      "copySelectedRangeToClipboard(includeHeader?: boolean)": "void",
      "copyRangeDown()": "void"
    }
  },
  "IColumnToolPanel": {
    "meta": {},
    "type": {
      "expandColumnGroups(groupIds?: string[])": "void",
      "collapseColumnGroups(groupIds?: string[])": "void",
      "setColumnLayout(colDefs: (ColDef | ColGroupDef)[])": "void",
      "syncLayoutWithGrid()": "void",
      "setPivotModeSectionVisible(visible: boolean)": "void",
      "setRowGroupsSectionVisible(visible: boolean)": "void",
      "setValuesSectionVisible(visible: boolean)": "void",
      "setPivotSectionVisible(visible: boolean)": "void"
    }
  },
  "ColumnVO": {
    "meta": {},
    "type": {
      "id": "string",
      "displayName": "string",
      "field?": "string",
      "aggFunc?": "string"
    }
  },
  "IComponent": {
    "meta": { "typeParams": ["T"] },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "IContextMenuFactory": {
    "meta": {},
    "type": {
      "onContextMenu(mouseEvent: MouseEvent | null, touchEvent: TouchEvent | null, rowNode: RowNode | null, column: Column | null, value: any, anchorToElement: HTMLElement)": "void",
      "hideActiveMenu()": "void"
    }
  },
  "ICsvCreator": {
    "meta": {},
    "type": {
      "getDataAsCsv(params?: CsvExportParams)": "string",
      "exportDataAsCsv(params?: CsvExportParams)": "string"
    }
  },
  "IDatasource": {
    "meta": {},
    "type": {
      "rowCount?": "number",
      "getRows(params: IGetRowsParams)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "rowCount?": "If you know up front how many rows are in the dataset, set it here. Otherwise leave blank.",
      "getRows(params: IGetRowsParams)": "Callback the grid calls that you implement to fetch rows from the server. See below for params."
    }
  },
  "IGetRowsParams": {
    "meta": {},
    "type": {
      "startRow": "number",
      "endRow": "number",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "void",
      "failCallback()": "void",
      "sortModel": "any",
      "filterModel": "any",
      "context": "any"
    },
    "docs": {
      "startRow": "The first row index to get.",
      "endRow": "The first row index to NOT get.",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "Callback to call for the result when successful.",
      "failCallback()": "Callback to call when the request fails.",
      "sortModel": "If doing server side sorting, contains the sort model",
      "filterModel": "If doing server side filtering, contains the filter model",
      "context": "The grid context object"
    }
  },
  "IEventEmitter": {
    "meta": {},
    "type": {
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void"
    }
  },
  "ExcelStyle": {
    "meta": {},
    "type": {
      "id": "string",
      "alignment?": "ExcelAlignment",
      "borders?": "ExcelBorders",
      "dataType?": "ExcelDataType",
      "font?": "ExcelFont",
      "interior?": "ExcelInterior",
      "numberFormat?": "ExcelNumberFormat",
      "protection?": "ExcelProtection",
      "name?": "string"
    }
  },
  "ExcelAlignment": {
    "meta": {},
    "type": {
      "horizontal?": "'Automatic' | 'Left' | 'Center' | 'Right' | 'Fill' | 'Justify' | 'CenterAcrossSelection' | 'Distributed' | 'JustifyDistributed'",
      "indent?": "number",
      "readingOrder?": "'RightToLeft' | 'LeftToRight' | 'Context'",
      "rotate?": "number",
      "shrinkToFit?": "boolean",
      "vertical?": "'Automatic' | 'Top' | 'Bottom' | 'Center' | 'Justify' | 'Distributed' | 'JustifyDistributed'",
      "wrapText?": "boolean",
      "verticalText?": "boolean"
    }
  },
  "ExcelBorders": {
    "meta": {},
    "type": {
      "borderBottom?": "ExcelBorder",
      "borderLeft?": "ExcelBorder",
      "borderRight?": "ExcelBorder",
      "borderTop?": "ExcelBorder"
    }
  },
  "ExcelBorder": {
    "meta": {},
    "type": {
      "color?": "string",
      "lineStyle?": "'None' | 'Continuous' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot' | 'SlantDashDot' | 'Double'",
      "weight?": "0 | 1 | 2 | 3"
    }
  },
  "ExcelFont": {
    "meta": {},
    "type": {
      "bold?": "boolean",
      "color?": "string",
      "family?": "string",
      "fontName?": "string",
      "italic?": "boolean",
      "outline?": "boolean",
      "shadow?": "boolean",
      "size?": "number",
      "strikeThrough?": "boolean",
      "underline?": "'Single' | 'Double'",
      "verticalAlign?": "'Superscript' | 'Subscript'",
      "charSet?": "number"
    }
  },
  "ExcelInterior": {
    "meta": {},
    "type": {
      "color": "string",
      "pattern": "'None' | 'Solid' | 'Gray75' | 'Gray50' | 'Gray25' | 'Gray125' | 'Gray0625' | 'HorzStripe' | 'VertStripe' | 'ReverseDiagStripe' | 'DiagStripe' | 'DiagCross' | 'ThickDiagCross' | 'ThinHorzStripe' | 'ThinVertStripe' | 'ThinReverseDiagStripe' | 'ThinDiagStripe' | 'ThinHorzCross' | 'ThinDiagCross'",
      "patternColor": "string"
    }
  },
  "ExcelNumberFormat": { "meta": {}, "type": { "format": "string" } },
  "ExcelProtection": {
    "meta": {},
    "type": { "protected": "boolean", "hideFormula": "boolean" }
  },
  "ExcelWorksheet": {
    "meta": {},
    "type": { "name": "string", "table": "ExcelTable" }
  },
  "ExcelTable": {
    "meta": {},
    "type": { "columns": "ExcelColumn[]", "rows": "ExcelRow[]" }
  },
  "ExcelColumn": {
    "meta": {},
    "type": {
      "min?": "number",
      "max?": "number",
      "width?": "number",
      "s?": "number",
      "hidden?": "boolean",
      "bestFit?": "boolean"
    }
  },
  "ExcelRow": {
    "meta": {},
    "type": {
      "index?": "number",
      "collapsed?": "boolean",
      "hidden?": "boolean",
      "height?": "number",
      "outlineLevel?": "number",
      "s?": "number",
      "cells": "ExcelCell[]"
    }
  },
  "ExcelCell": {
    "meta": {},
    "type": {
      "ref?": "string",
      "styleId?": "string",
      "data": "ExcelData",
      "mergeAcross?": "number"
    }
  },
  "ExcelImage": {
    "meta": {},
    "type": {
      "id": "string",
      "base64": "string",
      "imageType": "'jpg' | 'png' | 'gif'",
      "altText?": "string",
      "fitCell?": "boolean",
      "transparency?": "number",
      "rotation?": "number",
      "recolor?": "'Grayscale' | 'Sepia' | 'Washout'",
      "width?": "number",
      "height?": "number",
      "position?": "{\n    row?: number;\n    rowSpan?: number;\n    column?: number;\n    colSpan?: number;\n    offsetX?: number;\n    offsetY?: number;\n}"
    }
  },
  "ExcelDataType": {
    "meta": { "isTypeAlias": true },
    "type": "'String' | 'Formula' | 'Number' | 'Boolean' | 'DateTime' | 'Error'"
  },
  "ExcelOOXMLDataType": {
    "meta": { "isTypeAlias": true },
    "type": "'str' | 's' | 'f' | 'inlineStr' | 'n' | 'b' | 'd' | 'e' | 'empty'"
  },
  "ExcelData": {
    "meta": {},
    "type": {
      "type": "ExcelDataType | ExcelOOXMLDataType",
      "value": "string | null"
    }
  },
  "ExcelRelationship": {
    "meta": {},
    "type": { "Id": "string", "Type": "string", "Target": "string" }
  },
  "ExcelContentType": {
    "meta": {},
    "type": {
      "name": "'Default' | 'Override'",
      "ContentType": "string",
      "Extension?": "string",
      "PartName?": "string"
    }
  },
  "ExcelXMLTemplate": {
    "meta": {},
    "type": {
      "getTemplate(styleProperties?: ExcelStyle | ExcelWorksheet | ExcelColumn | ExcelRow | ExcelCell)": "XmlElement"
    }
  },
  "ExcelOOXMLTemplate": {
    "meta": {},
    "type": {
      "getTemplate(config?: any, idx?: number, currentSheet?: number)": "XmlElement",
      "convertType?(type: string)": "string"
    }
  },
  "ExcelFactoryMode": {
    "meta": { "isEnum": true },
    "type": ["SINGLE_SHEET", "MULTI_SHEET"]
  },
  "ColumnWidthCallbackParams": {
    "meta": {},
    "type": { "column": "Column | null", "index": "number" }
  },
  "RowHeightCallbackParams": { "meta": {}, "type": { "rowIndex": "number" } },
  "ExcelExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean",
      "prependContent?": "T",
      "appendContent?": "T",
      "customHeader?": "T",
      "customFooter?": "T",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => T | undefined",
      "author?": "string",
      "autoConvertFormulas?": "boolean",
      "columnWidth?": "number | ((params: ColumnWidthCallbackParams) => number)",
      "exportMode?": "'xlsx' | 'xml'",
      "fontSize?": "number",
      "headerRowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "rowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "sheetName?": "string",
      "margins?": "ExcelSheetMargin",
      "pageSetup?": "ExcelSheetPageSetup",
      "headerFooterConfig?": "ExcelHeaderFooterConfig",
      "suppressTextAsCDATA?": "boolean",
      "addImageToCell?": "(rowIndex: number, column: Column, value: string) => {\n    image: ExcelImage;\n    value?: string;\n} | undefined"
    }
  },
  "ExcelExportMultipleSheetParams": {
    "meta": {},
    "type": {
      "author?": "string",
      "data": "string[]",
      "fileName?": "string",
      "fontSize?": "number"
    }
  },
  "ExcelHeaderFooterConfig": {
    "meta": {},
    "type": {
      "all?": "ExcelHeaderFooter",
      "first?": "ExcelHeaderFooter",
      "even?": "ExcelHeaderFooter"
    }
  },
  "ExcelHeaderFooter": {
    "meta": {},
    "type": {
      "header?": "ExcelHeaderFooterContent[]",
      "footer?": "ExcelHeaderFooterContent[]"
    }
  },
  "ExcelHeaderFooterContent": {
    "meta": {},
    "type": {
      "value": "string",
      "position?": "'Left' | 'Center' | 'Right'",
      "font?": "ExcelFont"
    }
  },
  "IExcelCreator": {
    "meta": {},
    "type": {
      "exportDataAsExcel(params?: ExcelExportParams)": "void",
      "getDataAsExcel(params?: ExcelExportParams)": "Blob | string | undefined",
      "getSheetDataForExcel(params?: ExcelExportParams)": "string",
      "getMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "Blob | undefined",
      "exportMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "void",
      "setFactoryMode(factoryMode: ExcelFactoryMode, exportMode: 'xml' | 'xlsx')": "void",
      "getFactoryMode(exportMode: 'xml' | 'xlsx')": "ExcelFactoryMode"
    },
    "docs": {
      "setFactoryMode(factoryMode: ExcelFactoryMode, exportMode: 'xml' | 'xlsx')": "private methods"
    }
  },
  "ExcelSheetMargin": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number",
      "header?": "number",
      "footer?": "number"
    }
  },
  "ExcelSheetPageSetup": {
    "meta": {},
    "type": {
      "orientation?": "'Portrait' | 'Landscape'",
      "pageSize?": "'Letter' | 'Letter Small' | 'Tabloid' | 'Ledger' | 'Legal' | 'Statement' | 'Executive' | 'A3' | 'A4' | 'A4 Small' | 'A5' | 'A6' | 'B4' | 'B5' | 'Folio' | 'Envelope' | 'Envelope DL' | 'Envelope C5' | 'Envelope B5' | 'Envelope C3' | 'Envelope C4' | 'Envelope C6' | 'Envelope Monarch' | 'Japanese Postcard' | 'Japanese Double Postcard'"
    }
  },
  "IFilterType": {
    "meta": { "isTypeAlias": true },
    "type": "string | {\n    new (): IFilterComp;\n} | boolean"
  },
  "IFilterDef": {
    "meta": {},
    "type": {
      "filter?": "IFilterType",
      "filterFramework?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "string | {\n    new (): IFloatingFilterComp;\n}",
      "floatingFilterComponentParams?": "any",
      "floatingFilterComponentFramework?": "any"
    },
    "docs": {
      "filter?": "One of the built in filter names: [set, number, text], or a filter function",
      "filterParams?": "The filter params are specific to each filter!",
      "floatingFilterComponent?": "The custom component to be used for rendering the floating filter. If none is specified the default AG Grid is used. *"
    }
  },
  "IFilter": {
    "meta": {},
    "type": {
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "isFilterActive()": "This is used to let the grid know if the filter is active or not",
      "doesFilterPass(params: IDoesFilterPassParams)": "The grid will ask each active filter, in turn, whether each row in the grid passes. If any\nfilter fails, then the row will be excluded from the final set. The method is provided a\nparams object with attributes node (the rodNode the grid creates that wraps the data) and data\n(the data object that you provided to the grid for that row).",
      "getModel()": "Gets the filter state for storing",
      "setModel(model: any)": "Restores the filter state.",
      "onNewRowsLoaded?()": "Gets called when new rows are inserted into the grid. If the filter needs to change it's state\nafter rows are loaded, it can do it here.",
      "onAnyFilterChanged?()": "Called whenever any filter is changed.",
      "getFrameworkComponentInstance?()": "If using React or Angular 2, returns the underlying component instance, so you can call methods\non it if you want.",
      "getModelAsString?(model: any)": "Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\nassociated for this filter, this will happen if you create a custom filter and NOT a custom floating\nfilter."
    }
  },
  "ProvidedFilterModel": { "meta": {}, "type": { "filterType?": "string" } },
  "IFilterComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters.",
      "isFilterActive()": "This is used to let the grid know if the filter is active or not",
      "doesFilterPass(params: IDoesFilterPassParams)": "The grid will ask each active filter, in turn, whether each row in the grid passes. If any\nfilter fails, then the row will be excluded from the final set. The method is provided a\nparams object with attributes node (the rodNode the grid creates that wraps the data) and data\n(the data object that you provided to the grid for that row).",
      "getModel()": "Gets the filter state for storing",
      "setModel(model: any)": "Restores the filter state.",
      "onNewRowsLoaded?()": "Gets called when new rows are inserted into the grid. If the filter needs to change it's state\nafter rows are loaded, it can do it here.",
      "onAnyFilterChanged?()": "Called whenever any filter is changed.",
      "getFrameworkComponentInstance?()": "If using React or Angular 2, returns the underlying component instance, so you can call methods\non it if you want.",
      "getModelAsString?(model: any)": "Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\nassociated for this filter, this will happen if you create a custom filter and NOT a custom floating\nfilter."
    }
  },
  "IDoesFilterPassParams": {
    "meta": {},
    "type": { "node": "RowNode", "data": "any" }
  },
  "IFilterOptionDef": {
    "meta": {},
    "type": {
      "displayKey": "string",
      "displayName": "string",
      "test": "(filterValue: any, cellValue: any) => boolean",
      "hideFilterInput?": "boolean"
    }
  },
  "IFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any"
    }
  },
  "Filter": {
    "meta": {},
    "type": {
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "isFilterActive()": "This is used to let the grid know if the filter is active or not",
      "doesFilterPass(params: IDoesFilterPassParams)": "The grid will ask each active filter, in turn, whether each row in the grid passes. If any\nfilter fails, then the row will be excluded from the final set. The method is provided a\nparams object with attributes node (the rodNode the grid creates that wraps the data) and data\n(the data object that you provided to the grid for that row).",
      "getModel()": "Gets the filter state for storing",
      "setModel(model: any)": "Restores the filter state.",
      "onNewRowsLoaded?()": "Gets called when new rows are inserted into the grid. If the filter needs to change it's state\nafter rows are loaded, it can do it here.",
      "onAnyFilterChanged?()": "Called whenever any filter is changed.",
      "getFrameworkComponentInstance?()": "If using React or Angular 2, returns the underlying component instance, so you can call methods\non it if you want.",
      "getModelAsString?(model: any)": "Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\nassociated for this filter, this will happen if you create a custom filter and NOT a custom floating\nfilter."
    }
  },
  "IFiltersToolPanel": {
    "meta": {},
    "type": {
      "setFilterLayout(colDefs: ColDef[])": "void",
      "expandFilterGroups(groupIds?: string[])": "void",
      "collapseFilterGroups(groupIds?: string[])": "void",
      "expandFilters(colIds?: string[])": "void",
      "collapseFilters(colIds?: string[])": "void",
      "syncLayoutWithGrid()": "void"
    }
  },
  "IFrameworkOverrides": {
    "meta": {},
    "type": {
      "setTimeout(action: any, timeout?: any)": "void",
      "setInterval(action: any, interval?: any)": "AgPromise<number>",
      "addEventListener(element: HTMLElement, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions)": "void",
      "dispatchEvent(eventType: string, listener: () => {}, global: boolean)": "void",
      "frameworkComponent(name: string)": "any"
    },
    "docs": {
      "setTimeout(action: any, timeout?: any)": "Because Angular 2+ uses Zones, you should not use setTimeout or setInterval (as it'll keep angular constantly doing dirty checks etc\nSo to get around this, we allow the framework to specify how to execute setTimeout. The default is to just call the browser setTimeout().",
      "addEventListener(element: HTMLElement, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions)": "Again because Angular uses Zones, we allow adding some events outside of Zone JS so that we do not kick off\nthe Angular change detection. We do this for some events ONLY, and not all events, just events that get fired\na lot (eg mouse move), but we need to make sure in AG Grid that we do NOT call any grid callbacks while processing\nthese events, as we will be outside of ZoneJS and hence Angular2 Change Detection won't work. However it's fine\nfor our code to result in AG Grid events (and Angular application action on these) as these go through\nEvent Emitter's.\n\nThis was done by Niall and Sean. The problematic events are mouseover, mouseout, mouseenter and mouseleave."
    }
  },
  "IImmutableService": {
    "meta": {},
    "type": {
      "createTransactionForRowData(data: any[])": "([RowDataTransaction, {\n    [id: string]: number;\n} | null]) | undefined"
    }
  },
  "IInfiniteRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void",
      "setDatasource(datasource: IDatasource | undefined)": "void",
      "refreshCache()": "void",
      "purgeCache()": "void",
      "setRowCount(rowCount: number, maxRowFound?: boolean)": "void"
    },
    "docs": {
      "getRow(index: number)": "Returns the rowNode at the given index.",
      "getRowNode(id: string)": "Returns the rowNode for given id.",
      "getRowCount()": "This is legacy, not used by AG Grid, but keeping for backward compatibility",
      "getRowIndexAtPixel(pixel: number)": "Returns the row index at the given pixel",
      "isRowPresent(rowNode: RowNode)": "Returns true if the provided rowNode is in the list of rows to render",
      "getRowBounds(index: number)": "Returns row top and bottom for a given row",
      "isEmpty()": "Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\nout, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\ndon't show that overlay if the rows are just filtered out.",
      "isRowsToRender()": "Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\nuses to know if there are rows to render or not.",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\nthen no rows should be returned",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "Iterate through each node. What this does depends on the model type. For clientSide, goes through\nall nodes. For serverSide, goes through what's loaded in memory.",
      "getType()": "The base class returns the type. We use this instead of 'instanceof' as the client might provide\ntheir own implementation of the models in the future.",
      "isLastRowIndexKnown()": "It tells us if this row model knows about the last row that it can produce. This is used by the\nPaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\nnot shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "Used by CSRM only - is makes sure there are now estimated row heights within the range.",
      "start()": "Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\nfrom gridOptions, the other row models will start calling their datasources."
    }
  },
  "IMenu": { "meta": {}, "type": {} },
  "IMenuFactory": {
    "meta": {},
    "type": {
      "showMenuAfterButtonClick(column: Column | null, eventSource: HTMLElement, containerType: ContainerType, defaultTab?: string, restrictToTabs?: string[])": "void",
      "showMenuAfterMouseEvent(column: Column, mouseEvent: MouseEvent | Touch, defaultTab?: string, restrictToTabs?: string[])": "void",
      "isMenuEnabled(column: Column)": "boolean",
      "hideActiveMenu()": "void"
    }
  },
  "Module": {
    "meta": {},
    "type": {
      "moduleName": "string",
      "beans?": "any[]",
      "agStackComponents?": "ComponentMeta[]",
      "userComponents?": "{\n    componentName: string;\n    componentClass: any;\n}[]",
      "rowModels?": "{\n    [name: string]: {\n        new (): IRowModel;\n    };\n}",
      "dependantModules?": "Module[]"
    }
  },
  "IPopupComponent": {
    "meta": { "typeParams": ["T"] },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "isPopup?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters.",
      "isPopup?()": "Gets called once after initialised. If you return true, the component will appear in a popup, and it will be\nconstrained to the boundaries of the popupParent. This is great if you want to, for example, provide you own\ncustom dropdown list for selection. Default is false (ie if you don't provide the method).",
      "focusIn?()": "Called when focus is within the component",
      "focusOut?()": "Called when focus is leaving the component"
    }
  },
  "IRangeService": {
    "meta": {},
    "type": {
      "isEmpty()": "boolean",
      "removeAllCellRanges()": "void",
      "getCellRangeCount(cell: CellPosition)": "number",
      "isCellInAnyRange(cell: CellPosition)": "boolean",
      "isCellInSpecificRange(cell: CellPosition, range: CellRange)": "boolean",
      "isBottomRightCell(cellRange: CellRange, cell: CellPosition)": "boolean",
      "isContiguousRange(cellRange: CellRange)": "boolean",
      "isMoreThanOneCell()": "boolean",
      "onDragStart(mouseEvent: MouseEvent)": "void",
      "onDragStop()": "void",
      "onDragging(mouseEvent: MouseEvent)": "void",
      "getCellRanges()": "CellRange[]",
      "setRangeToCell(cell: CellPosition, appendRange?: boolean)": "void",
      "setCellRange(params: CellRangeParams)": "void",
      "addCellRange(params: CellRangeParams)": "void",
      "extendLatestRangeInDirection(key: number)": "CellPosition | undefined",
      "extendLatestRangeToCell(cell: CellPosition)": "void",
      "updateRangeEnd(cellRange: CellRange, cellPosition: CellPosition, silent?: boolean)": "void",
      "getRangeStartRow(cellRange: CellRange)": "RowPosition",
      "getRangeEndRow(cellRange: CellRange)": "RowPosition",
      "createCellRangeFromCellRangeParams(params: CellRangeParams)": "CellRange | undefined",
      "setCellRanges(cellRanges: CellRange[])": "void"
    }
  },
  "ISelectionHandle": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "getType()": "SelectionHandleType",
      "refresh(cellCtrl: CellCtrl)": "void"
    }
  },
  "ISelectionHandleFactory": {
    "meta": {},
    "type": {
      "createSelectionHandle(type: SelectionHandleType)": "ISelectionHandle"
    }
  },
  "SelectionHandleType": {
    "meta": { "isEnum": true },
    "type": ["FILL", "RANGE"]
  },
  "CellRangeType": {
    "meta": { "isEnum": true },
    "type": ["VALUE", "DIMENSION"]
  },
  "CellRange": {
    "meta": {},
    "type": {
      "id?": "string",
      "type?": "CellRangeType",
      "startRow?": "RowPosition",
      "endRow?": "RowPosition",
      "columns": "Column[]",
      "startColumn": "Column"
    }
  },
  "CellRangeParams": {
    "meta": {},
    "type": {
      "rowStartIndex": "number | null",
      "rowStartPinned?": "string | null",
      "rowEndIndex": "number | null",
      "rowEndPinned?": "string | null",
      "columnStart?": "string | Column",
      "columnEnd?": "string | Column",
      "columns?": "(string | Column)[]"
    }
  },
  "RangeSelection": {
    "meta": {},
    "type": {
      "start": "CellPosition",
      "end": "CellPosition",
      "columns": "Column[] | null"
    }
  },
  "AddRangeSelectionParams": {
    "meta": {},
    "type": {
      "rowStart": "number",
      "floatingStart": "string",
      "rowEnd": "number",
      "floatingEnd": "string",
      "columnStart": "string | Column",
      "columnEnd": "string | Column"
    }
  },
  "CellValue": {
    "meta": { "isTypeAlias": true },
    "type": "object | string | number"
  },
  "IRichCellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "values": "CellValue[]",
      "cellHeight": "number",
      "cellRenderer": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "searchDebounceDelay?": "number"
    }
  },
  "RowBounds": {
    "meta": {},
    "type": { "rowTop": "number", "rowHeight": "number", "rowIndex?": "number" }
  },
  "IRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "Returns the rowNode at the given index.",
      "getRowNode(id: string)": "Returns the rowNode for given id.",
      "getRowCount()": "This is legacy, not used by AG Grid, but keeping for backward compatibility",
      "getRowIndexAtPixel(pixel: number)": "Returns the row index at the given pixel",
      "isRowPresent(rowNode: RowNode)": "Returns true if the provided rowNode is in the list of rows to render",
      "getRowBounds(index: number)": "Returns row top and bottom for a given row",
      "isEmpty()": "Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\nout, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\ndon't show that overlay if the rows are just filtered out.",
      "isRowsToRender()": "Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\nuses to know if there are rows to render or not.",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\nthen no rows should be returned",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "Iterate through each node. What this does depends on the model type. For clientSide, goes through\nall nodes. For serverSide, goes through what's loaded in memory.",
      "getType()": "The base class returns the type. We use this instead of 'instanceof' as the client might provide\ntheir own implementation of the models in the future.",
      "isLastRowIndexKnown()": "It tells us if this row model knows about the last row that it can produce. This is used by the\nPaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\nnot shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "Used by CSRM only - is makes sure there are now estimated row heights within the range.",
      "start()": "Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\nfrom gridOptions, the other row models will start calling their datasources."
    }
  },
  "IRowNodeBlock": {
    "meta": {},
    "type": {
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "getDisplayIndexStart()": "number",
      "getDisplayIndexEnd()": "number",
      "getLastAccessed()": "number",
      "getState()": "string",
      "isAnyNodeOpen(rowCount: number)": "boolean",
      "getBlockNumber()": "number",
      "forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number)": "void",
      "forEachNodeShallow(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number)": "void",
      "load()": "void"
    }
  },
  "StageExecuteParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowNodeTransaction?": "RowNodeTransaction | null",
      "rowNodeTransactions?": "RowNodeTransaction[] | null",
      "rowNodeOrder?": "{\n    [id: string]: number;\n}",
      "changedPath?": "ChangedPath",
      "afterColumnsChanged?": "boolean"
    }
  },
  "IRowNodeStage": {
    "meta": {},
    "type": { "execute(params: StageExecuteParams)": "any" }
  },
  "IServerSideGetRowsRequest": {
    "meta": {},
    "type": {
      "startRow": "number",
      "endRow": "number",
      "rowGroupCols": "ColumnVO[]",
      "valueCols": "ColumnVO[]",
      "pivotCols": "ColumnVO[]",
      "pivotMode": "boolean",
      "groupKeys": "string[]",
      "filterModel": "any",
      "sortModel": "any"
    }
  },
  "IServerSideGetRowsParams": {
    "meta": {},
    "type": {
      "request": "IServerSideGetRowsRequest",
      "parentNode": "RowNode",
      "successCallback(rowsThisPage: any[], lastRow: number)": "void",
      "success(params: LoadSuccessParams)": "void",
      "failCallback()": "void",
      "fail()": "void",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "IServerSideDatasource": {
    "meta": {},
    "type": {
      "getRows(params: IServerSideGetRowsParams)": "void",
      "destroy?()": "void"
    }
  },
  "IServerSideRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | null",
      "getRowNode(id: string)": "RowNode | null",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void",
      "refreshStore(params: RefreshStoreParams)": "void",
      "onRowHeightChanged()": "void",
      "getStoreState()": "ServerSideStoreState[]",
      "retryLoads()": "void",
      "expandAll(value: boolean)": "void",
      "setDatasource(datasource: IServerSideDatasource)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void)": "void"
    },
    "docs": {
      "getRow(index: number)": "Returns the rowNode at the given index.",
      "getRowNode(id: string)": "Returns the rowNode for given id.",
      "getRowCount()": "This is legacy, not used by AG Grid, but keeping for backward compatibility",
      "getRowIndexAtPixel(pixel: number)": "Returns the row index at the given pixel",
      "isRowPresent(rowNode: RowNode)": "Returns true if the provided rowNode is in the list of rows to render",
      "getRowBounds(index: number)": "Returns row top and bottom for a given row",
      "isEmpty()": "Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\nout, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\ndon't show that overlay if the rows are just filtered out.",
      "isRowsToRender()": "Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\nuses to know if there are rows to render or not.",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\nthen no rows should be returned",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "Iterate through each node. What this does depends on the model type. For clientSide, goes through\nall nodes. For serverSide, goes through what's loaded in memory.",
      "getType()": "The base class returns the type. We use this instead of 'instanceof' as the client might provide\ntheir own implementation of the models in the future.",
      "isLastRowIndexKnown()": "It tells us if this row model knows about the last row that it can produce. This is used by the\nPaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\nnot shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel.",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "Used by CSRM only - is makes sure there are now estimated row heights within the range.",
      "start()": "Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\nfrom gridOptions, the other row models will start calling their datasources."
    }
  },
  "IServerSideTransactionManager": {
    "meta": {},
    "type": {
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult | undefined",
      "applyTransactionAsync(transaction: ServerSideTransaction, callback?: (res: ServerSideTransactionResult) => void)": "void",
      "flushAsyncTransactions()": "void"
    }
  },
  "RefreshStoreParams": {
    "meta": {},
    "type": { "route?": "string[]", "purge?": "boolean" }
  },
  "IServerSideStore": {
    "meta": {},
    "type": {
      "clearDisplayIndexes()": "void",
      "getDisplayIndexEnd()": "number | undefined",
      "isDisplayIndexInStore(displayIndex: number)": "boolean",
      "setDisplayIndexes(displayIndexSeq: NumberSequence, nextRowTop: {\n    value: number;\n})": "void",
      "forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence?: NumberSequence)": "void",
      "forEachNodeDeepAfterFilterAndSort(callback: (rowNode: RowNode, index: number) => void, sequence?: NumberSequence)": "void",
      "retryLoads()": "void",
      "getRowUsingDisplayIndex(displayRowIndex: number, dontCreateBlock?: boolean)": "RowNode | null",
      "getRowBounds(index: number)": "RowBounds | null",
      "isPixelInRange(pixel: number)": "boolean",
      "getRowIndexAtPixel(pixel: number)": "number | null",
      "getChildStore(keys: string[])": "IServerSideStore | null",
      "refreshAfterSort(params: StoreRefreshAfterParams)": "void",
      "refreshAfterFilter(params: StoreRefreshAfterParams)": "void",
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult",
      "refreshStore(purge: boolean)": "void",
      "getRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "isLastRowIndexKnown()": "boolean",
      "getRowNodesInRange(firstInRange: RowNode, lastInRange: RowNode)": "RowNode[]",
      "addStoreStates(result: ServerSideStoreState[])": "void"
    }
  },
  "StoreRefreshAfterParams": {
    "meta": {},
    "type": {
      "valueColChanged": "boolean",
      "secondaryColChanged": "boolean",
      "alwaysReset": "boolean",
      "changedColumns": "string[]"
    }
  },
  "ServerSideStoreState": {
    "meta": {},
    "type": {
      "type": "ServerSideStoreType",
      "route": "string[]",
      "rowCount": "number",
      "lastRowIndexKnown?": "boolean",
      "info?": "any",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    }
  },
  "SetFilterValuesFuncParams": {
    "meta": {},
    "type": { "success": "(values: string[]) => void", "colDef": "ColDef" }
  },
  "SetFilterValuesFunc": { "meta": {}, "type": {} },
  "SetFilterValues": {
    "meta": { "isTypeAlias": true },
    "type": "SetFilterValuesFunc | any[]"
  },
  "ISetFilterParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "context": "any",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "suppressRemoveEntries?": "boolean",
      "values?": "SetFilterValues",
      "refreshValuesOnOpen?": "boolean",
      "cellHeight?": "number",
      "suppressSorting?": "boolean",
      "cellRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "suppressMiniFilter?": "boolean",
      "applyMiniFilterWhileTyping?": "boolean",
      "suppressSelectAll?": "boolean",
      "defaultToNothingSelected?": "boolean",
      "suppressSyncValuesAfterDataChange?": "boolean",
      "comparator?": "(a: any, b: any) => number",
      "textFormatter?": "(from: string) => string",
      "valueFormatter?": "(params: ValueFormatterParams) => string",
      "selectAllOnMiniFilter?": "boolean",
      "syncValuesLikeExcel?": "boolean",
      "showTooltips?": "boolean",
      "excelMode?": "'mac' | 'windows'"
    }
  },
  "ISideBar": {
    "meta": {},
    "type": {
      "refresh()": "void",
      "setDisplayed(show: boolean)": "void",
      "setSideBarPosition(position?: 'left' | 'right')": "void",
      "isToolPanelShowing()": "boolean",
      "openToolPanel(key: string)": "void",
      "getToolPanelInstance(key: string)": "IToolPanel | undefined",
      "close()": "void",
      "openedItem()": "string | null",
      "isDisplayed()": "boolean"
    }
  },
  "IStatusBarService": {
    "meta": {},
    "type": {
      "registerStatusPanel(key: string, component: IStatusPanelComp)": "void",
      "getStatusPanel(key: string)": "IStatusPanelComp"
    }
  },
  "StatusPanelDef": {
    "meta": {},
    "type": {
      "statusPanel?": "{\n    new (): IStatusPanelComp;\n} | string",
      "statusPanelFramework?": "any",
      "align?": "string",
      "key?": "string",
      "statusPanelParams?": "any"
    }
  },
  "IStatusPanelParams": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "context": "any" }
  },
  "IStatusPanel": { "meta": {}, "type": {} },
  "IStatusPanelComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "IToolPanelParams": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi" }
  },
  "IToolPanel": { "meta": {}, "type": { "refresh()": "void" } },
  "IToolPanelComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "refresh()": "void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "ToolPanelColumnCompParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "suppressRowGroups": "boolean",
      "suppressValues": "boolean",
      "suppressPivots": "boolean",
      "suppressPivotMode": "boolean",
      "suppressColumnFilter": "boolean",
      "suppressColumnSelectAll": "boolean",
      "suppressColumnExpandAll": "boolean",
      "contractColumnSelection": "boolean",
      "suppressSyncLayoutWithGrid": "boolean"
    }
  },
  "IPrimaryColsPanel": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "init(allowDragging: boolean, params: ToolPanelColumnCompParams, eventType: ColumnEventType)": "void",
      "onExpandAll()": "void",
      "onCollapseAll()": "void",
      "expandGroups(groupIds?: string[])": "void",
      "collapseGroups(groupIds?: string[])": "void",
      "setColumnLayout(colDefs: (ColDef | ColGroupDef)[])": "void",
      "syncLayoutWithGrid()": "void"
    }
  },
  "IViewportDatasource": {
    "meta": {},
    "type": {
      "init(params: IViewportDatasourceParams)": "void",
      "setViewportRange(firstRow: number, lastRow: number)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "init(params: IViewportDatasourceParams)": "Gets called exactly once before viewPort is used. Passes methods to be used to tell viewPort of data loads / changes.",
      "setViewportRange(firstRow: number, lastRow: number)": "Tell the viewport what the scroll position of the grid is, so it knows what rows it has to get",
      "destroy?()": "Gets called once when viewPort is no longer used. If you need to do any cleanup, do it here."
    }
  },
  "IViewportDatasourceParams": {
    "meta": {},
    "type": {
      "setRowCount": "(count: number, keepRenderedRows: boolean) => void",
      "setRowData": "(rowData: {\n    [key: number]: any;\n}) => void",
      "getRow": "(rowIndex: number) => RowNode"
    },
    "docs": {
      "setRowCount": "datasource calls this method when the total row count changes. This in turn sets the height of the grids vertical scroll.",
      "setRowData": "datasource calls this when new data arrives. The grid then updates the provided rows. The rows are mapped [rowIndex]=>rowData].",
      "getRow": "datasource calls this when it wants a row node - typically used when it wants to update the row node"
    }
  },
  "XmlElement": {
    "meta": {},
    "type": {
      "name": "string",
      "properties?": "XmlAttributes",
      "children?": "XmlElement[]",
      "textNode?": "string | null"
    }
  },
  "HeaderElement": {
    "meta": {},
    "type": {
      "[key: string]": "string | undefined",
      "version?": "string",
      "standalone?": "string",
      "encoding?": "string"
    }
  },
  "XmlAttributes": {
    "meta": {},
    "type": {
      "prefixedAttributes?": "PrefixedXmlAttributes[]",
      "rawMap?": "any"
    }
  },
  "PrefixedXmlAttributes": {
    "meta": {},
    "type": { "prefix": "string", "map": "any" }
  },
  "RowDataTransaction": {
    "meta": {},
    "type": {
      "addIndex?": "number | null",
      "add?": "any[] | null",
      "remove?": "any[] | null",
      "update?": "any[] | null"
    }
  },
  "RowNodeTransaction": {
    "meta": {},
    "type": { "add": "RowNode[]", "remove": "RowNode[]", "update": "RowNode[]" }
  },
  "ServerSideTransaction": {
    "meta": {},
    "type": {
      "route?": "string[]",
      "addIndex?": "number",
      "add?": "any[]",
      "remove?": "any[]",
      "update?": "any[]"
    }
  },
  "ServerSideTransactionResult": {
    "meta": {},
    "type": {
      "status": "ServerSideTransactionResultStatus",
      "add?": "RowNode[]",
      "remove?": "RowNode[]",
      "update?": "RowNode[]"
    }
  },
  "ServerSideTransactionResultStatus": {
    "meta": { "isEnum": true },
    "type": [
      "StoreNotFound = 'StoreNotFound'",
      "StoreLoading = 'StoreLoading'",
      "StoreWaitingToLoad = 'StoreWaitingToLoad'",
      "StoreLoadingFailed = 'StoreLoadingFailed'",
      "StoreWrongType = 'StoreWrongType'",
      "Applied = 'Applied'",
      "Cancelled = 'Cancelled'"
    ]
  },
  "TabbedLayoutParams": {
    "meta": {},
    "type": {
      "items": "TabbedItem[]",
      "cssClass?": "string",
      "onItemClicked?": "Function",
      "onActiveItemClicked?": "Function"
    }
  },
  "TabbedItem": {
    "meta": {},
    "type": {
      "title": "Element",
      "titleLabel": "string",
      "bodyPromise": "AgPromise<HTMLElement>",
      "name": "string",
      "afterAttachedCallback?": "(params: IAfterGuiAttachedParams) => void"
    }
  },
  "TabbedItemWrapper": {
    "meta": {},
    "type": { "tabbedItem": "TabbedItem", "eHeaderButton": "HTMLElement" }
  },
  "TaskItem": {
    "meta": {},
    "type": { "task": "() => void", "index": "number", "createOrder": "number" }
  },
  "TaskList": {
    "meta": {},
    "type": { "list": "TaskItem[]", "sorted": "boolean" }
  },
  "SimpleHttpRequestParams": { "meta": {}, "type": { "url": "string" } },
  "ModuleNames": {
    "meta": { "isEnum": true },
    "type": [
      "CommunityCoreModule = \"@ag-grid-community/core\"",
      "CommunityAllModules = \"@ag-grid-community/all\"",
      "InfiniteRowModelModule = \"@ag-grid-community/infinite-row-model\"",
      "ClientSideRowModelModule = \"@ag-grid-community/client-side-row-model\"",
      "CsvExportModule = \"@ag-grid-community/csv-export\"",
      "EnterpriseCoreModule = \"@ag-grid-enterprise/core\"",
      "EnterpriseAllModules = \"@ag-grid-enterprise/all\"",
      "RowGroupingModule = \"@ag-grid-enterprise/row-grouping\"",
      "ColumnToolPanelModule = \"@ag-grid-enterprise/column-tool-panel\"",
      "FiltersToolPanelModule = \"@ag-grid-enterprise/filter-tool-panel\"",
      "MenuModule = \"@ag-grid-enterprise/menu\"",
      "SetFilterModule = \"@ag-grid-enterprise/set-filter\"",
      "MultiFilterModule = \"@ag-grid-enterprise/multi-filter\"",
      "StatusBarModule = \"@ag-grid-enterprise/status-bar\"",
      "SideBarModule = \"@ag-grid-enterprise/side-bar\"",
      "RangeSelectionModule = \"@ag-grid-enterprise/range-selection\"",
      "MasterDetailModule = \"@ag-grid-enterprise/master-detail\"",
      "RichSelectModule = \"@ag-grid-enterprise/rich-select\"",
      "GridChartsModule = \"@ag-grid-enterprise/charts\"",
      "ViewportRowModelModule = \"@ag-grid-enterprise/viewport-row-model\"",
      "ServerSideRowModelModule = \"@ag-grid-enterprise/server-side-row-model\"",
      "ExcelExportModule = \"@ag-grid-enterprise/excel-export\"",
      "ClipboardModule = \"@ag-grid-enterprise/clipboard\"",
      "AngularModule = \"@ag-grid-community/angular\"",
      "ReactModule = \"@ag-grid-community/react\"",
      "VueModule = \"@ag-grid-community/vue\"",
      "PolymerModule = \"@ag-grid-community/polymer\""
    ]
  },
  "ICellComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setUserStyles(styles: any)": "void",
      "setAriaSelected(selected: boolean | undefined)": "void",
      "setAriaExpanded(expanded: boolean)": "void",
      "getFocusableElement()": "HTMLElement",
      "setLeft(left: string)": "void",
      "setWidth(width: string)": "void",
      "setAriaColIndex(index: number)": "void",
      "setHeight(height: string)": "void",
      "setZIndex(zIndex: string)": "void",
      "setTabIndex(tabIndex: number)": "void",
      "setRole(role: string)": "void",
      "setColId(colId: string)": "void",
      "setTitle(title: string | undefined)": "void",
      "setUnselectable(value: 'on' | null)": "void",
      "setTransition(value: string | undefined)": "void",
      "setIncludeSelection(include: boolean)": "void",
      "setIncludeRowDrag(include: boolean)": "void",
      "setIncludeDndSource(include: boolean)": "void",
      "setForceWrapper(force: boolean)": "void",
      "getCellEditor()": "ICellEditor | null",
      "getCellRenderer()": "ICellRenderer | null",
      "getParentOfValue()": "HTMLElement | null",
      "setRenderDetails(compDetails: UserCompDetails | undefined, valueToDisplay: any, forceNewCellRendererInstance: boolean)": "void",
      "setEditDetails(compDetails?: UserCompDetails, popup?: boolean, position?: string)": "void"
    }
  },
  "ILargeTextEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "maxLength": "number",
      "rows": "number",
      "cols": "number"
    }
  },
  "ISelectCellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "values": "any[]"
    }
  },
  "ITextCellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any",
      "useFormatter": "boolean"
    }
  },
  "IGroupCellRenderer": {
    "meta": {},
    "type": {
      "setInnerRenderer(compDetails: UserCompDetails | undefined, valueToDisplay: any)": "void",
      "setChildCount(count: string)": "void",
      "setCheckboxVisible(value: boolean)": "void",
      "setExpandedDisplayed(value: boolean)": "void",
      "setContractedDisplayed(value: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "GroupCellRendererParams": {
    "meta": {},
    "type": {
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "value": "any",
      "valueFormatted": "any",
      "data": "any",
      "node": "RowNode",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string) => void",
      "pinned": "string",
      "fullWidth": "boolean",
      "suppressPadding": "boolean",
      "suppressDoubleClickExpand": "boolean",
      "suppressEnterExpand": "boolean",
      "footerValueGetter": "any",
      "suppressCount": "boolean",
      "checkbox": "any",
      "rowDrag?": "boolean",
      "innerRenderer?": "{\n    new (): ICellRendererComp;\n} | ICellRendererFunc | string",
      "innerRendererFramework?": "any",
      "innerRendererParams?": "any",
      "scope": "any",
      "padding": "number"
    },
    "docs": { "registerRowDragger": "registerRowDragger: Function" }
  },
  "ICellRendererParams": {
    "meta": {},
    "type": {
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "value": "any",
      "valueFormatted": "any",
      "data": "any",
      "node": "RowNode",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string) => void"
    },
    "docs": { "registerRowDragger": "registerRowDragger: Function" }
  },
  "ISetFilterCellRendererParams": {
    "meta": {},
    "type": {
      "value": "any",
      "valueFormatted": "any",
      "api": "GridApi",
      "context": "any"
    }
  },
  "ICellRenderer": {
    "meta": {},
    "type": { "refresh(params: ICellRendererParams)": "boolean" },
    "docs": {
      "refresh(params: ICellRendererParams)": "Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\nthen the grid will refresh the cell for you."
    }
  },
  "ICellRendererComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void",
      "refresh(params: ICellRendererParams)": "boolean"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters.",
      "refresh(params: ICellRendererParams)": "Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\nthen the grid will refresh the cell for you."
    }
  },
  "ICellRendererFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "any" },
      "returnType": "HTMLElement | string"
    }
  },
  "ILoadingCellRendererParams": {
    "meta": {},
    "type": {
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "value": "any",
      "valueFormatted": "any",
      "data": "any",
      "node": "RowNode",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string) => void"
    },
    "docs": { "registerRowDragger": "registerRowDragger: Function" }
  },
  "ILoadingCellRenderer": {
    "meta": {},
    "type": { "refresh(params: ICellRendererParams)": "boolean" },
    "docs": {
      "refresh(params: ICellRendererParams)": "Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\nthen the grid will refresh the cell for you."
    }
  },
  "IDate": {
    "meta": {},
    "type": {
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void"
    },
    "docs": {
      "getDate()": "Returns the current date represented by this editor",
      "setDate(date: Date | null)": "Sets the date represented by this component"
    }
  },
  "IDateParams": {
    "meta": {},
    "type": {
      "onDateChanged": "() => void",
      "filterParams": "IDateFilterParams"
    },
    "docs": {
      "onDateChanged": "Method for component to tell AG Grid that the date has changed."
    }
  },
  "IDateComp": {
    "meta": {},
    "type": {
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getDate()": "Returns the current date represented by this editor",
      "setDate(date: Date | null)": "Sets the date represented by this component",
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "PositionableOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "Used for when a popup needs to be resized by an element within itself\nIn that case, the feature will configured as `popup=false` but the offsetParent\nneeds to be the popupParent."
    }
  },
  "ResizableSides": {
    "meta": { "isTypeAlias": true },
    "type": "'topLeft' | 'top' | 'topRight' | 'right' | 'bottomRight' | 'bottom' | 'bottomLeft' | 'left'"
  },
  "ResizableStructure": { "meta": {}, "type": {} },
  "MappedResizer": {
    "meta": {},
    "type": { "element": "HTMLElement", "dragSource?": "DragListenerParams" }
  },
  "ILoadingOverlayParams": { "meta": {}, "type": { "api": "GridApi" } },
  "ILoadingOverlayComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "INoRowsOverlayParams": { "meta": {}, "type": { "api": "GridApi" } },
  "INoRowsOverlayComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "LoadingType": { "meta": { "isEnum": true }, "type": ["Loading", "NoRows"] },
  "RowCssClassCalculatorParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowIsEven": "boolean",
      "rowLevel": "number",
      "fullWidthRow?": "boolean",
      "firstRowOnPage": "boolean",
      "lastRowOnPage": "boolean",
      "printLayout": "boolean",
      "expandable": "boolean",
      "pinned?": "string | null",
      "extraCssClass?": "string",
      "rowFocused?": "boolean",
      "fadeRowIn?": "boolean",
      "scope?": "any"
    }
  },
  "RowType": {
    "meta": { "isEnum": true },
    "type": [
      "Normal = 'Normal'",
      "FullWidth = 'FullWidth'",
      "FullWidthLoading = 'FullWidthLoading'",
      "FullWidthGroup = 'FullWidthGroup'",
      "FullWidthDetail = 'FullWidthDetail'"
    ]
  },
  "IRowComp": {
    "meta": {},
    "type": {
      "setDisplay(value?: string)": "void",
      "setDomOrder(domOrder: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setCellCtrls(cellCtrls: CellCtrl[])": "void",
      "showFullWidth(compDetails: UserCompDetails)": "void",
      "getFullWidthRowComp()": "ICellRendererComp | null | undefined",
      "setAriaExpanded(on: boolean)": "void",
      "destroyCells(cellComps: CellComp[])": "void",
      "setAriaSelected(selected: boolean | undefined)": "void",
      "setHeight(height: string)": "void",
      "destroy()": "void",
      "setTop(top: string)": "void",
      "setTransform(transform: string)": "void",
      "setRowIndex(rowIndex: string)": "void",
      "setAriaRowIndex(rowIndex: number)": "void",
      "setRowId(rowId: string)": "void",
      "setRowBusinessKey(businessKey: string)": "void",
      "setTabIndex(tabIndex: number)": "void",
      "setAriaLabel(label: string | undefined)": "void",
      "setUserStyles(styles: any)": "void",
      "setRole(role: string)": "void"
    }
  },
  "RowGui": {
    "meta": {},
    "type": {
      "rowComp": "IRowComp",
      "element": "HTMLElement",
      "pinned": "string | null"
    }
  },
  "CellCtrlListAndMap": {
    "meta": {},
    "type": {
      "list": "CellCtrl[]",
      "map": "{\n    [key: string]: CellCtrl;\n}"
    }
  },
  "IRowDragItem": {
    "meta": {},
    "type": {
      "rowNode?": "RowNode",
      "rowNodes?": "RowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{\n    [key: string]: boolean;\n}",
      "defaultTextValue": "string"
    },
    "docs": {
      "rowNode?": "When dragging a row, this contains the row node being dragged\nWhen dragging multiple rows, this contains the row that started the drag.",
      "rowNodes?": "When dragging multiple rows, this contains all rows being dragged",
      "columns?": "When dragging columns, this contains the columns being dragged",
      "visibleState?": "When dragging columns, this contains the visible state of the columns"
    }
  },
  "RowCtrlMap": { "meta": {}, "type": { "[key: string]": "RowCtrl" } },
  "RefreshViewParams": {
    "meta": {},
    "type": {
      "recycleRows?": "boolean",
      "animate?": "boolean",
      "suppressKeepFocus?": "boolean",
      "onlyBody?": "boolean",
      "newData?": "boolean",
      "newPage?": "boolean"
    }
  },
  "ITooltipParams": {
    "meta": {},
    "type": {
      "location": "string",
      "api?": "GridApi",
      "columnApi?": "ColumnApi",
      "context?": "any",
      "colDef?": "ColDef | ColGroupDef | null",
      "column?": "Column | ColumnGroup",
      "value?": "any",
      "valueFormatted?": "any",
      "rowIndex?": "number",
      "node?": "RowNode",
      "data?": "any"
    }
  },
  "ITooltipComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "Return the DOM element of your component, this is what the grid puts into the DOM",
      "destroy?()": "Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "A hook to perform any necessary operation just after the GUI for this component has been rendered\non the screen.\nIf a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\nThis is useful for any\nlogic that requires attachment before executing, such as putting focus on a particular DOM\nelement. The params has one callback method 'hidePopup', which you can call at any later\npoint to hide the popup - good if you have an 'Apply' button and you want to hide the popup\nafter it is pressed.",
      "init?(params: T)": "The init(params) method is called on the component once. See below for details on the parameters."
    }
  },
  "LoadCompleteEvent": {
    "meta": {},
    "type": { "type": "string", "success": "boolean", "block": "RowNodeBlock" },
    "docs": { "type": "Event identifier" }
  },
  "LoadSuccessParams": {
    "meta": {},
    "type": { "rowData": "any[]", "rowCount?": "number", "storeInfo?": "any" }
  },
  "SortOption": {
    "meta": {},
    "type": { "sort": "string", "column": "Column" }
  },
  "SortedRowNode": {
    "meta": {},
    "type": { "currentPos": "number", "rowNode": "RowNode" }
  },
  "SortModelItem": {
    "meta": {},
    "type": { "colId": "string", "sort": "string" }
  },
  "LayoutView": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "LayoutCssClasses": {
    "meta": { "isEnum": true },
    "type": [
      "AUTO_HEIGHT = 'ag-layout-auto-height'",
      "NORMAL = 'ag-layout-normal'",
      "PRINT = 'ag-layout-print'"
    ]
  },
  "UpdateLayoutClassesParams": {
    "meta": {},
    "type": { "autoHeight": "boolean", "normal": "boolean", "print": "boolean" }
  },
  "GenericFunction": { "meta": {}, "type": {} },
  "PickByTypeKeyFilter": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "KeysByType": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "ValuesByType": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "PickByType": { "meta": { "typeParams": ["T", "C"] }, "type": {} },
  "MethodsOf": { "meta": { "typeParams": ["T"] }, "type": {} },
  "InterfaceOf": { "meta": { "typeParams": ["T"] }, "type": {} },
  "PartiallyMockedInterfaceOf": { "meta": { "typeParams": ["T"] }, "type": {} },
  "CellValueChange": {
    "meta": {},
    "type": {
      "rowPinned?": "string | null",
      "rowIndex": "number",
      "columnId": "string",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "LastFocusedCell": {
    "meta": {},
    "type": {
      "rowPinned?": "string | null",
      "rowIndex": "number",
      "columnId": "string"
    }
  },
  "ColumnSortState": {
    "meta": { "isTypeAlias": true },
    "type": "'ascending' | 'descending' | 'none'"
  },
  "PathItem": {
    "meta": {},
    "type": { "rowNode": "RowNode", "children": "PathItem[] | null" }
  },
  "ResolveAndRejectCallback": { "meta": { "typeParams": ["T"] }, "type": {} },
  "AgPromiseStatus": {
    "meta": { "isEnum": true },
    "type": ["IN_PROGRESS", "RESOLVED"]
  },
  "FieldElement": {
    "meta": { "isTypeAlias": true },
    "type": "HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement"
  },
  "IInputField": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "value?": "any",
      "width?": "number"
    }
  },
  "LabelAlignment": {
    "meta": { "isTypeAlias": true },
    "type": "'left' | 'right' | 'top'"
  },
  "IAgLabel": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment"
    }
  },
  "ChangeEvent": {
    "meta": {},
    "type": { "type": "string", "selected": "boolean" },
    "docs": { "type": "Event identifier" }
  },
  "ColorPickerConfig": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "color": "string"
    }
  },
  "DialogOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null",
      "component?": "Component",
      "hideTitleBar?": "boolean | null",
      "closable?": "boolean | null",
      "resizable?": "boolean | ResizableStructure",
      "title?": "string | null",
      "cssIdentifier?": "string | null",
      "eWrapper?": "HTMLElement",
      "modal?": "boolean",
      "movable?": "boolean",
      "alwaysOnTop?": "boolean",
      "maximizable?": "boolean"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "Used for when a popup needs to be resized by an element within itself\nIn that case, the feature will configured as `popup=false` but the offsetParent\nneeds to be the popupParent."
    }
  },
  "GroupItem": {
    "meta": { "isTypeAlias": true },
    "type": "Component | HTMLElement"
  },
  "Align": {
    "meta": { "isTypeAlias": true },
    "type": "'start' | 'end' | 'center' | 'stretch'"
  },
  "Direction": {
    "meta": { "isTypeAlias": true },
    "type": "'horizontal' | 'vertical'"
  },
  "AgGroupComponentParams": {
    "meta": {},
    "type": {
      "title?": "string",
      "enabled?": "boolean",
      "suppressEnabledCheckbox?": "boolean",
      "suppressOpenCloseIcons?": "boolean",
      "cssIdentifier?": "string",
      "items?": "GroupItem[]",
      "alignItems?": "Align",
      "direction?": "Direction"
    }
  },
  "IInputRange": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "value?": "any",
      "width?": "number",
      "min?": "number",
      "max?": "number",
      "step?": "number"
    }
  },
  "ITextInputField": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment",
      "value?": "any",
      "width?": "number",
      "allowedCharPattern?": "string"
    }
  },
  "ListOption": {
    "meta": {},
    "type": { "value": "string", "text?": "string" }
  },
  "PanelOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null",
      "component?": "Component",
      "hideTitleBar?": "boolean | null",
      "closable?": "boolean | null",
      "resizable?": "boolean | ResizableStructure",
      "title?": "string | null",
      "cssIdentifier?": "string | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "Used for when a popup needs to be resized by an element within itself\nIn that case, the feature will configured as `popup=false` but the offsetParent\nneeds to be the popupParent."
    }
  },
  "VisibleChangedEvent": {
    "meta": {},
    "type": { "type": "string", "visible": "boolean" },
    "docs": { "type": "Event identifier" }
  },
  "ManagedFocusCallbacks": {
    "meta": {},
    "type": {
      "shouldStopEventPropagation?": "(e: KeyboardEvent) => boolean",
      "onTabKeyDown?": "(e: KeyboardEvent) => void",
      "handleKeyDown?": "(e: KeyboardEvent) => void",
      "onFocusIn?": "(e: FocusEvent) => void",
      "onFocusOut?": "(e: FocusEvent) => void"
    }
  },
  "PopupEventParams": {
    "meta": {},
    "type": {
      "originalMouseEvent?": "MouseEvent | Touch | null",
      "mouseEvent?": "MouseEvent",
      "touchEvent?": "TouchEvent",
      "keyboardEvent?": "KeyboardEvent"
    }
  },
  "AgPopup": {
    "meta": {},
    "type": {
      "element": "HTMLElement",
      "wrapper": "HTMLElement",
      "hideFunc": "() => void",
      "stopAnchoringPromise": "AgPromise<Function>",
      "instanceId": "number"
    }
  },
  "Rect": {
    "meta": {},
    "type": {
      "top": "number",
      "left": "number",
      "right": "number",
      "bottom": "number"
    }
  },
  "DIRECTION": {
    "meta": { "isEnum": true },
    "type": ["vertical", "horizontal"]
  },
  "AddPopupParams": {
    "meta": {},
    "type": {
      "modal?": "boolean",
      "eChild": "any",
      "closeOnEsc?": "boolean",
      "closedCallback?": "(e?: MouseEvent | TouchEvent | KeyboardEvent) => void",
      "click?": "MouseEvent | Touch | null",
      "alwaysOnTop?": "boolean",
      "afterGuiAttached?": "(params: IAfterGuiAttachedParams) => void",
      "positionCallback?": "() => void",
      "anchorToElement?": "HTMLElement"
    }
  },
  "AddPopupResult": {
    "meta": {},
    "type": {
      "hideFunc": "() => void",
      "stopAnchoringPromise": "AgPromise<Function>"
    }
  },
  "ITabGuard": {
    "meta": {},
    "type": { "setTabIndex(tabIndex?: string)": "void" }
  },
  "TooltipParentComp": {
    "meta": {},
    "type": {
      "getTooltipParams()": "ITooltipParams",
      "getGui()": "HTMLElement"
    }
  },
  "TooltipStates": {
    "meta": { "isEnum": true },
    "type": ["NOTHING", "WAITING_TO_SHOW", "SHOWING"]
  },
  "TapEvent": {
    "meta": {},
    "type": { "type": "string", "touchStart": "Touch" },
    "docs": { "type": "Event identifier" }
  },
  "LongTapEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "touchStart": "Touch",
      "touchEvent": "TouchEvent"
    },
    "docs": { "type": "Event identifier" }
  },
  "VirtualListModel": {
    "meta": {},
    "type": {
      "getRowCount()": "number",
      "getRow(index: number)": "any",
      "isRowSelected?(index: number)": "boolean | undefined"
    }
  }
}
